[{"categories":null,"content":"关于网站 个人博客 ","date":"2023-01-11","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我 科技后浪 喜欢效率和极简，喜欢看电影、读书（2022读书为0）、旅行和健身（不花钱）、练字（一时兴起） 想在这短短的一生中体验这世间美好的一切 ","date":"2023-01-11","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有的原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容（包含文字、自制图像、摄影作品）时请遵守以下版权要求： 注明转载 注明来源为本站首页网址 tenonzzz.github.io，或所转内容在本站的完整网址 本站图片部分来自互联网。 此类图片的原版权所有者可在任何时候、以任何理由要求本站停止使用有关图片，其中包括被本站编辑（比如加注中文说明）过的图片， 联系方式见本站首页。 ","date":"2023-01-11","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["我所热爱的生活啊"],"content":"每次买东西纠结个半天，最后买回来还不一定合心意，所以打算梳理一下购物的流程，希望能提供一些参考，给以后的购物节省一些时间，同时减小冲动消费的概率。 ","date":"2022-01-04","objectID":"/2022/shopping-process/:0:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"想买东西的时刻 把几个电商平台的购物历史浏览了一遍之后，根据当初买东西的出发点，分成了以下几种不同的情况。 已有同类物品。此时又分为三种子情况，第一种是原物品用完了或到期了，常见于有保质期的化妆品、药物以及各类日常消耗品（牙刷、卫生纸等）；第二种是原物品损坏，必须换，或者半损坏，用着很不舒服；第三种则是原物品不喜欢，可能是日积月累看腻了，也可能是本来就不喜欢，勉勉强强用到现在。 没有同类物品。此时分为两种子情况，第一种是由于生活中遇到的各种问题诞生的需求，第二种则是来自各种文章视频或者来自身边朋友的安利，或者是单纯的凑单需求。 拿最近两个月买的东西举个例子 物品名 一级分类 二级说明 小米10s手机壳 已有 原物品不喜欢 免打孔吹风机置物架 没有 浴室储物架杂乱诞生的收纳需求 Keep手环b2腕带 已有 原物品损坏 双耳泡面碗+筷勺套装 没有 周末吃饭没有餐具诞生的需求 药箱 没有 药品和医疗器械储备存放诞生的需求 羽绒服 已有 原物品半损坏 折叠裤架 没有 被安利 哑铃 没有 室内健身需求 手账本 已有 原物品用完了 无痕衣架 已有 原物品不喜欢 ","date":"2022-01-04","objectID":"/2022/shopping-process/:1:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"购物冲动自评 做到理性消费的核心是诞生了购买欲后做一个自评，自评的核心有两点，一是买这个物品有没有必要，二是需不需要立即买。 关于购买的必要性，其实评价维度很多，已有的物品用完了、到期了、损坏了，这些都毫无疑问需要马上购买，但储备的物品还有一半突然遇到打折了，比如卫生纸，或者物品半损坏，比如插排出现了电流声，这个时候就会有一点纠结。更进一步的，遇到物品不喜欢的情况，比如以前买的衣服，因为没法和其它衣服搭配，变得不喜欢了，或者买手机送的手机壳，虽然可以使用，但就是不喜欢，这时候是否买一个新的来替换，纠结程度就更多一点。这两种情况我一般是看当月的预算是否还足够，以及与之同时的是否有其它购买需求，如果预算足够且没有其它购买需求的话，一般就买了。 另外，生活中诞生的需求，也需要区分是真需求还是伪需求。我的办法有两个，一个是判断买回来是立即投入使用，还是作为储备，另一个是了解完商品情况及分析了自己的需要后，判断是否能满足自己的需要。比如，免打孔吹风机置物架是买回来马上就用且立马就能使得浴室空间焕然一新的，双耳泡面碗+筷勺套装则是立马就解决了周末吃饭问题的，但用来洗内裤袜子的小洗衣机，经过了解后就发现完全属于鸡肋，没法完全满足需求，因此就不必购买。 ","date":"2022-01-04","objectID":"/2022/shopping-process/:2:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"了解商品情况 线下还是线上 有空的话线下逛一圈，看看有没有想要的样式以及多少钱 网上样式较多，但是没法上手看，很多方面只能买回来才能看到，退换成本较高 去哪儿翻评测或找咨询 B站各专业细分方向的评测，普通人的开箱、使用体验 知乎的购买建议，仅供参考 小红书的购买建议，仅供参考 同类比较， 这个产品有几种不同样式，每种的优缺点是啥 确定产品样式后自己翻各个平台全网比价 确定商品后全网比价，以及查询商品历史价格 主要看样式喜不喜欢，功能能不能满足自己需要，注意不需要为多余的功能付额外的钱 问清楚客服自己不清楚的事项 网购能不能搞价？ 买回来能不能退 注意买退货保险 注意会员权限中的免费退换货 注意退换货的条件 退不了的咋处理 二手回血，心里要想着卖了还能回点血，不卖血本无归 送人 扔掉 如何做金钱和时间的平衡，什么价位的东西值得付出什么样的时间和精力 一个几块钱的东西挑个一星期，不值得，这个价位可以定到10块、20块，根据自己经济情况看 每个月做预算，超出预算的部分可以下个月买 想买的东西记录到表格 ","date":"2022-01-04","objectID":"/2022/shopping-process/:3:0","tags":["生活技能"],"title":"购物流程","uri":"/2022/shopping-process/"},{"categories":["我所热爱的生活啊"],"content":"思考一些关于未来的担忧，包括人生之路、婚姻、自己意外身亡、父母生病等等。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:0:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"未来 现在这个时代，大家都焦虑未来，尤其是像鞭子一样高悬在我们身后的房价，更是让人不敢懈怠。最近一个名为 人生重开模拟器 的小游戏爆火，玩的时候就发现，无论你这一生是困苦还是辉煌，甚至活到 100 岁开启修仙之路，最后你还是忍不住点下最后的「再次重开」的选项，那么，对于现实里只有一次的人生，又哪有什么甘愿呢，心里怕总是会有「如果我当初选择了……」这样的想法吧。电影《无姓之人》里，主角尼莫有着能看到未来的能力，然而面对不同选择所衍生的无数时间线，直到死亡也没能做出决定（仅是我的理解），白白蹉跎了一生，所以我觉得其实最重要的是做出选择后坚定的往前走，而不是永远纠结然后被动做出选择。 很小很小就开始读书，然后一毕业就陷入现代社会围绕婚姻和生育形成的固定模板，买房、彩礼、结婚、生育，两代人甚至更多人的积蓄被迅速花完，然后陷入抚育第三代的轮回，再难抽身去做其它尝试。不能说未来再也没有可能，只是以普遍理性而言（狗头保命），真的就少了太多的可能。我不是坚持终身单身的人，如果你问我，想要一个可以共度余生、分享自己的所有喜怒哀乐的人吗？我的答案是肯定的，但如果要绑定未来的人生，或许要再考虑一下。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:1:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"健康 周期性的体检是监测自身健康状况的有效手段，这方面其实我们关心两件事，一是去哪儿体检，二是应该体检哪些项目，@刀客特Leslie 在 年轻人的体检指南 01：体检在检查什么 中做了详细解释，并在最后给出了一个总结性的思维导图（如下）。 另外，丁香医生也有一篇 别再花冤枉钱了，要做的体检项目就这些 | 内附体检清单 参考，有根据具体年龄的推荐。 其实除了自己定期体检外，最难的是说服父母体检，和说服父母坚持锻炼一样难。 父母病了如何陪床 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:2:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"身后事 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:0","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"遗嘱 谁也不能说自己永远不会发生意外，尤其是本科毕业的时候同专业的同学猝死，眼见着前一天还在楼道大喊大叫的同学第二天就没了，心里自然会诞生些许忧虑。后来有时候就想，如果自己也发生了这样的事怎么办，父母会不会太伤心，要不要留一封信安慰一下父母，自己那些珍视的事物父母会好好保留吗，银行卡密码、网上各种账户的密码没人知道怎么办，所以很早就动了留一份遗嘱的念头，只是最近才抽出时间做这件事 。首要就是两份法规的阅读 👉 《中华人民共和国民法典》第六编　继承 👉 最高人民法院关于适用《中华人民共和国民法典》继承编的解释 民法典第六编第三章即是关于遗嘱继承和遗赠的相关条目，其中将遗嘱分为以下几类 自书遗嘱：由遗嘱人亲笔书写，签名，注明年、月、日。 代书遗嘱：应当有两个以上见证人在场见证，由其中一人代书，并由遗嘱人、代书人和其他见证人签名，注明年、月、日。 打印遗嘱：应当有两个以上见证人在场见证。遗嘱人和见证人应当在遗嘱每一页签名，注明年、月、日。 以录音录像形式立的遗嘱：应当有两个以上见证人在场见证。遗嘱人和见证人应当在录音录像中记录其姓名或者肖像，以及年、月、日。 遗嘱人在危急情况下，可以立口头遗嘱。口头遗嘱应当有两个以上见证人在场见证。危急情况消除后，遗嘱人能够以书面或者录音录像形式立遗嘱的，所立的口头遗嘱无效。 公证遗嘱：由遗嘱人经公证机构办理。 首先要考虑遗嘱的有效性，可以看到，除自书遗嘱外，其它几种遗嘱均应有见证人在场，而民法典中规定见证人不可以是继承人、与继承人有利害关系的人以及 无民事行为能力或限制民事行为能力的人，所以这一条首先就对我们提出了挑战。再考虑到年轻人思想变化、财产变化都比较快，遗嘱的更新频率也会比较快，因此，自书遗嘱是我们最好的选择。 具有完全的民事行为能力：年满18周岁且精神状态正常的人 自书遗嘱的生效条件如下 由遗嘱人亲笔书写，签名，注明年、月、日 立遗嘱人必须具有完全的民事行为能力。无行为能力人所立的遗嘱，即使其本人后来有了行为能力，仍属无效遗嘱 遗嘱必须表示遗嘱人的真实意思，受欺诈、胁迫所立的遗嘱无效 伪造的遗嘱无效，遗嘱被篡改的，篡改的内容无效 遗嘱人以遗嘱处分了国家、集体或者他人财产的，应当认定该部分遗嘱无效 第一条的核心在于亲笔书写、亲笔签名以及注明年、月、日，如需涂改、增删还要在涂改、增删处签名并注明时间，否则，涂改、增删的内容无效。这里的日期是在有多份遗嘱时确定各份遗嘱先后的准据，只有日期最近的遗嘱有效。另外，关于受胁迫判定的问题，只要没有证据证明是在受到胁迫的情况下立遗嘱的，就是没有受到胁迫。最后，遗嘱格式参考下面的链接，事实上我也不确定网上这些模板是否可用，一个比较好的办法是第一次前往专业机构咨询和拟定遗嘱，之后按照这份遗嘱模板自己写就好，目前在网上查到的影响力大的专业机构是 中华遗嘱库 。 📝 遗嘱范本【标准版】 以已有的知识，或者从民法典中可以看到，遗产的第一顺序继承人为配偶、子女、父母，第二顺序继承人为兄弟姐妹、祖父母、外祖父母。所以这就意味着其实以我自己，可能也是很多年轻人的情况——没有配偶（更别提子女），即使我们没有留遗嘱，或者遗嘱无效，所留财产依法也是父母继承，因此目前更应该关注的是如何将自己拥有的财产清单、所珍视的物品、各种账户密码、对父母想说的话等留一个备份，并能在自己去世后及时的送达父母手里。当然，也要保证平时不会被父母随便找到，不然又是一场大型社死现场，这个地方就要自己好好斟酌了。对于我自己而言，我在 Notion 里动态更新着一份物品清单和账户密码清单，所以我只需要准备如下材料即可 电脑密码，Notion及账户密码及其内清单的简单说明； 对我有重要意义的物品清单，清单中每个物品的意义； 以何种方式安葬； 想对父母说的话。 所有这些放在火漆印章封好的信封里，父母不会随便打开这种封好的文件的。 ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:1","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["我所热爱的生活啊"],"content":"葬礼 父母终有百年之后，事先了解一下丧葬办理程序，可以避免到时候的手忙脚乱，以下是中国殡葬协会给出的处理程序1： 开具死亡证明：当亲人去世后，死者家属或单位必须取得死亡证明：正常死亡的，由医疗卫生机构出具医学死亡证明；非正常死亡的，由区、县以上公安、司法部门出具死亡证明。 注销户口：死者家属持死亡证明书到驻地派出所注销户口。 联系火化 打电话或派人前往殡仪馆或殡葬服务站联系火化，登记死者姓名、住址、年龄、性别、死亡原因、死亡时间、遗体所在地、死者户口所在地； 登记家属姓名、住址、电话、与死者关系等； 预定殡葬服务项目，服务时间。 接运遗体：按预定时间，家属持死亡证明在指定地点等候灵车接运遗体。 遗体火化：遗体运送到殡仪馆，经过整容后举行告别仪式，然后进行火化并领取火化证明，火化完毕后领取骨灰装入实现选购的骨灰盒中。 骨灰安放：可以临时骨灰寄存，也可以选择各种葬式安放。 葬式类型除了传统的土葬外，火化后的骨灰有如下存放方式：骨灰堂、骨灰墙、骨灰廊、骨灰林、骨灰墓以及各种生态葬。父母选择何种葬式是他们的自由，需要尊重，但就我自己而言，眼见着广大的农村坟头林立，城市的墓碑又贵出天际，遗体捐赠和生态葬进入了我的视线。事实上从我小时候被村里的坟头吓到开始，就下定决心自己绝对不要以这种方式安葬，长大后又看到骨灰堂那一个个小格子，想着自己活着的时候住格子间，死了还要住格子间，还不如尘归尘土归土，更加坚定了信心，所以在上面的遗嘱中才会专门加入这一条。 一些细则和注意事项可以查看民政部发布的 殡葬管理条例（2012年修正本）和各地区自己的殡葬管理办法，这里要注意，在我自己所在地区的殡葬管理办法中看到了如下描述，在需要不断缴费的情况下，几乎已经可以肯定自己的墓穴一定会沦为无主穴位，而目前没有找到资料描述「无主穴位」究竟如何处理，因此，考虑海葬等生态葬又多了一条理由。 凡在公墓和骨灰存放设施安放骨灰，应按规定缴纳费用。逾期三个月不缴纳的按无主穴位处理。 以天津天海海葬服务中心 官网 给出的描述看，整体流程如下： 提前打进电话预约登记。 确定海葬进行的时间，以及随行人数。 缴纳海葬定金。 到指定地点进行海葬活动 海葬活动的具体流程如下 全体参加海葬的丧家起立,向本次骨灰海葬的先人默哀； 丧家将鲜花花瓣与骨灰相拌； 丧家陆续将拌有鲜花的骨灰撒向大海 ； 向先人海葬地献花海撒用品，鲜花、花瓣、手套、口罩等均免费提供。 嗯，我决定了，我以后就海葬。 中国殡葬协会，丧葬办理程序，2010-12. ↩︎ ","date":"2021-09-04","objectID":"/2021/sense-of-security-future/:3:2","tags":["生活技能"],"title":"安全感建立-未来","uri":"/2021/sense-of-security-future/"},{"categories":["Golang学习之路"],"content":"学习 Go 时收藏的一些网址，做一下收录，作为结尾。 Go文档-国内 (go-zh.org) Go文档-国外 (golang.org) Go语言爱好者周刊(studygolang.com) Go语言中文网 论坛(studygolang.com) Go语言标准库文档中文版(studygolang.com) 书籍: the-way-to-go_ZH_CN 博客: TY·Loafer的Go学习记录 (tyloafer.github.io) Go语言入门教程（非常详细） (biancheng.net) Go项目列表 (awesome-go.com) LeetCode Go实现(halfrost.com) Go语言学习之路第10天(Go并发编程) - 真的白给 - 博客园 (cnblogs.com) Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现 (draveness.me) ","date":"2021-07-05","objectID":"/2021/golang-learning-materials/:0:0","tags":["Go语法"],"title":"Golang学习资料","uri":"/2021/golang-learning-materials/"},{"categories":["Golang学习之路"],"content":"Go 实现一个命令行界面的 2048 游戏，仅涉及 Git 和 Go，用来熟悉基本语言特性。原型项目来自 https://github.com/chhabraamit/2048 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:0:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"1. 环境准备 Win10 环境，go 1.14.3，编辑器为 VScode，使用 Github 管理代码。 首先在网页端建立 Github 仓库，选择 MIT 协议，然后克隆仓库到本地 $ git clone https://github.com/shuzang/2048.git 在项目根目录创建 main.go 文件 package main import \"fmt\" func main() { fmt.Println(\"Getting started!\") } 初始化项目 $ go mod init github.com/shuzang ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:1:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"2. 显示游戏面板 2048 的游戏界面是一个 4×4 的网格，我们使用一个二维切片作为底层结构存储数字，然后按照网格的形式输出到终端，数字随机生成。 // game/board.go package game import ( \"fmt\" \"math/rand\" \"time\" ) // 游戏界面规格 const _rows, _cols = 4, 4 type Board interface { Display() } type board struct { board [][]int } /* 显示 4×4 网格形式的游戏界面 */ func (b *board) Display() { b.board = generate() printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { // 每个数字占7个位置，如果为0，输出空字符 if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else {// 数字不为0，使其位于中间，方法是使其占4位，然后接着输出3个空字符 fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } // 输出横线，4*7+5 = 33 func printHorizontal() { for i := 0; i \u003c 33; i++ { fmt.Printf(\"-\") } fmt.Println() } // 输出竖线 func printVertical() { fmt.Printf(\"|\") } // 生成所需的所有随机数 func generate() [][]int { // Store all available numbers from 2 to 2048 nums := make([]int, 0) nums = append(nums, 0) for i := 2; i \u003c= 2048; i *= 2 { nums = append(nums, i) } // generate random numbers for init board rand.Seed(time.Now().UnixNano()) matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[i][j] = nums[rand.Int()%len(nums)] } } return matrix } func NewBoard() *Board { return \u0026board{} } 然后修改 main.go 如下 // main.go package main import ( \"fmt\" \"github.com/shuzang/2048/game\" ) func main() { fmt.Println(\"Getting started!\") b := game.NewBoard() b.Display() } 运行 go run main.go 可以看到一个临时的游戏面板。 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:2:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"3. 添加元素 上面的程序随机生成了 16 个数字填充游戏面板，但这只是初始测试，正式游戏的做法是：初始时随机填充两个数字，然后每个键盘输入新增一个数字。这里还要注意每一步生成的数字有两种选择，2 或 4，我们可以控制这两个数字生成的概率。 所以添加新元素被抽象为一个独立的函数，如下 // game/board.go type board struct { board [][]int nx, ny int } // 被折叠的代码... // 随机填充一个新数字 func (b *board) AddElement() { rand.Seed(time.Now().UnixNano()) // 随机选择一个空白位置 index := make([][2]int, 0) for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { index = append(index, [2]int{i, j}) } } } next := rand.Int() % len(index) nx, ny := index[next][0], index[next][1] // 按概率选择数字 2 和 4 var number int if rand.Int()%100 \u003c 80 { number = 2 } else { number = 4 } // 将数字填充到选择的位置 b.nx, b.ny = nx, ny b.board[nx][ny] = number } func NewBoard() *board { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } return \u0026board{board: matrix} } board 结构体新增了 nx,ny 两个字段，是为了标记新添加的元素在游戏面板中的位置，我们需要将新元素以不同的颜色表示，这里用到了 fatih/color 包。 $ go get -v github.com/gatih/color 导入该包后修改显示函数如下，用不同的颜色输出新添加的元素。 // game/board.go func (b *board) Display() { c := color.New(color.FgCyan, color.Bold) printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else if i == b.nx \u0026\u0026 j == b.ny { c.Printf(\"%4d%3s\", b.board[i][j], \"\") } else { fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } 相应的，主函数修改如下，添加 10 个元素并输出 // main.go func main() { fmt.Println(\"Getting started!\") b := game.NewBoard() for i := 0; i \u003c 10; i++ { b.Display() b.AddElement() } fmt.Println(\"Game over!\") } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:3:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"4. 先清屏后显示 上面的程序会把每一步的面板都输出到终端，我们应当添加的一个功能是，每一步只输出当前的游戏面板。该功能通过清屏函数实现，注意，清屏的实现在不同操作系统可能会有区别，下面的实现适用于 Windows 系统。 // game/board.go func (b *board) Display() { // clear screen, but only works on windows cmd := exec.Command(\"cmd\", \"/c\", \"cls\") cmd.Stdout = os.Stdout cmd.Run() c := color.New(color.FgCyan, color.Bold) printHorizontalLine() for i := 0; i \u003c _rows; i++ { printVerticalLine() for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { fmt.Printf(\"%7s\", \"\") } else if i == b.nx \u0026\u0026 j == b.ny { c.Printf(\"%4d%3s\", b.board[i][j], \"\") } else { fmt.Printf(\"%4d%3s\", b.board[i][j], \"\") } printVerticalLine() } fmt.Println() printHorizontalLine() } } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:4:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"5. 获取键盘输入 游戏的每一步操作肯定都是根据键盘的输入来的，可以使用 {W, A, S, D} 和 方向键，如果使用 fmt 包中的输入函数，那么每次输入后都需要手动按下回车。为了不必每次输入字符后都敲一下回车键，我们使用 eiannone/keyboard 包 $ go get -v github.com/eiannone/keyboard 将键盘输入对应的几个操作定义为几个常量，然后调用 keyboard 包中的 GetKeyStrokes() 函数接收键盘输入，返回对应的常量，最后在 TakeInput() 函数中根据不同常量交给对应的操作函数处理。 // game/board.go type Key int // 几个操作常量，向四个方向移动、退出和错误按键 const ( UP Key = iota DOWN LEFT RIGHT QUIT ERROR_KEY ) func (b *board) TakeInput() bool { key, err := GetKeyStrokes() if err != nil { fmt.Printf(err.Error()) } if key == ERROR_KEY { b.TakeInput() } switch key { case UP: b.moveUp() case DOWN: b.moveDown() case LEFT: b.moveLeft() case RIGHT: b.moveRight() case QUIT: fmt.Println(\"You press ESC, game exit!\") return false } return true } func GetKeyStrokes() (Key, error) { char, key, err := keyboard.GetSingleKey() if err != nil { return ERROR_KEY, err } //fmt.Printf(\"You pressed: %c, key %X\\r\\n\", char, key) if int(char) == 0 { switch key { case keyboard.KeyArrowUp: return UP, nil case keyboard.KeyArrowDown: return DOWN, nil case keyboard.KeyArrowLeft: return LEFT, nil case keyboard.KeyArrowRight: return RIGHT, nil case keyboard.KeyEsc: return QUIT, nil default: return ERROR_KEY, errors.New(\"Invalid key, please press again!\") } } else { switch char { case 119: return UP, nil case 97: return LEFT, nil case 115: return DOWN, nil case 100: return RIGHT, nil default: return ERROR_KEY, errors.New(\"Invalid key, please press again!\") } } } 游戏退出有两种情况，一个是上面程序中定义的 QUIT 操作，用于游戏过程中主动输入 ESC 按键退出，另一个是游戏面板 16 个数字已满，Game over，通过添加以下函数实现 // game/board.go func (b *board) IsOver() bool { blank := 0 for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { if b.board[i][j] == 0 { blank++ } } } return blank == 0 } 最后是程序开始的逻辑，即输入任意键开始。这部分逻辑在 main 函数中 // main.go func main() { fmt.Println(\"Use {W A S D} or Arrow keys to move the board\") fmt.Printf(\"Press and key to start\\n\") _, _, err := keyboard.GetSingleKey() if err != nil { log.Fatalln(\"error while taking input to start the game\") } b := game.NewBoard() b.AddElement() b.AddElement() for true { if b.IsOver() { break } b.AddElement() b.Display() res := b.TakeInput() if !res { return } } fmt.Println(\"game over\") } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:5:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"6. 数字移动合并 每个键盘输入都对应一个操作函数，四个方向的数字移动和合并是游戏的核心逻辑。如下，向左移动数字和合并单独实现，向右、向上和向下都能通过矩阵旋转转换为向左移动和合并的问题。 // game/board.go func (b *board) moveLeft() { for i := 0; i \u003c _rows; i++ { old := b.board[i] b.board[i] = moveRow(old) } } func (b *board) moveRight() { b.Reverse() b.moveLeft() b.Reverse() } func (b *board) moveUp() { b.leftRotate90() b.moveLeft() b.rightRotate90() } func (b *board) moveDown() { b.rightRotate90() b.moveLeft() b.leftRotate90() } func (b *board) rightRotate90() { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[j][_cols-1-i] = b.board[i][j] } } b.board = matrix } func (b *board) leftRotate90() { matrix := make([][]int, _rows) for i := 0; i \u003c _rows; i++ { matrix[i] = make([]int, _cols) } for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { matrix[_cols-1-j][i] = b.board[i][j] } } b.board = matrix } func (b *board) Reverse() { for i := 0; i \u003c _rows; i++ { for j, k := 0, _cols-1; j \u003c k; j, k = j+1, k-1 { b.board[i][j], b.board[i][k] = b.board[i][k], b.board[i][j] } } } func moveRow(row []int) []int { index := 0 for i := 0; i \u003c len(row); i++ { if row[i] != 0 { row[index], row[i] = row[i], row[index] index++ } } for i := 0; i \u003c len(row)-1; i++ { if row[i] == row[i+1] { row[i] += row[i+1] row[i+1] = 0 i++ } } index = 0 for i := 0; i \u003c len(row); i++ { if row[i] != 0 { row[index], row[i] = row[i], row[index] index++ } } return row } 由于这部分逻辑比较复杂，需要测试一下 // game/board_test.go package game import ( \"reflect\" \"testing\" ) func TestMoveRow(t *testing.T) { tests := []struct { name string input []int want []int }{ { name: \"one\", input: []int{2, 2, 0, 0}, want: []int{4, 0, 0, 0}, }, { name: \"two\", input: []int{2, 2, 4, 8}, want: []int{4, 4, 8, 0}, }, { name: \"three\", input: []int{2, 4, 4, 8}, want: []int{2, 8, 8, 0}, }, { name: \"four\", input: []int{2, 4, 8, 8}, want: []int{2, 4, 16, 0}, }, { name: \"five\", input: []int{2, 2, 2, 2}, want: []int{4, 4, 0, 0}, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := moveRow(tt.input); !reflect.DeepEqual(got, tt.want) { t.Errorf(\"moveRow() = %v, want %v\", got, tt.want) } }) } } func TestLeftRotate90(t *testing.T) { type fields struct { matrix [][]int } tests := []struct { name string fields fields want [][]int }{ { name: \"one\", fields: fields{ matrix: [][]int{ {1, 2, 3, 9}, {4, 5, 6, 10}, {6, 7, 8, 11}, {16, 17, 18, 111}, }, }, want: [][]int{ {9, 10, 11, 111}, {3, 6, 8, 18}, {2, 5, 7, 17}, {1, 4, 6, 16}, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { b := \u0026board{board: tt.fields.matrix} b.leftRotate90() if !reflect.DeepEqual(b.board, tt.want) { t.Errorf(\"b.leftRotate90() = %v, want %v\", b.board, tt.want) } }) } } func TestRightRotate90(t *testing.T) { type fields struct { matrix [][]int } tests := []struct { name string fields fields want [][]int }{ { name: \"one\", fields: fields{ matrix: [][]int{ {1, 2, 3, 9}, {4, 5, 6, 10}, {6, 7, 8, 11}, {16, 17, 18, 111}, }, }, want: [][]int{ {16, 6, 4, 1}, {17, 7, 5, 2}, {18, 8, 6, 3}, {111, 11, 10, 9}, }, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { b := \u0026board{board: tt.fields.matrix} if b.rightRotate90(); !reflect.DeepEqual(b.board, tt.want) { t.Errorf(\"b.rightRotate90() = %v, want %v\", b.board, tt.want) } }) } } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:6:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"7. 分数计算 游戏正常结束后显示当前最大分数和总分数，算是一个小功能。 //game/board.go func (b *board) CountScore() (int, int) { total, max := 0, 0 matrix := b.board for i := 0; i \u003c _rows; i++ { for j := 0; j \u003c _cols; j++ { total += matrix[i][j] max = maxInts(max, matrix[i][j]) } } return max, total } func maxInts(a, b int) int { if a \u003e b { return a } return b } //main.go func main() { fmt.Println(\"Use {W A S D} or Arrow keys to move the board\") fmt.Printf(\"Press and key to start\\n\") _, _, err := keyboard.GetSingleKey() if err != nil { log.Fatalln(\"error while taking input to start the game\") } b := game.NewBoard() b.AddElement() b.AddElement() for true { if b.IsOver() { break } b.AddElement() b.Display() res := b.TakeInput() if !res { return } } fmt.Println(\"\\n********** game over **********\") max, total := b.CountScore() fmt.Printf(\"Max Score: %v \\n\", max) fmt.Printf(\"Total Score %v \\n\", total) } ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:7:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"8. 代码重构 所有功能完成后，对代码进行重构整理，包括 将数字移动合并的相关代码移动到单独的 move.go 源文件中； （可选）将输入和显示的相关函数都拆分到单独的源文件中； 为所有代码添加注释，并编写 README.md 文档； ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:8:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"9. 结果与收获 完整的项目代码可以查看我的 github 仓库，与原项目有一些实现上的区别，并完善了一些功能。 编写该项目的收获有 开源协议的选择； 对结构体和接口作用和意义的思考； 一个项目是从简单到复杂一步步建立的，不要想一步登天做的很完善； 方法中 (b *board) 和 (b board) 的区别； 一些重要的可定制的参数可以抽取作为为常量，比如面板规格，常量命名时前面最好加下划线 _ 加以区分； fmt.Printf 可以输出固定长度的空字符用于占位，fmt.Println() 可以用来换行； 随机数的生成方法，一个小技巧是使用数组存放待选择数字，然后随机生成数组长度范围内的数字作为索引进行选择； 结构体对象的生成可以使用工厂模式，比如 NewBoard 函数； 格式化输出的颜色控制（fatih/color包）； 清屏的实现方法； 无需回车不断读取键盘输入的实现方法（eiannone/keyboard包）; 矩阵旋转等大量关于二维切片的算法实现（PS：刷题还是有用的）； 测试用例的编写； 所有功能完成后，根据情况进行重构，比如代码的解耦等，然后完成添加注释、编写文档等工作； Go 文档的编写与使用； 日志系统的使用。 ","date":"2020-10-08","objectID":"/2020/a-cli-implement-of-2048-game-using-go/:9:0","tags":["Go实战"],"title":"Go实现2048小游戏","uri":"/2020/a-cli-implement-of-2048-game-using-go/"},{"categories":["Golang学习之路"],"content":"本篇介绍如何分析 Go 的调用栈。 测试使用的版本是Go 1.14.3，下面介绍如何在Go调试的时候查看堆栈跟踪信息及识别传递的参数。 示例程序如下 package main import ( \"runtime/debug\" ) func main() { slice := make([]string, 2, 4) Example(slice, \"hello\", 10) } func Example(slice []string, str string, i int) { debug.PrintStack() } 在程序中我们使用了 runtime/debug 下的 PrintStack() 函数将调用栈的返回信息打印到标准错误输出，如下所示 goroutine 1 [running]: runtime/debug.Stack(0x0, 0x0, 0x0) c:/go/src/runtime/debug/stack.go:24 +0xa8 runtime/debug.PrintStack() c:/go/src/runtime/debug/stack.go:16 +0x29 main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa) f:/Gotest/main.go:13 +0x2e main.main() f:/Gotest/main.go:9 +0xb1 Process exiting with code: 0 注意，在其它编程语言如C中，运行一个程序会启动一个线程来执行，在Go中，启动的是一个 Goroutine。上面第一行就说明了启动了一个 Goroutine，Goroutine ID 为1，其后各行是不同层次的调用，最深的调用最先打印，最浅的调用最后打印。各行说明如下 第8、9行：main package 的 main 函数，代码文件路径为 f:/Gotest/main.go，调用出现在 main.go 文件的第9行 第6、7行：main 函数调用 Example 函数 第4、5行：Example 函数调用 debug.PrintStack 函数 第2，3行：debug.PrintStack 函数调用 debug.Stack 函数 Example 函数传参信息如下 // 调用 slice := make([]string, 2, 4) Example(slice, \"hello\", 10) // 栈追踪 main.Example(0xc000077f38, 0x2, 0x4, 0x4a8534, 0x5, 0xa) 堆栈跟踪信息中，前三个参数分别代表切片的指针、长度、容量，第4和第5个参数代表字符串的指针和大小，最后一个参数指向整型数值 // 切片 Pointer: 0xc000077f38 Length: 0x2 Capacity: 0x4 // 字符串 Pointer: 0x4a8534 Length: 0x5 // 整数 base 16: 0xa 如果是调用方法，跟踪信息会显示接收者 // 程序 package main import ( \"fmt\" \"runtime/debug\" ) type trace struct{} func main() { slice := make([]string, 2, 4) var t trace t.Example(slice, \"hello\", 10) } func (t *trace) Example(slice []string, str string, i int) { fmt.Printf(\"Receiver Address: %p\\n\", t) debug.PrintStack() } // 堆栈信息 Receiver Address: 0x5781c8 goroutine 1 [running]: runtime/debug.Stack(0x15, 0xc000071ef0, 0x1) C:/Go/src/runtime/debug/stack.go:24 +0xae runtime/debug.PrintStack() C:/Go/src/runtime/debug/stack.go:16 +0x29 main.(*trace).Example(0x5781c8, 0xc000071f48, 0x2, 0x4, 0x4c04bb, 0x5, 0xa) D:/gopath/src/example/example/main.go:17 +0x7c main.main() D:/gopath/src/example/example/main.go:13 +0x9a 传递的参数全部为值类型时，可能会防止一个32位的字中 // 程序 import ( \"runtime/debug\" ) func main() { Example(true, false, true, 25) } func Example(b1, b2, b3 bool, i uint8) { debug.PrintStack() } // 堆栈信息 goroutine 1 [running]: runtime/debug.Stack(0x4, 0xc00007a010, 0xc000077f88) C:/Go/src/runtime/debug/stack.go:24 +0xae runtime/debug.PrintStack() C:/Go/src/runtime/debug/stack.go:16 +0x29 main.Example(0xc019010001) D:/gopath/src/example/example/main.go:12 +0x27 main.main() D:/gopath/src/example/example/main.go:8 +0x30 可以看到 Example 的参数只有一个，实际上底层四个参数放在一个字中 // Parameter values true, false, true, 25 // Word value Bits Binary Hex Value 00-07 0000 0001 01 true 08-15 0000 0000 00 false 16-23 0000 0001 01 true 24-31 0001 1001 19 25 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-9-call-stack/:0:0","tags":["Go语法"],"title":"Golang深入学习9-调用栈","uri":"/2020/golang-deep-learning-9-call-stack/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Go 的堆栈和逃逸分析。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:0:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"1. 堆栈 栈是一种后入先出的结构，计算机中也有一块满足该特性的动态内存区域，程序可以将数据压入栈中或者将数据从栈中弹出，从而使栈动态的增大或减小。 除此之外，堆也是计算机中的一中内存区域。堆与栈的区别如下 栈一般由操作系统来分配和释放，堆由程序员通过编程语言来申请创建与释放。 栈用来存放函数的参数、返回值、局部变量、函数调用时的临时上下文等，堆用来存放全局变量。我们可以这样理解数据存放的规则：只要是局部的、占用空间确定的数据，一般都存放在stack 里面，否则就放在 heap 里面。 栈的访问速度相对比堆快。 一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack 是线程独占的，heap 是线程共用的。 stack 创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow 错误，而heap的大小是不确定的，需要的话可以不断增加。 栈是由高地址向低地址增长的，而堆是由低地址向高地址增长的。 在 C/C++ 中，程序员申请的内存空间使用完毕后需要自己释放，在 Java、Go 等语言中，提供了一种主动释放申请的内存空间的功能，这就是垃圾回收机制。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:1:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"2. Go的堆栈 首先，Go 是自己管理内存的，而不是交给操作系统，它每次从操作系统申请一大块内存，然后按照 Google 的 TCMalloc 算法进行内存分配，也划分为堆、栈等很多区域。 这里我们主要关心变量究竟放在堆还是栈里，官方有这么一段解释 只要有对变量的引用，变量就会存在，而它存储的位置与语言的语义无关。如果可能，变量会被分配到其函数的栈，但如果编译器无法证明函数返回之后变量是否仍然被引用，就必须在堆上分配该变量，采用垃圾回收机制进行管理，从而避免指针悬空。此外，局部变量如果非常大，也会存在堆上。 在编译器中，如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。 总之，分配在堆还是栈完全由编译器确定。 所以 Go 里变量分配在由编译器决定，我们虽然无法通过变量的类型判断它的存储位置，但可以通过打印程序的汇编代码来查看，主要使用 go tool compile 命令，示例程序如下 package main import \"fmt\" func main() { var a [1]int c := a[:] fmt.Println(c) } 使用 -S 参数编译，可以输出详细内容。可以看到第 6 行代码出现了 runtime.newobject，这就说明 main.go 第6行 的数组变量 a 分配在堆上。反之，如果没有发现 runtime.newobject 调用，就说明分配在栈上。 $ go tool compile -S main.go ... 0x0028 00040 (main.go:6) PCDATA $0, $1 0x0028 00040 (main.go:6) PCDATA $1, $0 0x0028 00040 (main.go:6) LEAQ type.[1]int(SB), AX 0x002f 00047 (main.go:6) PCDATA $0, $0 0x002f 00047 (main.go:6) MOVQ AX, (SP) 0x0033 00051 (main.go:6) CALL runtime.newobject(SB) 0x0038 00056 (main.go:6) PCDATA $0, $1 0x0038 00056 (main.go:6) MOVQ 8(SP), AX 0x003d 00061 (main.go:8) PCDATA $0, $0 0x003d 00061 (main.go:8) MOVQ AX, (SP) 0x0041 00065 (main.go:8) MOVQ $1, 8(SP) 0x004a 00074 (main.go:8) MOVQ $1, 16(SP) ... 使用 -m 参数可以输出优化后的描述，这里就看起来很清楚了，可以看到 main.go 第 6 行的变量 a 分配到了堆上，在第 8 行时，变量 c 逃逸到了堆上。关于逃逸我们在下一小节介绍。 $ go tool compile -m main.go main.go:8:13: inlining call to fmt.Println main.go:6:6: moved to heap: a main.go:8:13: c escapes to heap main.go:8:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape 也可以直接在 go build 命令中添加 -gcflag=-m 参数，意思是编译的同时以 -m 参数运行 go tool compile 命令，结果是相同的。 $ go build -gcflags=-m main.go # command-line-arguments .\\main.go:8:13: inlining call to fmt.Println .\\main.go:6:6: moved to heap: a .\\main.go:8:13: c escapes to heap .\\main.go:8:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:2:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"3. 逃逸分析 前面已经提到，Go 中变量分配在栈还是堆上完全由编译器决定，而原本看起来应该分配在栈上的变量，如果其生命周期获得了延长，被分配在了堆上，就说它发生了逃逸。编译器会自动地去判断变量的生命周期是否获得了延长，整个判断的过程就叫逃逸分析。 package main func main() { a := test() println(a) } func test() *int { b := 2 return \u0026b } 举个例子，上面的程序中 b 作为局部变量，如果是在 C 语言中，return \u0026b 这样的写法无法通过，因为 b 在函数返回后已经消失了，但在 Go 中，编译器做了一下逃逸分析，发现返回 \u0026b 说明之后 b 还要用，于是就把 b 分配在了堆上。 $ go tool compile -m main.go main.go:8:6: can inline test main.go:3:6: can inline main main.go:4:11: inlining call to test main.go:9:2: moved to heap: b 然后我们举另外一个例子如下，一个最简单的输出 package main import \"fmt\" func main() { a := 1 fmt.Println(a) } 结果发现变量 a 依然逃逸了 $ go tool compile -m main.go main.go:7:13: inlining call to fmt.Println main.go:7:13: a escapes to heap main.go:7:13: []interface {} literal does not escape \u003cautogenerated\u003e:1: .this does not escape \u003cautogenerated\u003e:1: .this does not escape 这是因为输出其实是调用了 fmt 包的 Println 函数，变量的生命周期依然得到了扩展，如果我们使用 println 函数，就不会发生逃逸 package main func main() { a := 1 println(a) } $ go tool compile -m main.go main.go:3:6: can inline main 所以现在我们可以更好的理解官方说明中的这句话：如果变量具有地址，就作为堆分配的候选，但如果逃逸分析可以确定其生存周期不会超过函数返回，就会分配在栈上。 变量发生逃逸的情况可以总结如下 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。 发送指针或带有指针的值到 channel 中。 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。 在一个切片上存储指针或带指针的值。 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。 slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。 在 interface 类型上调用方法。 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:3:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"参考 [1] Go堆栈的理解 [2] 阮一峰，栈的三种含义 [3] 官方关于变量分配在堆还是栈上的说明 [4] Young，CSDN，Go 的变量到底在堆还是栈中分配 [5] 胖虎，微信公众号，简单聊聊内存逃逸 ","date":"2020-08-15","objectID":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/:4:0","tags":["Go语法"],"title":"Golang深入学习8-堆栈与逃逸分析","uri":"/2020/golang-deep-learning-8-stack-heap-and-escape-analysis/"},{"categories":["Golang学习之路"],"content":"一直都比较纠结这个问题，所以搜了一下答案，记录在这里。 变量的声明有两种情况： 需要建立存储空间，这种称为定义性声明（defining declaration），简称定义 不需要建立存储空间，这种称为引用性声明（referncing declaration） 所以广义的讲，声明包含定义，定义是声明的一个特例。 在 Go 中，基本变量类型在声明时都会分配存储空间并分配默认值，因此都属于定义性声明 var ( a int b float32 c bool ) 但是，像切片、映射、通道等，声明时不会分配存储空间，要分配空间还必须使用 make 内置函数，因此它们是引用性声明 var a []int a = make([]int,3) 在 Go 的官方文档中，使用的也都是 declaration 这个词，统一用「声明」来描述 ","date":"2020-08-15","objectID":"/2020/golang-supplement-the-difference-between-definition-and-declaration/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-定义与声明的区别","uri":"/2020/golang-supplement-the-difference-between-definition-and-declaration/"},{"categories":["Golang学习之路"],"content":"调度器和垃圾回收都属于 runtime 的一部分，本文我们介绍 Go 中 runtime 的含义，然后再来分析 Go 的调度器和垃圾回收策略。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:0:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"1. runtime runtime，直译为运行时，之前只听说过这个概念，但要解释 runtime 究竟是什么，还是说不出口。我从 Go 官方文档的问答里找到了下面这段话，可以作为一个很好的开始。 Go does have an extensive library, called the runtime, that is part of every Go program. The runtime library implements garbage collection, concurrency, stack management, and other critical features of the Go language. Although it is more central to the language, Go’s runtime is analogous to libc, the C library. It is important to understand, however, that Go’s runtime does not include a virtual machine, such as is provided by the Java runtime. Go programs are compiled ahead of time to native machine code (or JavaScript or WebAssembly, for some variant implementations). Thus, although the term is often used to describe the virtual environment in which a program runs, in Go the word “runtime” is just the name given to the library providing critical language services. Go 的运行时是每个 Go 程序的一部分，负责实施垃圾回收、并发、栈管理以及其它 Go 的一些核心特性。但是，尽管这些都是一个语言的核心，runtime 在 Go 中实际上是一个库（标准库的一个）。理解这一点很重要，因为在其它一些语言中，比如 Java，runtime 实际上包含一个虚拟机的概念，是程序运行的环境，但在 Go 中 runtime 就仅仅是一个包含一些关键特性的库。 这里已经说的比较清楚了，接下来我们来看 runtime 库包含哪些东西，实际上，runtime 库下面还有几个子库 runtime/cgo：用来支持 C 语言函数的调用 runtime/debug：进行问题排查 runtime/msan runtime/pprof：进行性能分析 runtime/race：实现了数据静态检测逻辑 runtime/trace：执行跟踪器，捕获各种执行时的事件，比如 goroutine 的创建/阻塞/解除阻塞、系统调用的进入/退出/阻塞、垃圾回收相关的事件、堆大小的改变、处理器的启动和停止等，并将它们写入 io.writer 中 需要知道的是，调度器、垃圾回收、各种数据类型的定义和操作(比如切片、接口等)都位于 runtime 库，而不是这几个子库，在电脑中的位置为 $GOROOT/src/runtime Go 的可执行文件一般比相应的源码文件大很多，这是因为 runtime 潜入了每一个可执行文件中，因此，Go 运行不依赖于其它任何文件。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:1:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2. 调度器 这部分关于调度器的介绍，主要翻译自 The Go scheduler 这篇文章，写的非常容易理解。 在操作系统中，调度主要是对 CPU 时间片的分配策略，为了充分利用 CPU，将时间划分为一系列的时间片，然后遵循某种最优的策略（总执行时间最短或其它）将进程分配到某个时间片执行的过程。Go 中的调度做的也是类似的事，也就是如何分配 Goroutine 的执行，做这件事的工具就是调度器，而且我们也可以看出，调度器和 Go 的并发是息息相关的。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2.1 设计理念 我们首先来理解为什么 Go 需要一个自己的调度器，而不是使用操作系统的调度器。首先，在操作系统中，线程的上下文切换也需要一定的资源，其中很多开销对 Go 的运行来说是不必要的，而且线程数量越多，这部分开销越大。另外一个重要的原因是交给操作系统调度无法基于 Go 当前的情况做出最优的调度决策，比如 Go 进行垃圾回收的时候，需要暂停正在运行的 Goroutine 和线程，并使内存保持在一个一致的状态，如果交给操作系统的调度器，就失去了对一致性状态的把握，并且需要等待所有相关线程停止工作，正在运行的线程越多，达到这个目的越难。如果 Go 使用自己的调度器，就知道什么时候内存状态是一致的（只针对 Go 程序分配的内存），它会在这些已知的内存一致性的时刻开始垃圾回收，并且此时只需要等待当前正在 CPU 核上执行的那个线程，而不是等待所有的线程。 有三种常见的线程模型，第一种是 N:1，也就是多个用户空间线程运行在一个 OS 线程上，其优点是上下文切换快速，缺点是不能充分利用多核系统的优点；第二种是 1:1，也就是一个用户空间线程对应一个 OS 线程，其优点是充分利用了系统的多个核，缺点是上下文切换的开销有点大。 Go 采用的是一种折衷的办法，即 M:N，也就是将任意数量的 Goroutine 对应到任意数量的 OS 线程，OS 线程的数量通常取决于 CPU 核的数目，这种方式保持了较低的上下文切换开销，并且充分利用了多核系统的优点，它主要的缺点是增加了调度器的复杂性。 Go 的调度器定义在 runtime 包中，具体的文件是 src/runtime/proc.go，最主要的概念有三个：P，M，G。其定义如下 // Goroutine scheduler // The scheduler's job is to distribute ready-to-run goroutines over worker threads. // // The main concepts are: // G - goroutine. // M - worker thread, or machine. // P - processor, a resource that is required to execute Go code. // M must have an associated P to execute Go code, however it can be // blocked or in a syscall w/o an associated P. // // Design doc at https://golang.org/s/go11sched. 用图形描述更直观一点 M 是 OS 线程，由操作系统管理，是实际的执行者，M 是 Machine 的首字母大写。 G 是 Goroutine，它包括堆栈，指令指针和其他对调度 Goroutine 重要的信息。 P 是调度的上下文，可以看作 Go 自己的调度器，负责将 Goroutine 调度到具体的 OS 线程上执行，他是实现 M:N 模型的关键，P 是 Processor 的首字母大写。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:1","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"2.2 调度策略 我们基于上面的三个概念来描述 Go 的调度策略。 上图中有两个 M，每个线程 M 都持有一个调度器 P，并且运行着一个 G。调度器的数目可以通过设置 GOMAXPROCS 环境变量或者调用 runtime.GOMAXPROCS 函数来设定，通常在设定好后，程序运行期间该值不会改变。事实上，该值的设定是充分利用多核的关键，比如，如果有一个 4 核的计算机，我们通常将 GOMAXPROCS 设定为 4，这样操作系统中会同时有 4 个线程运行 Goroutine。 灰色的 G 意味着 Goroutine 没有在运行，而是处于等待被调度的状态，这里使用了一个队列来存放它们，称为运行队列(runqueue)。每当使用 go 关键字启动一个 Goroutine 时，它就被加入运行队列的尾部，当 P 到达某个调度的时刻，就从运行队列首部取出一个 Goroutine ，设置好堆栈和指令指针，然后分配给关联的 M 运行。为了减少争用，每个 P 都有自己的运行队列。 注：早期的时候所有 P 公用一个运行队列，但这种情况下调度时需要加解锁，线程经常被阻塞。 运行队列不空，P 有用来调度的 Goroutine，那么就不会发生意外，调度会处于一个稳定的状态。但实际环境下是会产生意外的，我们介绍如下： 线程出于某些原因需要阻塞。这时候 P 无法再将 Goroutine 交给自己的 M 运行，然后就会将 Goroutine 移交给其它的 M 运行。 如上图，我们可以看到 M0 由于系统调用（syscall）发生了阻塞，与之相关的 P （实际上是下文）就被移交给了 M1（这里我们可以更好的理解为什么 P 的本质是上下文，只是可以看作调度器）。调度程序会确保有足够的 M 来运行 P，上面的 M1 可能仅为了处理移交的 P 和对应的 Goroutine创建，也可能来自线程池。M0 将保留正在执行的 Goroutine，因为实质上它仍然在执行，只是在 OS 中被阻塞。 当 syscall 返回时，M0 必须尝试获取一个 P 用来执行未执行完的 G0，一般情况是从其它线程窃取一个 P，如果无法窃取到，就会把 G0 放到全局的运行队列中，然后把自己放到线程池进入睡眠状态。 全局的运行队列是 P 从自己的运行队列无法获取到 G 时读取的地方，P 会定期检测全局运行队列，防止全局运行队列中的 Goroutine 始终得不到执行。 这种处理过程说明了为什么即使 GOMAXPROCS=1，Go 程序运行也会涉及到多个线程，G0 会停留在syscall 线程上。 运行队列中的 Goroutine 被用尽了。如果每个 P 的运行队列上 Goroutine 的数量不平衡，就可能发生这种情况 前面已经提到，P 本身的运行队列空了的时候，会从全局运行队列获取 Goroutine，那么，如果全局运行队列也为空呢。P 就会从其它 P 那里窃取 Goroutine，一般情况下会窃取大约一半的运行队列，这样可以保证两个 P 一直有 Goroutine 可调用，也就是保持平衡，从而保证所有的线程不处于空闲状态。上图中空闲 P 从其它 P 窃取了两个 Goroutine，一个直接开始执行，剩下的放入运行队列，此时两个 P 的运行队列大小相同。 所以，在操作系统层面，Go 采用的是抢占式调度，如果 M 陷入了阻塞，那么会导致当前在它上面的 Goroutine 长时间占用 M，这时候就会发生抢占， P 会寻找其它的 M，然后把 G 交给新的 M 调度。但是在语言层面，后来的 Goroutine 永远假如运行队列的末尾，不会抢占 P。 非抢占式调度是进程/线程交给 CPU 后，会一直执行完毕，不会被中断； 抢占式调度是 CPU 正在执行的进程/线程会被具有更高优先级的进程/线程抢占掉（可以防止单一进程长时间独占 CPU）。 其它参考：说说Golang的runtime ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:2:2","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3. 垃圾回收 垃圾回收（Garbage Collection，GC），是一种存储管理机制。我们编写的程序中，变量、函数参数等在内存通常存放在两个不同的区域：栈和堆。栈的分配由操作系统管理，而堆的分配由程序员管理，在 C 和一些语言中，程序员使用 malloc 申请空间后，最后还需要自己使用 free 释放空间，编译器不会辅助完成这个过程，如果忘记释放，就可能造成不可预知的后果（内存泄漏等）。而在 Go 和另一些编程语言中，主动提供了一种机制，它会在后台持续的运行，监控各个变量和参数的状态，识别那些不再使用的对象并释放掉它们的内存空间，这种机制（或者说这个后台进程）叫做垃圾回收。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:0","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.1 常见的GC算法 有很多用于垃圾回收的算法。 第一个叫做引用计数，方法是为每个对象添加一个引用计数器，每当有引用指向该对象，计数器+1，释放时计数器-1，当 GC 检测到计数器为 0 时，说明该对象不再被使用，就回收为它分配的内存。其缺点是无法检测到循环引用，因为循环引用的引用计数永远不可能为 0。 第二个叫做根搜索算法，Java 和 C# 使用了这种办法。原理是通过一系列称为 GC Root 的对象作为起点，从这些节点向下搜索，所走过的路径称为引用链（Reference Chain），如果一个对象到 GC Root 没有任何引用链相连，那么就说明该对象的内存可以被回收。Java 中可以作为 GC Root 的对象包括虚拟机栈中的引用对象、类静态属性引用的对象、常量引用的对象和本地方法栈中的引用对象。 第三种叫做标记-清除算法。它将垃圾回收划分为两个阶段，在标记阶段标记所有可回收的对象，然后在回收阶段回收被标记对象占用的空间。其缺点主要有两个，第一个是标记时需要暂停整个程序的运行，第二个是会产生大量的内存碎片，如下图，碎片比较多的话后续可能没有足够的连续内存分配给需求较多的对象。 第四种是复制算法。复制算法是标记-清除算法的改进，它将内存分为两个相等的区域，每次只使用其中一个区域，进行垃圾回收时，会把当前存活的所有对象复制到另一个空间，然后堆当前空间进行回收。如下图，这种算法解决了内存碎片的问题，代价是可使用的内存为原理的一半，并且由于额外的复制操作，效率会有一定的影响。 第五种是标记-压缩算法。标记-压缩算法与复制算法思路相似，都是将内存分两块，不同在于，标记完可回收的对象后，标记-压缩算法会将存活的对象压缩到内存的一端，让它们紧凑的排列在一起，然后对边界以外的空间进行回收，回收后，已用和未用的内存各自在一边。如下图，标记压缩算法解决了内存碎片问题和回收效率低的问题。 第六种是分代收集。分代收集是一种思路，研究发现，程序中大部分对象的生命周期都很短，所以根据对象生命周期的长短，使用不同的垃圾回收算法。生命周期比较长的叫做老年代，通常使用标记-压缩算法，生命周期比较短的叫做新生代，通常使用复制算法。 本节主要参考：简书，顾林海，垃圾回收算法有哪些 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:1","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.2 Go的垃圾回收 Go 的垃圾回收经历了一个比较长的演变过程，具体可以参考 The Journey of Go’s Garbage Collector 这篇文章。 目前 Go 使用的是三色标记法。三色标记法是标记-回收算法的一种改进，它将所有的对象用白色、灰色、黑色三种颜色表示，基本步骤如下 开始时将所有对象标记为白色； GC 从根结点开始扫描，下图中，A 和 F 是根结点，所以将它们标记为灰色（注意这一步标记为灰色的是根结点集合的所有对象） 遍历灰色节点，将灰色节点所引用的节点也标记为灰色，这里 A 引用了 B、C、D，F 没有引用，然后将分析过的灰色节点标记为黑色，如下图 循环遍历灰色节点，直到灰色节点的个数为 0，下图中，B、C、D都没有引用的白色节点，所以这一轮都标记为了黑色 此时对白色节点对应的内存空间进行垃圾回收 最后，GC 将黑色节点再次重置为白色，供下一次垃圾回收使用。 除了三色标记的主过程外，还需要写屏障（Write Barrier）的配合。由于三色标记是可并发执行的，运行过程中就可能出现新分配的对象，对于这些对象如何处理就需要写屏障参与。写屏障类似于写锁，主要用于保证并发的一致性。写屏障在标记开始时打开，在标记结束后关闭。（需要进一步理解） 另外一个概念是 STW（Stop the world），这是标记阶段产生的一种行为，意思是停止所有的 Goroutine。 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:2","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"3.3 其它 有 GC 不意味着高枕无忧，也可能发生内存泄漏，所以要养成一些良好的习惯，比如不使用的指针置为 Nil。 runtime包有两个关于垃圾回收的 API runtime.GC：手动触发 GC runtime.ReadMemStats：读取内存相关的统计信息，其中包含部分 GC 相关的统计信息 自动垃圾回收触发的条件有两个： 超过内存大小阈值 达到定时时间（默认2min触发一次） 如果想知道当前的内存状态，可以使用 // fmt.Printf(\"%d\\n\", runtime.MemStats.Alloc/1024) // 此处代码在 Go 1.5.1下不再有效，更正为 var m runtime.MemStats runtime.ReadMemStats(\u0026m) fmt.Printf(\"%d Kb\\n\", m.Alloc / 1024) 上面的程序会给出已分配内存的总量，单位是 Kb。进一步的测量参考 package runtime 垃圾回收参考： [1] 简书，Go垃圾回收之三色标记算法 [2] 博客园，搞懂Go垃圾回收 [3] 知乎专栏，张三毛，Go垃圾回收系列 ","date":"2020-07-30","objectID":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/:3:3","tags":["Go语法"],"title":"Golang深入学习7-调度器与垃圾回收","uri":"/2020/golang-deep-learning-7-scheduler-and-garbage-collection/"},{"categories":["Golang学习之路"],"content":"pprof 用来做 Go 程序的性能监控，让我们知道在什么地方耗费了多少 CPU、memory。 pprof 关注的方面有： CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据 Memory Profile（Heap Profile）：报告程序的内存使用情况 Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈 Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:0:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"1. 引入 pprof 可以从以下两个包中引入： import \"net/http/pprof\" import \"runtime/pprof\" 其中 net/http/pprof 底层使用 runtime/pprof 包，只是进行了一下封装，并在 http 端口上暴露出来。 如果我们的服务是一直运行的，如 web 应用，通过简单的导入 import _ \"net/http/pprof\"，就可以在运行 web 应用后在浏览器 http://localhost:port/debug/pprof 直接看到当前 web 服务的状态，包括 CPU 占用情况和内存使用情况等。 如果我们的程序不是 web 应用，而是一个服务进程，那么可以导入 net/http/pprof 包，然后主动开启一个 Goroutine 在端口进行监听 go func() { log.Println(http.ListenAndServe(\"localhost:6060\", nil)) }() 如果我们的程序只是简单的 Go 程序，那么只能使用 runtime/pprof 包，具体做法是在代码中加入下面这段程序，然后在运行时（go run 或 go build等命令）加入 –cpuprofile 参数，比如 go run demo.go --cpuprofile=demo.prof var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... 命令执行完后当前目录会生成 demo.prof 文件，其中记录了 CPU 运行的信息，下一步就可以利用该文件查看相关的信息，使用 go tool pprof 命令来执行，如果要进行可视化，需要安装 graphviz win10 下可以使用 chocolatye 或 winget 安装，如下 \u003e choco install graphviz # 或 \u003e winget install graphviz ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:1:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"2. 分析普通程序 主要参考的文章是 Go Post 中的 Profiling Go Programs 测试代码来自于 https://github.com/rsc/benchgraffiti/tree/master/havlak 我们使用 go mod 建立了一个测试项目文件夹，第一次使用测试代码中的 havlak1.go 文件，将该文件复制到测试项目根目录。由于其中已经引入了 runtime/pprof 包并包含了如下代码，我们不需要做修改，执行执行 var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... 执行时加入 –cpuprofile=havlak1.prof 参数 $ go build havlak1.go $ ./havlak1 --cpuprofile=havlak1.prof # of loops: 76000 (including 1 artificial root node) $ ls go.mod havlak1.exe havlak1.go havlak1.prof 然后运行 go tool pprof 命令与 profile 交互 $ go tool pprof havlak1.exe havlak1.prof File: havlak1.exe Type: cpu Time: Jul 25, 2020 at 7:23pm (CST) Duration: 21.52s, Total samples = 34.77s (161.56%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) 最主要的命令是 topN ，用来输出最耗 CPU 的前N个调用 (pprof) top10 Showing nodes accounting for 21340ms, 61.37% of 34770ms total Dropped 168 nodes (cum \u003c= 173.85ms) Showing top 10 nodes out of 89 flat flat% sum% cum cum% 5340ms 15.36% 15.36% 12320ms 35.43% runtime.scanobject 3190ms 9.17% 24.53% 3650ms 10.50% runtime.mapaccess1_fast64 2650ms 7.62% 32.15% 16670ms 47.94% main.FindLoops 2240ms 6.44% 38.60% 3320ms 9.55% runtime.findObject 1800ms 5.18% 43.77% 2920ms 8.40% runtime.greyobject 1490ms 4.29% 48.06% 6540ms 18.81% runtime.mallocgc 1480ms 4.26% 52.32% 4230ms 12.17% main.DFS 1230ms 3.54% 55.85% 3510ms 10.09% runtime.mapassign_fast64ptr 1000ms 2.88% 58.73% 1450ms 4.17% runtime.heapBitsSetType 920ms 2.65% 61.37% 1050ms 3.02% runtime.spanOf (inline) (pprof) flat、flat% 表示函数在 CPU上运行的时间及百分比 sum% 表示列表中自己包括前面的函数CPU使用比例的累积，比如第三行 main.FindLoops 显示的 32.15% 其实就等于前面三个调用的比例之和 15.36% + 9.17% + 7.62% = 32.15% cum、cum% 表示该函数及其子函数运行所占的时间总和及比例总和，应该大于等于自己执行所占的时间和比例，也就是最前面两列 添加 -cum 参数可以按照 cum 来排序 (pprof) top5 -cum Showing nodes accounting for 2.67s, 7.68% of 34.77s total Dropped 168 nodes (cum \u003c= 0.17s) Showing top 5 nodes out of 89 flat flat% sum% cum cum% 0 0% 0% 16.79s 48.29% main.main 0 0% 0% 16.79s 48.29% runtime.main 0 0% 0% 16.67s 47.94% main.FindHavlakLoops (inline) 2.65s 7.62% 7.62% 16.67s 47.94% main.FindLoops 0.02s 0.058% 7.68% 15.16s 43.60% runtime.systemstack (pprof) 实际上 main.FindLoops 和 main.main 的总和应当为 100%，但是 pprof 不会统计所有的调用，递归调用层次过深的一些执行会被忽略。 另外，使用 web 命令可以生成调用关系图，是一个 svg 文件，可视化的方式可以帮助我们更好的理解，该命令需要 graphviz 工具的支持，这也是为什么前面要安装它 (pprof) web 执行该命令后图片会自动打开 图片中每个方框都代表一个函数，方框的大小根据 CPU 占用比例确定，箭头表示调用关系，从上到下调用层次逐渐加深，表示调用的线条上出现的数字表示调用次数，递归调用自身会有一个自己指向自己的箭头。 从图中看到 mapaccess 占用比例较大，我们可以只显示与它相关的调用，从而使图片逻辑更清晰。可以看到 mapaccess1 主要由 main.FindLoops 和 main.DFS 调用。 我们还可以通过指定函数进入某个函数的细节，DFS逻辑比较简单，以它为例 (pprof) web DFS 也可以使用命令 (pprof) list DFS Total: 34.77s ROUTINE ======================== main.DFS in F:\\Go-web\\havlak1.go 1.48s 8.38s (flat, cum) 24.10% of Total . . 233: return false . . 234:} . . 235: . . 236:// DFS - Depth-First-Search and node numbering. . . 237:// 30ms 30ms 238:func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int { 20ms 240ms 239: nodes[current].Init(currentNode, current) 20ms 340ms 240: number[currentNode] = current . . 241: . . 242: lastid := current 1.02s 1.02s 243: for _, target := range currentNode.OutEdges { 190ms 1.73s 244: if number[target] == unvisited { 80ms 4.23s 245: lastid = DFS(target, nodes, number, last, lastid+1) . . 246: } . . 247: } 80ms 750ms 248: last[number[currentNode]] = lastid 40ms 40ms 249: return lastid . . 250:} . . 251: . . 252:// FindLoops . . 253:// . . 254:// Find loops and build loop forest using Havlak's algorithm, which (pprof) 前两列分别是 flat 和 cum，也就是该行执行占用的时间和该行及该行调用的函数执行占用的总时间，第三列是源码行数。所以我们看到第 245 行由于出现了 DFS 这个递归函数，总占用时间为 4.23s，是最多的。除了该行之外，占用最多的就是第239、240、248三行，主要原因是映射的使用占用了大量时间，所以我们在使用中应尽可能使用数组和切片，而减少使用映射。 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:2:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"2. 时间与存储优化 将 DFS 函数参数中的 number 由映射更改为切片，可以将运行时间减少两倍，我们使用测试文件列表中的 havlak2.go，执行同样的测试过程可以验证这一点，原先的 DFS cum 是 4230ms，现在已经只有 830ms。 $ go build havlak2.go $ ./havlak2 --cpuprofile=havlak2.prof # of loops: 76000 (including 1 artificial root node) $ go tool pprof havlak2.exe havlak2.prof File: havlak2.exe Type: cpu Time: Jul 25, 2020 at 8:51pm (CST) Duration: 12.36s, Total samples = 22.91s (185.34%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top10 Showing nodes accounting for 14360ms, 62.68% of 22910ms total Dropped 132 nodes (cum \u003c= 114.55ms) Showing top 10 nodes out of 85 flat flat% sum% cum cum% 4130ms 18.03% 18.03% 9810ms 42.82% runtime.scanobject 1850ms 8.08% 26.10% 2570ms 11.22% runtime.findObject 1800ms 7.86% 33.96% 11070ms 48.32% main.FindLoops 1530ms 6.68% 40.64% 2510ms 10.96% runtime.greyobject 1450ms 6.33% 46.97% 5940ms 25.93% runtime.mallocgc 950ms 4.15% 51.11% 1290ms 5.63% runtime.heapBitsSetType 680ms 2.97% 54.08% 830ms 3.62% main.DFS 670ms 2.92% 57.01% 670ms 2.92% runtime.memclrNoHeapPointers 670ms 2.92% 59.93% 670ms 2.92% runtime.nextFreeFast 630ms 2.75% 62.68% 630ms 2.75% runtime.arenaIndex (partial-inline) 附： diff between havlak1 and havlak2 现在，DFS 不再是时间瓶颈，取而代之的是内存分配与垃圾回收，上面的结果中 runtime.mallocgc 占了一大部分。为了找出为什么垃圾回收时间占用这么多，我们来分析内存占用，这时候使用 memprofile ，不再是 cpuprofile。首先在主函数中替换如下部分 var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to this file\") ... FindHavlakLoops(cfgraph, lsgraph) if *memprofile != \"\" { f, err := os.Create(*memprofile) if err != nil { log.Fatal(err) } pprof.WriteHeapProfile(f) f.Close() return } 然后使用 –memprofile 标志编译源码，此时使用测试文件列表中的 havlak3 附：diff from havlak2 $ go build havlak3.go $ ./havlak3 --memprofile=havlak3.mprof $ go tool pprof havlak3.exe havlak3.mprof $ go tool pprof havlak3.exe havlak3.mprof File: havlak3.exe Type: inuse_space Time: Jul 25, 2020 at 9:07pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top5 Showing nodes accounting for 53.39MB, 100% of 53.39MB total Showing top 5 nodes out of 13 flat flat% sum% cum cum% 33.10MB 62.00% 62.00% 33.10MB 62.00% main.FindLoops 11.50MB 21.54% 83.54% 11.50MB 21.54% main.NewBasicBlock (inline) 4.50MB 8.43% 91.96% 4.50MB 8.43% main.(*BasicBlock).AddInEdge 2.29MB 4.29% 96.25% 13.79MB 25.83% main.(*CFG).CreateNode 2MB 3.75% 100% 2MB 3.75% main.(*BasicBlock).AddOutEdge (pprof) flat 和 cum 已经从时间占用变成了存储占用，可以看到 main.FindLoops 占用最多，达到了 62.00%，使用 list 命令查看具体情况 (pprof) list FindLoops Total: 53.39MB ROUTINE ======================== main.FindLoops in F:\\Go-web\\havlak3.go 33.10MB 33.10MB (flat, cum) 62.00% of Total . . 261: return . . 262: } . . 263: . . 264: size := cfgraph.NumNodes() . . 265: 1.97MB 1.97MB 266: nonBackPreds := make([]map[int]bool, size) 5.77MB 5.77MB 267: backPreds := make([][]int, size) . . 268: 1.97MB 1.97MB 269: number := make([]int, size) 1.97MB 1.97MB 270: header := make([]int, size, size) 1.97MB 1.97MB 271: types := make([]int, size, size) 1.97MB 1.97MB 272: last := make([]int, size, size) 1.97MB 1.97MB 273: nodes := make([]*UnionFindNode, size, size) . . 274: . . 275: for i := 0; i \u003c size; i++ { 11MB 11MB 276: nodes[i] = new(UnionFindNode) . . 277: } . . 278: . . 279: // Step a: . . 280: // - initialize all nodes as unvisited. . . 281: // - depth-first traversal and numbering. . . 282: // - unreached BB's are marked as dead. . . 283: // . . 284: for i, bb := range cfgraph.Blocks { . . 285: number[bb.Name] = unvisited 4.50MB 4.50MB 286: nonBackPreds[i] = make(map[int]bool) . . 287: } . . 288: . . 289: DFS(cfgraph.Start, nodes, number, last, 0) . . 290: . . 291: // Step b: (pprof) 瓶颈依然在于 UnionFindNode 结构体的初始化和映射。 另外，如果我们执行 go tool pprof 加入 --inuse_objects ，看到的不是内存使用而是调用计数 $ go tool pprof --inuse_objects havlak3.exe havlak3.mprof File: havlak3.exe Type: inuse_objects Time: Jul 25, 2020 at 9:07pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) list FindLoops Total: 1171490 ROUTINE ======================== main.FindLoops","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:3:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"3. 分析网络程序 就像我们一开始说的，分析一个网络程序更加的简单，只需要导入 net/http/pprof 包即可，不需要在程序中使用，只需要添加这一条导入语句。 import _ \"net/http/pprof\" 导入该包会添加一些 /debug/pprof/ URL 下面的一些处理器函数，之后简单的运行 go tool pprof 然后添加服务器 URL就会实时的检查配置文件。 以我们之前写的一个文件上传下载应用为例，端口使用 8090，添加导入语句后，打开浏览器 http://localhost:8090/debug/pprof/，显示如下 或者在命令行使用 go tool pprof 命令 go tool pprof http://localhost:8090/debug/pprof/profile # 30-second CPU profile go tool pprof http://localhost:8090/debug/pprof/heap # heap profile go tool pprof http://localhost:8090/debug/pprof/block # goroutine blocking profile 进入 pprof 命令行界面后就和前面的使用没有区别了，这几个文件简单介绍如下 /debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载 /debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件 /debug/pprof/block：block Profiling 的路径 最后，上面的导入形式是基于我们使用默认的 http.DefaultServeMux 的情况，如果使用了其它的包，比如 Mux，需要手动添加路由规则 r.HandleFunc(\"/debug/pprof/\", pprof.Index) r.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline) r.HandleFunc(\"/debug/pprof/profile\", pprof.Profile) r.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol) r.HandleFunc(\"/debug/pprof/trace\", pprof.Trace) 之后的使用就没有区别了。 ","date":"2020-07-27","objectID":"/2020/golang-deep-learning-6-performance-analysis-pprof/:4:0","tags":["Go语法"],"title":"Golang深入学习6-使用pprof进行性能分析","uri":"/2020/golang-deep-learning-6-performance-analysis-pprof/"},{"categories":["Golang学习之路"],"content":"在C/C++中，使用 GDB 调试程序，但在Go中，看过网上的一些文章后，发现 dlv 是个更好的选择，本文进行介绍。 实际上，delve 才是全称，dlv 只是启动命令，如果使用 VScode，默认使用的调试器就是基于 delve 的。 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:0:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"1. 基本命令 使用如下命令安装 go get github.com/go-delve/delve/cmd/dlv 安装后执行 dlv 命令查看基本信息 $ dlv Delve is a source level debugger for Go programs. Delve enables you to interact with your program by controlling the execution of the process, evaluating variables, and providing information of thread / goroutine state, CPU register state and more. The goal of this tool is to provide a simple yet powerful interface for debugging Go programs. Pass flags to the program you are debugging using `--`, for example: `dlv exec ./hello -- server --config conf/config.toml` Usage: dlv [command] Available Commands: attach Attach to running process and begin debugging. connect Connect to a headless debug server. core Examine a core dump. debug Compile and begin debugging main package in current directory, or the package specified. exec Execute a precompiled binary, and begin a debug session. help Help about any command run Deprecated command. Use 'debug' instead. test Compile test binary and begin debugging program. trace Compile and begin tracing program. version Prints version. Flags: --accept-multiclient Allows a headless server to accept multiple client connections. --api-version int Selects API version when headless. (default 1) --backend string Backend selection (see 'dlv help backend'). (default \"default\") --build-flags string Build flags, to be passed to the compiler. --check-go-version Checks that the version of Go in use is compatible with Delve. (default true) --headless Run debug server only, in headless mode. --init string Init file, executed by the terminal client. -l, --listen string Debugging server listen address. (default \"127.0.0.1:0\") --log Enable debugging server logging. --log-dest string Writes logs to the specified file or file descriptor (see 'dlv help log'). --log-output string Comma separated list of components that should produce debug output (see 'dlv help log') --only-same-user Only connections from the same user that started this instance of Delve are allowed to connect. (default true) --wd string Working directory for running the program. (default \".\") Additional help topics: dlv backend Help about the --backend flag. dlv log Help about logging flags. Use \"dlv [command] --help\" for more information about a command. 进入调试模式有以下几种办法 dlv attach pid：对正在运行的进程直接进行调试（pid 为进程id）； dlv debug：编译源文件并开始调试，这里应和 main 函数位于同一目录，或者指定完整的 main 函数路径 dlv exec filename：从二进制文件启动调试 我们以下面的程序为例进行说明，使用 dlv debug 进入调试 package main import \"fmt\" func main() { a := 10 fmt.Println(a) } 进入调试，使用 help 可以查看所有可用命令 $ dlv debug main.go Type 'help' for list of commands. (dlv) help The following commands are available: args ------------------------ Print function arguments. break (alias: b) ------------ Sets a breakpoint. breakpoints (alias: bp) ----- Print out info for active breakpoints. call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!) clear ----------------------- Deletes breakpoint. clearall -------------------- Deletes multiple breakpoints. condition (alias: cond) ----- Set breakpoint condition. config ---------------------- Changes configuration parameters. continue (alias: c) --------- Run until breakpoint or program termination. deferred -------------------- Executes command in the context of a deferred call. disassemble (alias: disass) - Disassembler. down ------------------------ Move the current frame down. edit (alias: ed) ------------ Open where you are in $DELVE_EDITOR or $EDITOR exit (alias: quit | q) ------ Exit the debugger. frame ----------------------- Set the current frame, or execute command on a different frame. funcs ----------------------- Print list of functions. goroutine (alias: gr) ------- Shows or changes current goroutine goroutines (alias: grs) ----- List program goroutines. help (alias: h) ------------- Prints the help message. libraries ------------------- List loaded dynamic libraries list (alias: ls | l) -------- Show source code. locals ---------------------- Print local variables. next (alias","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:1:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2. 命令使用 下面通过实践说明这些简单命令的使用 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.1 断点设置 (dlv) b main.go:6 Breakpoint 1 set at 0x4bd2f8 for main.main() F:/Gotest/main.go:6 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:1","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.2 打印断点信息 (dlv) bp Breakpoint runtime-fatal-throw at 0x4377e0 for runtime.fatalthrow() c:/go/src/runtime/panic.go:1162 (0) Breakpoint unrecovered-panic at 0x437860 for runtime.fatalpanic() c:/go/src/runtime/panic.go:1189 (0) print runtime.curg._panic.arg Breakpoint 1 at 0x4bd2f8 for main.main() F:/Gotest/main.go:6 (0) ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:2","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.3 运行直到断点处 (dlv) c \u003e main.main() F:/Gotest/main.go:6 (hits goroutine(1):1 total:1) (PC: 0x4bd2f8) 1: package main 2: 3: import \"fmt\" 4: 5: func main() { =\u003e 6: a := 10 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:3","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.4 下一步 (dlv) n \u003e main.main() F:/Gotest/main.go:7 (PC: 0x4bd301) 2: 3: import \"fmt\" 4: 5: func main() { 6: a := 10 =\u003e 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:4","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.5 查看局部变量 (dlv) locals a = 10 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:5","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.6 查看当前调用栈 (dlv) bt 0 0x00000000004bd301 in main.main at F:/Gotest/main.go:7 1 0x0000000000439cfa in runtime.main at c:/go/src/runtime/proc.go:203 2 0x00000000004643d1 in runtime.goexit at c:/go/src/runtime/asm_amd64.s:1373 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:6","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.7 打印源代码 (dlv) list \u003e main.main() F:/Gotest/main.go:7 (PC: 0x4bd301) 2: 3: import \"fmt\" 4: 5: func main() { 6: a := 10 =\u003e 7: fmt.Println(a) 8: } ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:7","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"2.8 运行到断点处执行某个命令 1 是断点ID，p a 代表指定到断点处打印变量 a 的值 (dlv) on 1 p a (dlv) c 10 Process 6540 has exited with status 0 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:2:8","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"3. Goroutine 调试 Go 的优势在协程，dlv 相比 GDB 的优点也在于对协程调试的支持，我们以下面的程序为例，给出示例 package main import ( \"fmt\" \"time\" ) func main() { a := 10 go printA(a) time.Sleep(1e9) } func printA(a int) { fmt.Println(a) } 设置断点并启动运行 \u003e b main.go:12 Breakpoint 1 set at 0x4bd5be for main.main() F:/Gotest/main.go:12 (dlv) c \u003e main.main() F:/Gotest/main.go:12 (hits goroutine(1):1 total:1) (PC: 0x4bd5be) 7: 8: func main() { 9: a := 10 10: go printA(a) 11: =\u003e 12: time.Sleep(1e9) 13: } 14: 15: func printA(a int) { 16: fmt.Println(a) 17: } 查看当前启动的协程，其中 Goroutine 1 是主协程，Goroutine 6 是自行启动的子协程 (dlv) goroutines * Goroutine 1 - User: F:/Gotest/main.go:12 main.main (0x4bd5be) (thread 11412) Goroutine 2 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 3 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 4 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 5 - User: c:/go/src/runtime/proc.go:305 runtime.gopark (0x43a092) Goroutine 6 - User: F:/Gotest/main.go:15 main.printA (0x4bd5e0) [6 goroutines] 打印主协程当前的变量 (dlv) locals a = 10 如果要查看子协程的情况，需要先切换到子协程 (dlv) goroutine 6 Switched from 1 to 6 (thread 11412) (dlv) bt 0 0x00000000004bd5e0 in main.printA at F:/Gotest/main.go:15 1 0x0000000000464621 in runtime.goexit at c:/go/src/runtime/asm_amd64.s:1373 (dlv) args a = 10 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:3:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"4. 后记 写到这里好像没发现直接使用 dlv 有什么优势，VScode 在 delve 基础上完成的调试功能更方便，比自己使用命令逐步执行好多了。 ","date":"2020-07-26","objectID":"/2020/golang-deep-learning-5-debug-with-dlv/:4:0","tags":["Go语法"],"title":"Golang深入学习5-使用dlv调试程序","uri":"/2020/golang-deep-learning-5-debug-with-dlv/"},{"categories":["Golang学习之路"],"content":"本文关心 map 的底层实现、map 的扩容机制和 map 遍历的随机性。 先解答问题 map 是实现是哈希表+链地址法解决冲突； map 扩容每次增加一倍的空间； map 遍历具有随机性，不要主观地认为遍历的顺序就是插入的顺序。 实际上，除了基本的结构定义，map 的初始化、访问、删除、扩容、遍历等操作并没有完全理解，留待之后再说，先占坑。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:0:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"1. 实现 Go 中映射（map）的底层实现是哈希表，位于 src/runtime/map.go 中，数据被放到一个 buckets 数组里，每个 bucket 包含最多 8 个键值对。key 的哈希值低 8 位用于选择 bucket，高 8 位用于区分 bucket 中存放的多个键值。如果超过 8 个键被放到同一个 bucket，使用一个额外的 bucket 来存储。 核心的结构体主要是 hmap 和 bmap，前者就是这个 bucket 数组，后者就是单个 bucket 的结构。 // map的基础数据结构 type hmap struct { count int // map存储的元素对计数，len()函数返回此值，所以map的len()时间复杂度是O(1) flags uint8 B uint8 // buckets数组的长度，也就是桶的数量为2^B个 noverflow uint16 // 溢出的桶的数量的近似值 hash0 uint32 // hash种子 buckets unsafe.Pointer // 指向2^B个桶组成的数组的指针，数据存在这里 oldbuckets unsafe.Pointer // 指向扩容前的旧buckets数组，只在map增长时有效 nevacuate uintptr // 计数器，标示扩容后搬迁的进度 extra *mapextra // 保存溢出桶的指针数组和未使用的溢出桶数组的首地址 } type mapextra struct { overflow *[]*bmap // overflow contains overflow buckets for hmap.buckets. oldoverflow *[]*bmap // oldoverflow contains overflow buckets for hmap.oldbuckets. // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap } // 桶的实现结构, hmap的buckets指针指向该结构 type bmap struct { // tophash存储桶内每个key的hash值的高字节 // tophash[0] \u003c minTopHash表示桶的疏散状态 // 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对 tophash [bucketCnt]uint8 // 下面紧跟存放的键值对，存放的格式是所有的 key，然后是所有的 value， // 之所以不是一个 key 跟随一个 value，是为了消除填充所需要的间隙，因为 // key 与 value 的类型不一致，占用的内存大小不一致 // 最后是一个溢出指针 } hmap 是哈希表的基础结构，hmap.buckets 实际指向 buckets 数组，hmap.oldbuckets 和 hmap.nevacuate 用于扩容，之后介绍，hmap.extra 保存溢出桶的地址的数组以及未使用的溢出桶数组的首地址。 bmap 是单个桶的结构，是一个长度为 8 的数组，数组每个元素的值是 key 的哈希值的高 8 位，数组之后是 8 个 key，然后 8 个 value，最后一个溢出指针，溢出指针指向额外的桶链表，用于存储溢出的数据。用图描述如下 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:1:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"2. 访问 主要是 map.go 文件中的几个 mapaccess 函数，基本逻辑为 找不到 key，就返回该类型的零值。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:2:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"3. 分配 分配的意思是向 map 中添加新值，主要是 mapassign 函数，基本逻辑与查找相似，但多了写保护和扩容的内容 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:3:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"4. 删除 删除主要是 mapdelete 函数，逻辑如下，删除操作的实质是将值置空，并没有减少内存 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:4:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"5. 遍历 Go 中 map 遍历的一个突出特征就是元素顺序的随机化，即每次遍历得到的元素的顺序不一定相同，和元素的插入顺序无关。 Go 中遍历的基本逻辑是先调用 mapiterinit 初始化 hiter 结构体，然后利用 该结构体进行遍历。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:5:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"6. 扩容 首先，判断是否需要扩容的逻辑是 func (h *hmap) growing() bool { return h.oldbuckets != nil } 何时h.oldbuckets不为nil呢？在分配assign逻辑中，当没有位置给key使用，而且满足测试条件(装载因子\u003e6.5或有太多溢出通)时，会触发hashGrow逻辑： func hashGrow(t *maptype, h *hmap) { //判断是否需要sameSizeGrow，否则\"真\"扩 bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { bigger = 0 h.flags |= sameSizeGrow } // 将buckets复制给oldbuckets oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags \u0026^ (iterator | oldIterator) if h.flags\u0026iterator != 0 { flags |= oldIterator } // 更新 hmap 结构 h.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 // 设置溢出桶 if h.extra != nil \u0026\u0026 h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\"oldoverflow is not nil\") } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). } 这里需要明白，map 扩容时每次增大一倍，方法是分配一个新的 Bucket 数组，然后将就数组复制过去。 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:6:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"参考 [1] 简书，Love语鬼，Golang map的底层实现 ","date":"2020-07-25","objectID":"/2020/golang-deep-learning-4-map/:7:0","tags":["Go语法"],"title":"Golang深入学习4-map","uri":"/2020/golang-deep-learning-4-map/"},{"categories":["Golang学习之路"],"content":"本篇理解切片的底层实现和扩容方式。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:0:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"1. 实现 切片的定义位于 src/runtime/slice.go，如下 type slice struct { array unsafe.Pointer // 用来存储实际数据的数组指针，指向一块连续的内存 len int // 切片中元素的数量 cap int // array数组的长度 } 所以可见切片和字符串很相似，实质都是一个指针，只不过除了长度 len 还有一个容量字段 cap。一个简单的图解如下 图中的 x 和 y 都是从数组 [5]int{2,3,5,7,11} 上获取的切片，也就是指向该数组的不同位置。 上篇介绍字符串的时候提到字符串虽然底层是指针，但不允许等于 nil，它的空值是空字符串 \"\"。但切片是可以等于 nil 的，只要其底层指针等于 nil，一般情况是切片声明而未初始化的时候出现该情况，这个时候因为没有指向任何内存区域，切片的长度和容量信息都是无效的，不过还是可以获取到。 注：因为切片等于 nil 一般意味着没有初始化，也就没有使用的价值，所以很少将切片直接和 nil 作比较，使用更多的还是判断切片的长度是否为0（len(s) == 0） func main() { var s []int fmt.Println(s, len(s), cap(s)) fmt.Println(s == nil) } // Output [] 0 0 true 切片一旦初始化，底层指针就指向了一个确定的内存区域，但指向的内存区域大小可以为0，也就是切片中没有任何元素，此时切片的长度也是 0，但和未初始化时得到的长度绝不是一个含义。 func main() { var s []int s = []int{} fmt.Println(s, len(s), cap(s)) fmt.Println(s == nil) } // Output [] 0 0 false ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:1:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"2. 扩容 切片的长度是当前所包含的元素个数，容量是可容纳的最大元素个数。这里的含义是，初始化时指定的容量就代表在内存已经预分配了与容量相等的空间，其后访问、添加、删除切片的元素都和数组相似，只操作指针，不会造成内存重新分配。 func main() { s := make([]int, 0, 3) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) s = append(s, 1) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) } // Output 0xc000124180 [] 0 3 0xc000124180 [1] 1 3 但是，如果追加的元素数量超过了容量，那么会导致内存的重新分配。 func main() { s := make([]int, 0, 3) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) s = append(s, 1, 2, 3, 4) fmt.Printf(\"%p \", s) fmt.Println(s, len(s), cap(s)) } // Output 0xc000124180 [] 0 3 0xc000146030 [1 2 3 4] 4 6 内存的重新分配就是切片的扩容，其逻辑是，为切片分配一块更大的内存，然后将旧切片的元素复制到新切片中。 一个很有意思的情况如下，将切片 s 赋值给一个新的切片 l，然后对原切片 s 进行扩容和修改，不会影响到切片 l func main() { s := make([]int, 3, 3) fmt.Printf(\"%p %v\\n\", s, s) l := s[:] s = append(s, 1) s[0] = 1 fmt.Printf(\"%p %v\\n\", s, s) fmt.Printf(\"%p %v\", l, l) } // Output 0xc000124180 [0 0 0] 0xc000146030 [1 0 0 1] 0xc000124180 [0 0 0] 最后一个值得注意的问题是切片每次扩容会扩大多少，这个逻辑位于 src/runtime/slice.go 文件中的 growslice 函数中，其中 old.len 是旧长度，old.cap 是旧容量，newcap 是新容量，cap 是需要的容量， // ...省略 newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap } else { if old.len \u003c 1024 { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } // ...省略 简单描述就是： 如果需要的容量超过原切片容量的两倍，直接使用需要的容量作为新容量； 如果原切片的长度小于 1024，新切片的容量翻倍； 如果原切片的长度大于1024，则每次增加25%，直到新容量超过所需要的容量； 第二条的翻倍倒是可以确认，但第一条和第三条经验证却不太符合 func main() { // 1. 需要的容量超过原切片容量的两倍，新容量应为需要的容量5 s1 := make([]int, 2) fmt.Printf(\"%p %v\\n\", s1, cap(s1)) s1 = append(s1, 3, 4, 5) fmt.Printf(\"%p %v\\n\", s1, cap(s1)) // 2. 原切片长度小于1024，新容量应当翻倍为4 s2 := make([]int, 2) fmt.Printf(\"%p %v\\n\", s2, cap(s2)) s2 = append(s2, 3) fmt.Printf(\"%p %v\\n\", s2, cap(s2)) // 3. 原切片长度大于1024，新容量递增25%1次，应当为1500 s3 := make([]int, 1200) fmt.Printf(\"%p %v\\n\", s3, cap(s3)) s3 = append(s3, 3) fmt.Printf(\"%p %v\", s3, cap(s3)) } // Output 0xc0000120b0 2 0xc00000a390 6 0xc0000120f0 2 0xc0000104c0 4 0xc000100000 1200 0xc00010c000 1536 这是因为扩容的那一段核心源码后面还有一段新容量的处理过程，如下 var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch { case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u003e maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026 31 } lenmem = uintptr(old.len) \u003c\u003c shift newlenmem = uintptr(cap) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } 其中 et 是切片中的元素类型，sys.PtrSize 是一个指针的大小，64位系统中为8，主要调用的处理函数 roundupsize 来自 src/runtime/msize.go 文件，如下 // Returns size of the memory block that mallocgc will allocate if you ask for the size. func roundupsize(size uintptr) uintptr { // _MaxSmallSize = 32768 if size \u003c _MaxSmallSize { // smallSizeMax = 1024 if size \u003c= smallSizeMax-8 { return uintptr(class_to_size[size_to_class8[divRoundUp(size, smallSizeDiv)]]) } else { return uintptr(class_to_size[size_to_class128[divRoundUp(size-smallSizeMax, largeSiz","date":"2020-07-24","objectID":"/2020/golang-deep-learning-3-slice/:2:0","tags":["Go语法"],"title":"Golang深入学习3-切片","uri":"/2020/golang-deep-learning-3-slice/"},{"categories":["Golang学习之路"],"content":"Go 中字符串虽然作为基本数据类型，但本质依然是字符数组，本篇文章理解 Go 底层 string 类型是如何实现的，以及探讨它与 []byte 之间的关系。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:0:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"1. string 标准库 builtin 声明了 Go 所有的预定义标识符，其中对 string 的描述如下 string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable. 意思是字符串是字节的一个序列，约定但不必须是 UTF-8 编码的文本。字符串可以为空但不能是nil，其值不可变。Go 中字符串的源码定义在 src/runtime/string.go 中，如下 type stringStruct struct { str unsafe.Pointer len int } 所以 Go 中字符串是一个结构体，其中包含两个字段，第一个字段 str 是个指针，第二个字段 len 是字符串长度。str 指针虽然是 unsafe.Pointer 类型，但它最后其实指向了一个 byte 类型的数组，如下 //go:nosplit func gostringnocopy(str *byte) string { ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} s := *(*string)(unsafe.Pointer(\u0026ss)) return s } 所以我们理解了字符串的赋值其实是指针的复制，同时我们还注意到字符串长度其实调用了 findnull 函数 func findnullw(s *uint16) int { if s == nil { return 0 } p := (*[maxAlloc/2/2 - 1]uint16)(unsafe.Pointer(s)) l := 0 for p[l] != 0 { l++ } return l } 在 findnull 的实现中，maxAlloc 是允许用户分配的最大虚拟内存空间。在 64 位，理论上可分配最大 1 \u003c\u003c heapAddrBits 字节。在 32 位，最大可分配小于 1 \u003c\u003c 32 字节。所以，求长度的逻辑是：如果指针悬空，那么字符串长度为0，否则将指针转换为一个字符数组的指针，然后判断这个字符数组的每个值是否存在，第一个为0的值对应的索引就是字符串的长度。 字符串的值不可改变这个特性是通过禁止访问 str 指针指向的内存的值实现的，但 str 指针本身的值是可以改变的，也就是说它指向的内存区域可以改变，所以字符串可以重复赋值 s := \"hello\" // str 指针指向\"hello\"的内存 s = \"world\" // str 指针指向\"world\"的内存 字符串同时也支持切片操作，我们可以理解为 str 的重新赋值和 len 的重新计算，比如下面的语句中，hello 和 world 其实都指向 s 所指向的内存区域，只是指针的位置不一样。 s := \"hello, world\" hello := s[:5] world := s[7:] 最后，虽然字符串底层指向一个 byte 数组，单独访问其元素得到的类型也是 byte，但使用 for range 语法遍历时，单个值的类型却是 rune。 func main() { s := \"hello\" fmt.Printf(\"%T \", s[1]) for _, v := range s { fmt.Printf(\"%T\", v) break } } // Output uint8 int32 这里主要是因为 Go 专门做了一个解码操作，如下，注意这里的代码不是真的底层实现，只是用来说明逻辑的 func forOnString(s string, forBody func(i int, r rune)) { for i := 0; len(s) \u003e 0; { r,size := utf8.DecodeRuneInString(s) forBody(i,r) s = s[size:] i += size } } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:1:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2. 转换 由以上可知字符串单个字符可能是 byte 或 rune，这也是我们使用字符串时经常做的强制类型转换。它们隐含者内存的重新分配，代价可能是不一样的，所以这里研究一下。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.1 string-\u003e[]byte string 转换 []byte，源码实现如下 func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s) \u003c= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { b = rawbyteslice(len(s)) } copy(b, s) return b } // rawbyteslice allocates a new byte slice. The byte slice is not zeroed. func rawbyteslice(size int) (b []byte) { cap := roundupsize(uintptr(size)) p := mallocgc(cap, nil, false) if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(cap)} return } 我们可以看到其实做了一次内存的重新分配，得到了新的字符数组 b，然后将 s 复制给 b。至于 copy 函数可以直接把 string 复制给 []byte，是因为 go 源码单独实现了一个slicestringcopy函数来实现，具体可以看src/runtime/slice.go。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:1","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.2 []byte-\u003estring []byte 转换 string，源码如下 func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { if n == 0 { // Turns out to be a relatively common case. // Consider that you want to parse out data between parens in \"foo()bar\", // you find the indices and convert the subslice to string. return \"\" } if raceenabled { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), funcPC(slicebytetostring)) } if msanenabled { msanread(unsafe.Pointer(ptr), uintptr(n)) } if n == 1 { p := unsafe.Pointer(\u0026staticuint64s[*ptr]) if sys.BigEndian { p = add(p, 7) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = 1 return } var p unsafe.Pointer if buf != nil \u0026\u0026 n \u003c= len(buf) { p = unsafe.Pointer(buf) } else { p = mallocgc(uintptr(n), nil, false) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = n memmove(p, unsafe.Pointer(ptr), uintptr(n)) return } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } 该转换的思路是新分配 s，然后将 b 复制给它，所以依然有内存的重新分配。 ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:2","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.3 string-\u003e[]rune 源码如下，由于 byte 和 rune 类型的差异，比如进行内存的重新分配。 func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune { // two passes. // unlike slicerunetostring, no race because strings are immutable. n := 0 for range s { n++ } var a []rune if buf != nil \u0026\u0026 n \u003c= len(buf) { *buf = [tmpStringBufSize]rune{} a = buf[:n] } else { a = rawruneslice(n) } n = 0 for _, r := range s { a[n] = r n++ } return a } // rawruneslice allocates a new rune slice. The rune slice is not zeroed. func rawruneslice(size int) (b []rune) { if uintptr(size) \u003e maxAlloc/4 { throw(\"out of memory\") } mem := roundupsize(uintptr(size) * 4) p := mallocgc(mem, nil, false) if mem != uintptr(size)*4 { memclrNoHeapPointers(add(p, uintptr(size)*4), mem-uintptr(size)*4) } *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(mem / 4)} return } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:3","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"2.4 []rune-\u003estring 源码如下，内存分配没得跑。 func slicerunetostring(buf *tmpBuf, a []rune) string { if raceenabled \u0026\u0026 len(a) \u003e 0 { racereadrangepc(unsafe.Pointer(\u0026a[0]), uintptr(len(a))*unsafe.Sizeof(a[0]), getcallerpc(), funcPC(slicerunetostring)) } if msanenabled \u0026\u0026 len(a) \u003e 0 { msanread(unsafe.Pointer(\u0026a[0]), uintptr(len(a))*unsafe.Sizeof(a[0])) } var dum [4]byte size1 := 0 for _, r := range a { size1 += encoderune(dum[:], r) } s, b := rawstringtmp(buf, size1+3) size2 := 0 for _, r := range a { // check for race if size2 \u003e= size1 { break } size2 += encoderune(b[size2:], r) } return s[:size2] } func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) { if buf != nil \u0026\u0026 l \u003c= len(buf) { b = buf[:l] s = slicebytetostringtmp(\u0026b[0], len(b)) } else { s, b = rawstring(l) } return } func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026s).str = p stringStructOf(\u0026s).len = size *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, size} return } ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:2:4","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"3. 总结 string 和 []byte，string 和 []rune 的转换都会进行内存的重新分配，有一定代价； 直接访问 string 中的成员，类型为 byte，使用 for range 结构，类型为 rune； 需要修改 string 中的成员时，需要转换 []byte； ","date":"2020-07-24","objectID":"/2020/golang-deep-learning-2-string/:3:0","tags":["Go语法"],"title":"Golang深入学习2-string","uri":"/2020/golang-deep-learning-2-string/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Go 中的指针、uintptr 和 unsafe.Pointer 三个概念。 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:0:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"1. 指针 Go 中指针的概念与 C 相同，只是指针本身不能进行运算。 任何一个变量在运行时都有一个地址，这个地址代表它在内存中的位置，在变量名前使用取地址符 \u0026 可以获取该变量的内存地址，比如 ptr := \u0026v 其中 v 是一个变量，ptr 用来保存它的内存地址，ptr 就是指针。当然，准确的来说，ptr 是一个指针变量，作为变量，仍然是用来保存数据，只不过这里它特别用来保存一个内存地址而已。 一个指针变量需要使用 * 来声明，如下 var ptr *int * 代表 ptr 保存一个地址，而 int 代表这个地址指向的内存所保存的数据是 int 类型。这里要注意，*int 和 *string 是不同的指针类型，不能相互赋值，如下例，指针的类型与它所指向的内存地址保存的数据类型有关。 func main() { var a *int b := \"hello\" a = \u0026b } // Output .\\main.go:6:4: cannot use \u0026b (type *string) as type *int in assignment 指针在声明但未赋值时其值为 nil，不指向任何内存 func main() { var a *int fmt.Println(a) } // Output \u003cnil\u003e 将一个变量的地址赋值给指针后，进行使用要利用 * 符号，否则其值就是所保存的内存地址 func main() { var a *int b := 10 a = \u0026b fmt.Println(a, *a) } // Output 0xc000012098 10 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:1:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"2. unsafe.Pointer 我们已经知道不同的指针类型间不能相互赋值，另外，它们也不能进行类型转换 func main() { var a *int b := 10 a = \u0026b c := (*float64)(a) } // Output .\\main.go:7:17: cannot convert a (type *int) to type *float64 unsafe.Pointer 是特别定义的一种指针类型，它可以包含任意类型变量的地址，也就是说无论 int、float64 还是其它类型的变量，内存地址都可以交给它保存。 package main import ( \"fmt\" \"unsafe\" ) func main() { b := 10 var a *int = \u0026b c := unsafe.Pointer(a) fmt.Println(c) } // Output 0xc000012098 从上面的程序注意到两点 unsafe.Pointer 来自 unsafe 包，不是内置类型； unsafe.Pointer 一般作为指针类型转换的桥梁使用 unsafe.Pointer 本质是一个 *int，在 unsafe 包中定义如下 type ArbitraryType int type Pointer *ArbitraryType unsafe.Pointer 的使用说明如下 任意类型的指针可以转换为一个Pointer类型值 一个Pointer类型值可以转换为任意类型的指针 一个uintptr类型值可以转换为一个Pointer类型值 一个Pointer类型值可以转换为一个uintptr类型值 下面是一个使用 unsafe.Pointer 作为桥梁进行类型转换的例子 func main() { b := 10 var a *int = \u0026b c := (*float64)(unsafe.Pointer(a)) } ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:2:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"3. uintptr uintptr 确确实实是 Go 的基本类型，属于整型的一种，被设计为足够容纳一个指针。在 Go 中指针是不允许进行运算的，但 uintptr 可以，所以它的意义在于将其它类型的指针转换成它进行运算，然后再转换回原本的类型。 type User struct { Name string Age int } func main() { u := new(User) name :=(*string)(unsafe.Pointer(u)) *name = \"test\" age := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(u)) + unsafe.Offsetof(u.Age))) *age = 18 fmt.Println(u) } 思路: 如果想对 Name 和 Age 进行赋值，那首先应该先拿到相应的地址，然后对地址内容修改，所以我们可以分别定义一个 string 和 int 分别指向 Name 和 Age的地址 对于 u 这个结构体，u 的首地址就是 Name 的地址，但是 u 是结构体指针，所以只需要将u转换成 *string 即可 对于 Age，我们已经拿到了Name的地址，在此基础上进行偏移即可，也就是 unsafe.Offsetof(u.Age) 的偏移量， 但是 Pointer不能进行指针运算，随意需要将 Pointer 转换成 uintptr ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:3:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"4. 说明 这里有两点要说明。 第一，理解 unsafe.Pointer 和 uintptr 是因为 Go 源码中很多实现都使用了这两个概念，比如接口类型的定义 type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter *interfacetype _type *_type hash uint32 _ [4]byte fun [1]uintptr } 第二，使用 unsafe.Pointer 和 uintptr 要非常注意，因为它们绕过了类型系统直接操作内存地址。 ","date":"2020-07-23","objectID":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/:4:0","tags":["Go语法"],"title":"Golang深入学习1-uintptr 和 Unsafe.Pointer","uri":"/2020/golang-deep-learning-1-uintptr-and-unsafe.pointer/"},{"categories":["Golang学习之路"],"content":"部署 Go 应用相对简单，因为所有应用代码都被打包成一个二进制文件了（视图模板、静态资源和配置文件等非 Go 代码除外），并且不需要依赖其他库，不需要额外的运行时环境（比如 Java 需要再安装 JVM），也不需要部署额外的 HTTP 服务器。 对于在线论坛项目，包含了静态资源文件（CSS、JavaScript、图片），所以我们将在 Go Web 应用之前前置一个 Nginx 服务器处理静态资源请求，然后通过反向代理处理动态资源请求（指向 Go 处理器方法的请求），对于那些不包含静态资源和视图模板的纯 API 项目，通常只需要打包一份二进制文件部署到服务器即可，更加便捷。 注：其实 Go 应用部署的最佳实践是基于 Docker，后续我们在部署专题中再介绍如何基于 Docker 将应用快速部署到远程云服务器。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"1. 构建应用 首先，我们可以在本地项目根目录下通过如下命令将应用代码打包成二进制可执行文件： GOOS=linux GOARCH=amd64 go build 注意这里指定了 GOOS 和 GOARCH 选项进行交叉编译，因为我们是在 Win10 系统（amd64）中打包，并且目标二进制文件需要在 Linux 服务器（linux）执行。该命令执行成功后会在当前目录下生成和项目名称相同的二进制文件： 然后我们可以将代码提交到 Github 或者其他代码仓库。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2. 部署应用 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.1 部署代码 再登录服务器到部署目录下拉取代码： git clone https://github.com/nonfu/chitchat 初次拉取使用 git clone，后续在 chitchat 目录下运行 git pull 即可。 然后我们进入 chitchat 目录，配置 config.json 进行服务端数据库配置（正式项目不要将 config.json 提交到代码仓库，以免安全风险和后续拉取代码覆盖），确保 logs 目录对 Web 用户具有写权限（比如配置权限为 777，或者所属用户与 Web 用户组一致）。 注：当然我们这里部署代码的方式比较原始，对于多人协作的大型项目，可以借助持续集成工具（比如 Jenkins）进行自动化部署，并且由于项目比较简单，就不再演示单元测试、CI/CD 等其他 DevOps 工具的使用了。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.2 数据库初始化 在服务端 MySqL 数据库中创建 chitchat 数据库，并初始化对应数据表。如果不了解如何安装和创建数据库，可以参考这篇教程：将博客应用自动部署到线上服务器完整流程详解。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"2.3 访问应用 完成以上工作后，我们就可以在 chitchat 项目目录下运行 chitchat 二进制文件启动应用了： 然后我们在本地 hosts 文件中自定义一个测试域名与服务器 IP 的映射： your-server-ip-address chitchat.test 将上述 your-server-ip-address 替换成自己的远程服务器 IP 地址，然后我们就可以在浏览器中通过 http://chitchat.test:8080 访问应用了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"3. 通过 Nginx 做反向代理 虽然上述方式可以正常运行，但是如果要高效处理静态资源文件并对其做缓存，可以借助 Nginx 作为反向代理服务器来完成，我们在 Nginx 虚拟主机配置目录 /etc/nginx/sites-available 中新增一个配置文件 chitchat.conf（以 Ubuntu 服务器为例）： server { listen 80; server_name chitchat.test www.chitchat.test; # 静态资源交由 Nginx 管理，并缓存一天 location /static { root /var/www/chitchat/public; expires 1d; add_header Cache-Control public; access_log off; try_files $uri @goweb; } location / { try_files /_not_exists_ @goweb; } # 动态请求默认通过 Go Web 服务器处理 location @goweb { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Scheme $scheme; proxy_redirect off; proxy_pass http://127.0.0.1:8080; } error_log /var/log/nginx/chitchat_error.log; access_log /var/log/nginx/chitchat_access.log; } 然后再启用该配置文件： ln -s /etc/nginx/sites-available/chitchat /etc/nginx/sites-enabled/chitchat 重启 Nginx 服务： service nginx restart 与此同时，我们可以把 chitchat/config.json 中的 App 配置项启动 IP 地址改为 127.0.0.1： \"App\": { \"Address\": \"127.0.0.1:8080\", \"Static\": \"public\", \"Log\": \"logs\", \"Locale\": \"locales\", \"Language\": \"zh\" }, 并再次重启这个 Go 应用，这样就只能通过 Nginx 访问应用，在浏览器中访问 http://chitchat.test： 而当你试图再通过 http://chitchat.test:8080 访问应用，则会报错： 我们可以测试下注册登录功能以及创建新群组功能： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"4. 通过 Supervisor 维护应用守护进程 看起来一切都 OK 了，但是目前这种模式下，用户退出后 Go Web 应用进程会关闭，这显然是不行的，而且如果 Go Web 应用进程因为其他异常挂掉，也无法自动重启，每次需要我们登录到服务器进行启动操作，这很不方便，也影响在线应用的稳定性，为此，我们需要借助第三方进程监控工具帮我们实现 Go Web 应用进程以后台守护进程的方式运行。常见的进程监控工具有 Supervisor、Upstart、systemd 等，由于我的服务器之前部署过 Supervisor，所以我就借助它来管理 Go Web 应用进程。 注：对 Supervisor 安装配置不了解的同学，可以参考这篇教程 —— 队列系统解决方案：Horizon。 首先创建对应的 Supervisor 配置文件 /etc/supervisor/conf.d/chitchat.conf，这里需要设置进程启动目录及命令、进程意外挂掉后是否自动重启、以及日志文件路径等： [program:chitchat] process_name=%(program_name)s directory=/var/www/chitchat command=/var/www/chitchat/chitchat autostart=true autorestart=true user=root redirect_stderr=true stdout_logfile=/var/www/chitchat/logs/chitchat.log 注意：我们需要进入 chitchat 所在目录执行启动命令，否则会找不到配置文件和其他资源路径，所以需要配置 directory 选项。 然后关闭之前通过手动运行 chitchat 启动的 Go Web 服务器，再运行如下指令通过 Supervisor 启动并维护 Go Web 应用进程： supervisorctl reread supervisorctl update supervisorctl start chitchat 你可以通过 ps -ef | grep chitchat 查看进程是否启动成功： 启动成功后，就可以在浏览器通过 http://chitchat.test 访问部署在远程服务器的在线论坛了： 并且无论是否退出远程服务器还是关闭 Go Web 应用进程，都不会影响在线论坛的访问，因为它是以守护进程的方式运行的，并且可以在关闭后自动重启。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛9-部署Go Web应用","uri":"/2020/development-of-online-forum-based-on-golang-9-deploy-go-web-application/"},{"categories":["Golang学习之路"],"content":"由于之前所有页面和消息文本都是英文的，而我们开发的应用基本都是面向中文用户的，所以需要对项目进行本地化，因此本篇介绍如何在 Go Web 应用中进行国际化和本地化编程，由于项目比较简单，只介绍消息提示、视图模板和日期格式的本地化。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1. 消息本地化 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.1 安装 go-i18n 扩展包 首先来看消息提示文本，消息提示文本通常包括表单验证消息、应用异常消息、接口响应消息等后端接口返回的消息字符串片段，关于这一块的本地化，可以借助 Go 官方自带的 golang.org/x/text 扩展包实现，这个扩展包扩展性好，但是上手起来有点复杂，因此我们使用的是一款更容易上手的第三方扩展包 —— go-i18n。 在使用这个扩展包之前，先在项目根目录下运行如下命令下载相关的扩展包： go get -u github.com/nicksnyder/go-i18n/v2/i18n go get -u github.com/nicksnyder/go-i18n/v2/goi18n 下载完成后，我们可以运行 goi18n -help 确保 goi18n 命令可执行 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.2 通过 go-i18n 自动生成翻译文件 接下来，我们来编写消息文本模板用于生成翻译文件。在这个项目中，只有一个消息提示文本，那就是访问的群组不存在时返回的 Cannot read thread，因此，我们在项目根目录下创建 messages.go，并基于 go-i18n 提供的类型编写消息模板如下： package main import \"github.com/nicksnyder/go-i18n/v2/i18n\" var messages = []i18n.Message{ { ID: \"thread_not_found\", Description: \"Thread not exists in db\", Other: \"Cannot read thread\", }, } 其中 ID 是消息文本的唯一标识，Other 则是对应的翻译字符串（默认是英文），然后基于 goi18n 命令自动生成翻译文件到 locales 目录（执行前先创建 locales 目录）： mkdir locales goi18n extract -outdir=locales -format=json messages.go 这样，就会在 locales 目录下生成可以被 go-i18n 包识别并解析的 JSON 格式翻译文件 active.en.json： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.3 编写中文版本翻译文件 然后，要进行本地化编程，可以在同级目录下创建并编辑 active.zh.json 用于存放消息文本的中文翻译： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.4 本地化配置初始化 回到在在线论坛项目，打开配置文件 config.json，新增本地化目录和语言配置： { \"App\": { ... \"Locale\": \"locales\", \"Language\": \"zh\" }, ... } 然后在 config/config.go 中新增与之映射的结构体字段，以及对应的初始化设置： package config import ( \"encoding/json\" \"github.com/nicksnyder/go-i18n/v2/i18n\" \"golang.org/x/text/language\" \"log\" \"os\" \"sync\" ) type App struct { ... Locale string Language string } ... type Configuration struct { App App Db Database LocaleBundle *i18n.Bundle } var config *Configuration var once sync.Once // 通过单例模式初始化全局配置 func LoadConfig() *Configuration { once.Do(func() { file, err := os.Open(\"config.json\") if err != nil { log.Fatalln(\"Cannot open config file\", err) } decoder := json.NewDecoder(file) config = \u0026Configuration{} err = decoder.Decode(config) if err != nil { log.Fatalln(\"Cannot get configuration from file\", err) } // 本地化初始设置 bundle := i18n.NewBundle(language.English) bundle.RegisterUnmarshalFunc(\"json\", json.Unmarshal) bundle.MustLoadMessageFile(config.App.Locale + \"/active.en.json\") bundle.MustLoadMessageFile(config.App.Locale + \"/active.\" + config.App.Language + \".json\") config.LocaleBundle = bundle }) return config } 注意我们在 App 结构体中新增了一个 *i18n.Bundle 类型的 LocaleBundle 字段，用于存放全局本地化 Bundle 实例，并且在 LoadConfig() 方法中以单例模式初始化该实例。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.5 在处理器方法中返回本地化消息 接下来，我们打开 handlers/helper.go，在 init 方法中初始化 Localizer 以便被所有处理器方法使用： package handlers import ( ... \"github.com/nicksnyder/go-i18n/v2/i18n\" . \"github.com/xueyuanjun/chitchat/config\" ) var logger *log.Logger var config *Configuration var localizer *i18n.Localizer func init() { // 获取全局配置实例 config = LoadConfig() // 获取本地化实例 localizer = i18n.NewLocalizer(config.LocaleBundle, config.App.Language) ... } ... 最后在 handlers/thread.go 和 handlers/post.go 中调用 errorMessage 辅助函数的地方调用 Localizer 提供的方法对消息文本进行翻译并返回给用户： if err != nil { msg := localizer.MustLocalize(\u0026i18n.LocalizeConfig{ MessageID: \"thread_not_found\", }) errorMessage(writer, request, msg) } else { ... } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:5","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"1.6 测试消息本地化 重新启动应用，如果试图访问一个不存在的群组页面，就会返回如下中文提示信息： 说明我们的本地化翻译生效了，当然这里只是使用了 go-i18n 提供的最基本的功能，想要了解更多使用示例，可以参考如下链接： 官方文档 借助 go-i18n 更简单地实现全球化 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:1:6","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2. 视图本地化 所谓视图本地化指的是静态 HTML 视图模板的本地化，这里就不再适合使用消息文本翻译的方式实现了，最简单的方式就是为每个语言创建独立的视图模板进行本地化，然后在应用代码中通过读取全局配置、用户手动选择、客户端参数（比如 HTML 请求头中的 Accept-Language 字段）、或者域名信息来判断加载那种本地化视图模板，为了简化演示流程，这里我们使用全局配置的方式，也就是我们上面配置文件中设置的 Language 字段。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.1 创建本地化视图模板 首先，我们在 views 目录下新增 en 和 zh 两个子目录，分别用于存放英文视图模板和中文视图模板，然后将原有视图文件移动到 en 目录下，并且在 zh 目录下创建每个视图模板的中文版本，以首页 index.html 为例，对应的中文版本如下： 其他中文视图模板也是类似，将其中的英文文本统一翻译成中文即可。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.2 通过配置加载本地化视图 打开 handlers/helper.go，在 generateHTML 方法中通过读取全局配置加载对应的本地化视图模板： func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s/%s.html\", config.App.Language, file)) } templates := template.Must(template.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } 非常简单，不再赘述。 注：同时移除 parseTemplateFiles 方法，并将调用该方法的地方调整为调用 generateHTML 以避免维护两个地方。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"2.3 测试视图本地化 重启应用，访问首页，即可看到页面视图已经都是中文显示了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3. 日期时间本地化 看起来都已经 OK 了，不过还有个小问题，那就是日期时间显示还是英文风格的，对应的实现代码在 models/thread.go 中： func (thread *Thread) CreatedAtDate() string { return thread.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } 我们当然可以直接修改这里来实现类似 2006-01-02 15:04:05 的日期时间格式（该时间节点是 Go 语言元年），不过，学院君这里换一种复杂一点的实现，以便顺手介绍下如何在 Go 视图模板中通过管道模式调用自定义函数。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3.1 将自定义函数应用到视图模板 打开 handlers/helper.go，新增一个格式化日期时间的函数 formatDate，然后在 generateHTML 方法中将这个函数通过 template.FuncMap 组装后再通过 Funcs 方法应用到视图模板中，这样，就可以在所有视图模板中通过 fdate 别名来调用 formatDate 函数了： // 生成 HTML 模板 func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s/%s.html\", config.App.Language, file)) } funcMap := template.FuncMap{\"fdate\": formatDate} t := template.New(\"layout\").Funcs(funcMap) templates := template.Must(t.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } ... // 日期格式化辅助函数 func formatDate(t time.Time) string { datetime := \"2006-01-02 15:04:05\" return t.Format(datetime) } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"3.2 调用自定义函数格式化本地日期时间 然后我们在所有视图文件中将群组创建日期渲染调整为如下方式，即通过管道连接符的方式将 .CreatedAt 变量作为参数传入 fdate 并输出返回值： {{ .CreatedAt | fdate }} 注意这里一定要使用 .CreatedAt，这个变量才是 time.Time 类型，而 .CreatedAtDate 是字符串类型。 再次重新启动应用，访问首页和群组详情页就可以看到格式化后的本地日期时间格式了： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛8-消息、视图和日期时间本地化","uri":"/2020/development-of-online-forum-based-on-golang-8-message-view-and-date-time-localizationsingleton-mode/"},{"categories":["Golang学习之路"],"content":"本文介绍如何将敏感信息或可变信息通过配置文件进行配置，然后在应用中读取这些配置文件来获取配置信息。 将敏感信息通过配置文件读取是为了避免随着代码提交到公开库造成敏感信息的泄露，给线上环境带来安全隐患，这些敏感信息包括数据库连接信息、第三方 SDK （比如微信、支付宝、Github）的密钥等。 将可变信息通过配置文件读取是为了避免硬编码，将经常变动的信息通过配置文件配置可以极大的提高代码的可维护性，这些可变信息通常包括应用服务器监听的地址和端口、目录路径设置、当前运行环境、超时时间等。 使用公开库时，如 github，配置文件需要写入 .gitignore 文件从而避免提交到线上。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"1. 定义全局配置文件 接下来，我们为在线论坛项目设置配置文件 config.json，将一些敏感信息和可变信息提交到 JSON 配置文件中 { \"App\": { \"Address\": \"0.0.0.0:8080\", \"Static\": \"public\", \"Log\": \"logs\" }, \"Db\": { \"Driver\": \"mysql\", \"Address\": \"localhost:3306\", \"Database\": \"chitchat\", \"User\": \"root\", \"Password\": \"root\" } } 应用相关的可变信息配置到 app 配置项，数据库相关的敏感信息配置到 Db 配置项 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"2. 通过单例模式初始化全局配置 在根目录下创建 config 目录，然后在该目录下新增 config.go 用来存放配置初始化代码 package config import ( \"encoding/json\" \"log\" \"os\" \"sync\" ) type App struct { Address string Static string Log string } type Database struct { Driver string Address string Database string User string Password string } type Configuration struct { App App Db Database } var config *Configuration var once sync.Once // 通过单例模式初始化全局配置 func LoadConfig() *Configuration { once.Do(func() { file, err := os.Open(\"config.json\") if err != nil { log.Fatalln(\"Cannot open config file\", err) } decoder := json.NewDecoder(file) config = \u0026Configuration{} err = decoder.Decode(config) if err != nil { log.Fatalln(\"Cannot get configuration from file\", err) } }) return config } 定义 Configuration 结构体以便和全局配置文件 config.json 字段进行映射，注意这里的首字母都需要大写 定义一个 LoadConfig 方法以单例模式返回全局配置实例的指针，这里使用单例的原因是因为应用代码中可能多处都要获取配置值，重复加载配置文件进行 JSON 解码存在性能损耗（当然，定义 init 方法本身就可以支持全局运行一次，这里主要演示下单例模式如何实现）。在 Go 语言中，我们可以借助并发编程中的 sync.Once 类型来实现单例模式，保证并发安全，在 once.Do 中定义的匿名函数全局只会执行一次 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3. 项目代码重构 最后，我们将项目代码中相应位置的硬编码调整为通过上面方法返回的全局配置实例获取配置值 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3.1 Web 服务器启动参数 首先需要在 main.go 的入口位置初始化全局配置 package main import ( . \"github.com/xueyuanjun/chitchat/config\" . \"github.com/xueyuanjun/chitchat/routes\" \"log\" \"net/http\" ) func main() { startWebServer() } // 通过指定端口启动 Web 服务器 func startWebServer() { // 在入口位置初始化全局配置 config := LoadConfig() r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 // 处理静态资源文件 assets := http.FileServer(http.Dir(config.App.Static)) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) log.Println(\"Starting HTTP service at \" + config.App.Address) err := http.ListenAndServe(config.App.Address, nil) if err != nil { log.Println(\"An error occured starting HTTP listener at \" + config.App.Address) log.Println(\"Error: \" + err.Error()) } } 我们在 startWebServer 方法的入口位置初始化全局配置，并且全局配置实例只在这里进行一次初始化，后续不会再执行加载配置文件和 JSON 解码操作，而是直接返回对应的 config 实例： config := LoadConfig() 然后将 Web 服务器的启动参数和静态资源目录都调整为通过配置值获取，这样我们后续只需要更改配置文件即可对其进行调整，而不需要修改任何代码，降低了代码维护成本。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"3.2 数据库连接配置 接下来，打开 models/db.go，将数据库连接信息调整为通过配置文件读取： package models import ( \"crypto/rand\" \"crypto/sha1\" \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" . \"github.com/xueyuanjun/chitchat/config\" \"log\" ) var Db *sql.DB func init() { var err error config := LoadConfig() // 加载全局配置实例 driver := config.Db.Driver source := fmt.Sprintf(\"%s:%s@(%s)/%s?charset=utf8\u0026parseTime=true\", config.Db.User, config.Db.Password, config.Db.Address, config.Db.Database) Db, err = sql.Open(driver, source) if err != nil { log.Fatal(err) } return } 虽然，在这里页调用了 LoadConfig()，但是由于是单例模式，所以会直接返回 config 实例，不会再进行初始化操作，然后我们获取配置值填充对应的 sql.Open 连接配置。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"4. 整体测试 至此，我们已经完成了通过配置文件读取应用配置的代码重构，我们可以为项目编写单元测试，也可以直接通过在浏览器访问这个在线论坛项目验证重构后应用是否可以正常运行，重新启动 Web 服务器，输出如下： $ go run main.go 2020/06/07 16:54:55 Starting HTTP server at 0.0.0.0:8080 表示启动服务器时读取配置信息正常，然后访问应用首页： 成功，对用户来说，没有任何感知后台的变动。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛7-通过单例模式获取全局配置","uri":"/2020/development-of-online-forum-based-on-golang-7-get-global-configuration-through-singleton-mode/"},{"categories":["Golang学习之路"],"content":"到现在为止，我们已经完成了在线论坛项目基本功能的开发，对 Go 语言 Web 编程中如何实现 MVC 架构模式以及 CRUD（数据库增删改查）基本操作有了初步的认识。不过现在所有的日志和错误处理都是杂糅在业务代码中，本篇介绍如何对它们统一进行处理，使得业务代码和日志及错误处理逻辑分离。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1. 日志处理 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.1 初始化日志处理器 首先来看日志处理，在 handlers/helper.go 中，新增如下日志处理器初始化代码： import ( \"log\" \"os\" ) var logger *log.Logger func init() { file, err := os.OpenFile(\"logs/chitchat.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(\"Failed to open log file\", err) } logger = log.New(file, \"INFO \", log.Ldate|log.Ltime|log.Lshortfile) } 这里我们借助 Go 官方提供的 log 包进行日志处理，首先声明一个 *log.Logger 类型的 logger 变量作为日志处理器，以便可以全局使用。默认的日志文件位于 logs/chitchat.log，我们通过 os.OpenFile 打开这个日志文件句柄，如果文件不存在，则自动创建。然后我们通过 log.New 初始化日志处理器并赋值给 logger，该方法需要传入日志文件、默认日志级别、以及日志格式，关于该方法的细节，我们后面在日志章节会详细介绍。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.2 定义日志函数 然后我们就可以通过 logger 这个日志处理器来记录日志了，在 helper.go 中新增如下几个日志函数： func info(args ...interface{}) { logger.SetPrefix(\"INFO \") logger.Println(args...) } // 为什么不命名为 error？避免和 error 类型重名 func danger(args ...interface{}) { logger.SetPrefix(\"ERROR \") logger.Println(args...) } func warning(args ...interface{}) { logger.SetPrefix(\"WARNING \") logger.Println(args...) } 非常简单，我们定义了三个日志函数来记录三个日志级别，分别是 INFO（普通）、ERROR（错误）、WARNING（警告），然后通过调用 logger.Println 传入参数记录日志信息到日志文件即可，这里的参数类型是 ...interface{}，表示可以传入参数支持任意类型、任意个数。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"1.3 重构业务代码 接下来，我们到业务处理器中，将原来的日志打印代码都重构为调用对应的日志函数，以 handlers/auth.go 为例，修改日志处理代码如下： // src/github.com/xueyuanjun/chitchat/handlers/auth.go // 注册新用户 func SignupAccount(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() if err != nil { danger(err, \"Cannot parse form\") } user := models.User{ Name: request.PostFormValue(\"name\"), Email: request.PostFormValue(\"email\"), Password: request.PostFormValue(\"password\"), } if err := user.Create(); err != nil { danger(err, \"Cannot create user\") } http.Redirect(writer, request, \"/login\", 302) } // 用户认证 func Authenticate(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() user, err := models.UserByEmail(request.PostFormValue(\"email\")) if err != nil { danger(err, \"Cannot find user\") } if user.Password == models.Encrypt(request.PostFormValue(\"password\")) { session, err := user.CreateSession() if err != nil { danger(err, \"Cannot create session\") } cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) http.Redirect(writer, request, \"/\", 302) } else { http.Redirect(writer, request, \"/login\", 302) } } // 用户退出 func Logout(writer http.ResponseWriter, request *http.Request) { cookie, err := request.Cookie(\"_cookie\") if err != http.ErrNoCookie { warning(err, \"Failed to get cookie\") session := models.Session{Uuid: cookie.Value} session.DeleteByUUID() } http.Redirect(writer, request, \"/\", 302) } 其他处理器方法参照这个示例进行调整即可 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2. 错误处理 Go 语言并没有像 PHP、Java 那样提供异常这种类型，只有 error 和 panic，对于 Go Web 应用中的错误处理，不影响程序继续往后执行的，可以通过日志方式记录下来，如果某些错误导致程序无法往后执行，比如浏览群组详情页，对应群组不存在，这个时候，我们就应该直接返回 404 响应或者将用户重定向到 404 页面，而不能继续往后执行，对于这种错误，只能通过单独的处理逻辑进行处理，这种错误类似于 Laravel 中的中断异常处理。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.1 重定向到错误页面 在这个项目中，我们通过重定向到错误页面的方式处理这种类型的错误，在 handlers/helper.go 中新增 error_message 函数： // 异常处理统一重定向到错误页面 func error_message(writer http.ResponseWriter, request *http.Request, msg string) { url := []string{\"/err?msg=\", msg} http.Redirect(writer, request, strings.Join(url, \"\"), 302) } 调用该方法会将用户重定向到错误处理页面（由 err 路由对应处理器方法渲染），响应状态码为 302，并且带上错误消息 msg，以便客户端感知错误原因。 ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.2 编写错误页面相关代码 为此，我们还要编写用于处理应用出错的路由、处理器和视图实现。 处理器方法 首先在 handlers/index.go 中编写全局的、渲染错误页面的处理器方法： func Err(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() _, err := session(writer, request) if err != nil { generateHTML(writer, vals.Get(\"msg\"), \"layout\", \"navbar\", \"error\") } else { generateHTML(writer, vals.Get(\"msg\"), \"layout\", \"auth.navbar\", \"error\") } } 我们可以通过 vals.Get 方法从查询字符串获取 msg 参数，并将其渲染到错误视图 error.html 中。 错误视图 然后在 views 目录下新增 error.html 用来定义错误视图： {{ define \"content\" }} \u003cp class=\"lead\"\u003e{{ . }}\u003c/p\u003e {{ end }} 非常简单，只是通过 {{ . }} 获取 msg 变量的值并渲染出来。 注册路由 最后在 routes/routes.go 中注册错误路由： { \"error\", \"GET\", \"/err\", handlers.Err, }, ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"2.3 重构业务代码 在必要的地方调用错误处理函数 error_message 将用户重定向到错误页面，比如在 handlers/thread.go 中，在浏览群组详情页时，如果指定 ID 对应群组不存在，则将用户重定向到错误页面： // 通过 ID 渲染指定群组页面 func ReadThread(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() uuid := vals.Get(\"id\") thread, err := models.ThreadByUUID(uuid) if err != nil { error_message(writer, request, \"Cannot read thread\") } else { ... } } 又比如 handlers/post.go 中，在创建新主题时，如果获取不到主题归属的群组，则将用户重定向到错误页面： // 在指定群组下创建新主题 func PostThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { ... thread, err := models.ThreadByUUID(uuid) if err != nil { error_message(writer, request, \"Cannot read thread\") } ... } } ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"3. 整体测试 至此，我们已经完成了日志和错误统一处理的代码重构，接下来，可以进行简单的测试，重启 HTTP 服务器，访问应用首页，此时会引入 helper.go，执行 init 方法，创建日志文件，我们试图使用错误的用户名密码登录： 测试就可以在 logs/chitchat.log 中看到错误日志了： ERROR 2020/04/07 14:55:39 helper.go:71: sql: no rows in result set Cannot find user 接下来，我们访问一个不存在的群组 http://localhost:8080/thread/read?id=100，页面就会重定向到错误页面： ","date":"2020-06-07","objectID":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛6-日志与错误处理","uri":"/2020/development-of-online-forum-based-on-golang-6-log-and-error/"},{"categories":["Golang学习之路"],"content":"日志是一个系统必不可少的部分，本篇介绍Golang中的日志系统。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:0:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1. 内置log包 官方提供的 log 包实现了简单的日志服务。该包定义了一个 Logger 类型，提供了一些格式化输出方法，为了更容易地使用，对该类型提供了一个标准 Logger 实现，该 Logger 会打印每条日志信息的日期、时间、默认输出到标准错误，Fatal系列函数会在写入日志信息后调用 os.Exit(1)。Panic系列函数会在写入日志信息后panic。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1.1 内置实现 一个内置实现使用的简单例子如下 // This sample program demonstrates how to use the base log package. package main import ( \"log\" ) func init() { log.SetPrefix(\"TRACE: \") log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile) } func main() { // Println writes to the standard logger. log.Println(\"message\") // Fatalln is Println() followed by a call to os.Exit(1). log.Fatalln(\"fatal message\") // Panicln is Println() followed by a call to panic(). log.Panicln(\"panic message\") } ------------------------------- TRACE: 2019/04/09 14:24:32.868375 D:/go/TestFile/src/main/TestLog.go:15: message TRACE: 2019/04/09 14:24:32.962329 D:/go/TestFile/src/main/TestLog.go:18: fatal message Process finished with exit code 1 原型函数的说明如下 func Flags() int // Flags返回标准logger的输出选项 func SetFlags(flag int) // SetFlags设置标准logger的输出选项 func Prefix() string // Prefix返回标准logger的输出前缀 func SetPrefix(prefix string) // SetPrefix设置标准logger的输出前缀 func SetOutput(w io.Writer) // SetOutput设置标准logger的输出目的地，默认是标准错误输出 // Printf调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Printf相同的方法处理。 func Printf(format string, v ...interface{}) // Print调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Print相同的方法处理。 func Print(v ...interface{}) // Println调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Println相同的方法处理。 func Println(v ...interface{}) func Fatalf(format string, v ...interface{}) // Fatalf等价于{Printf(v...); os.Exit(1)} func Fatal(v ...interface{}) // Fatal等价于{Print(v...); os.Exit(1)} func Fatalln(v ...interface{}) // Fatalln等价于{Println(v...); os.Exit(1)} func Panicf(format string, v ...interface{}) // Panicf等价于{Printf(v...); panic(...)} func Panic(v ...interface{}) // Panic等价于{Print(v...); panic(...)} func Panicln(v ...interface{}) // Panicln等价于{Println(v...); panic(...)} SetPrefix 设置输出前缀，SetfFlags 设置输出选项，为了理解输出前缀与选项，我们先来看一个标准输出 TRACE: 2019/04/09 14:24:32.868375 D:/go/TestFile/src/main/TestLog.go:15: message 其中，TRACE 就是输出前缀，可以通过 SetPrefix 设置，通过 Prefix 输出，用来在普通的程序输出中分布出日志。后面冒号前的信息就是输出选项，通过 SetFlags 设置，通过 Flags 输出。输出选项的结构定义如下 const ( // 字位共同控制输出日志信息的细节。不能控制输出的顺序和格式。 // 在所有项目后会有一个冒号：2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 \u003c\u003c iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒分辨率：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.go:23 Lshortfile // 文件无路径名+行号：d.go:23（会覆盖掉Llongfile） LstdFlags = Ldate | Ltime // 标准logger的初始值 ) log 包有一个很方便的地方就是，这些日志记录器是多 goroutine 安全的。这意味着在多个goroutine 可以同时调用来自同一个日志记录器的这些函数，而不会有彼此间的写冲突。标准日志记录器具有这一性质，用户定制的日志记录器也应该满足这一性质。 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:1","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"1.2 基于Logger自定义 官方的预置实现是基于Logger类型的，我们也可以基于Logger类型自己进行实现 Logger类型表示一个活动状态的记录日志的对象，它会生成一行行的输出写入一个io.Writer接口。每一条日志操作会调用一次io.Writer接口的Write方法。Logger类型的对象可以被多个线程安全的同时使用，它会保证对io.Writer接口的顺序访问。 type Logger struct { // contains filtered or unexported fields } Logger类型的方法就是官方实现的那些函数 func (l *Logger) Fatal(v ...interface{}) func (l *Logger) Fatalf(format string, v ...interface{}) func (l *Logger) Fatalln(v ...interface{}) func (l *Logger) Flags() int func (l *Logger) Output(calldepth int, s string) error func (l *Logger) Panic(v ...interface{}) func (l *Logger) Panicf(format string, v ...interface{}) func (l *Logger) Panicln(v ...interface{}) func (l *Logger) Prefix() string func (l *Logger) Print(v ...interface{}) func (l *Logger) Printf(format string, v ...interface{}) func (l *Logger) Println(v ...interface{}) func (l *Logger) SetFlags(flag int) func (l *Logger) SetPrefix(prefix string) 有区别的是，还有一个 New 函数用来创建一个 Logger，其中的参数 out 用于设置日志信息写入的目的地，prefix 设置前缀，flag 设置选项。 func New(out io.Writer, prefix string, flag int) *Logger 一个简单的使用示例如下 var buf bytes.Buffer logger := log.New(\u0026buf, \"logger: \", log.Lshortfile) logger.Print(\"Hello, log file!\") fmt.Print(\u0026buf) // Output logger: example_test.go:16: Hello, log file! 一般情况下，我们需要区分不同的日志级别：Info、Warning 和 Error，这里有一个参考实现 // 这个示例程序展示如何创建定制的日志记录器 package main import ( \"io\" \"io/ioutil\" \"log\" \"os\" ) var ( Trace *log.Logger // 记录所有日志 Info *log.Logger // 重要的信息 Warning *log.Logger // 需要注意的信息 Error *log.Logger // 非常严重的问题 ) func init() { file, err := os.OpenFile(\"errors.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(\"Failed to open error log file:\", err) } Trace = log.New(ioutil.Discard, \"TRACE: \", log.Ldate|log.Ltime|log.Lshortfile) Info = log.New(os.Stdout, \"INFO: \", log.Ldate|log.Ltime|log.Lshortfile) Warning = log.New(os.Stdout, \"WARNING: \", log.Ldate|log.Ltime|log.Lshortfile) Error = log.New(io.MultiWriter(file, os.Stderr), \"ERROR: \", log.Ldate|log.Ltime|log.Lshortfile) } func main() { Trace.Println(\"I have something standard to say\") Info.Println(\"Special Information\") Warning.Println(\"There is something you need to know about\") Error.Println(\"Something has failed\") } ------------------------------------ INFO: 2019/04/09 14:37:11 TestCustomLog.go:44: Special Information ERROR: 2019/04/09 14:37:11 TestCustomLog.go:46: Something has failed WARNING: 2019/04/09 14:37:11 TestCustomLog.go:45: There is something you need to know about 这里写入的目的地为 ioutil.Discard，这是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情并且始终成功返回。 OpenFile几个选项说明如下 O_CREATE // 如果不存在将创建一个新文件 O_WRONLY // 只写模式打开文件 O_APPEND // 写操作时将数据附加到文件尾部 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:1:2","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"2. 第三方log库 比较流行且近期还在更新的日志库有 logrus、zap、oklog、zerolog 可以考虑选择 JSON 格式的日志，参考 最佳日志实践（v2.0） 一文 关于性能可以参考 Go零消耗debug log技巧，使用官方模块在生产环境中存在性能瓶颈 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:2:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"3.参考 [1] 合肥懒皮，简书，Golang log日志，2019.04.09 [2] Go语言标准库文档 ","date":"2020-06-07","objectID":"/2020/golang-log-system/:3:0","tags":["Go实战"],"title":"Golang日志系统","uri":"/2020/golang-log-system/"},{"categories":["Golang学习之路"],"content":"上篇文章基于 Cookie + Session 实现了简单的用户认证功能，用户认证之后，就可以创建群组和主题了，本篇介绍如何创建群组和主题，并将其渲染到前端页面。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1. 群组的创建和浏览 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.1 处理器方法 在 handlers 目录下新增 thread.go 编写群组创建与获取方法： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // GET /threads/new // 创建群组页面 func NewThread(writer http.ResponseWriter, request *http.Request) { _, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { generateHTML(writer, nil, \"layout\", \"auth.navbar\", \"new.thread\") } } // POST /thread/create // 执行群组创建逻辑 func CreateThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { err = request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user, err := sess.User() if err != nil { fmt.Println(\"Cannot get user from session\") } topic := request.PostFormValue(\"topic\") if _, err := user.CreateThread(topic); err != nil { fmt.Println(\"Cannot create thread\") } http.Redirect(writer, request, \"/\", 302) } } // GET /thread/read // 通过 ID 渲染指定群组页面 func ReadThread(writer http.ResponseWriter, request *http.Request) { vals := request.URL.Query() uuid := vals.Get(\"id\") thread, err := models.ThreadByUUID(uuid) if err != nil { fmt.Println(\"Cannot read thread\") } else { _, err := session(writer, request) if err != nil { generateHTML(writer, \u0026thread, \"layout\", \"navbar\", \"thread\") } else { generateHTML(writer, \u0026thread, \"layout\", \"auth.navbar\", \"auth.thread\") } } } 其中定义了三个方法，分别用于渲染群组创建表单页面、处理提交表单执行群组创建逻辑、以及根据指定 ID 渲染对应群组页面。前两个方法需要认证后才能访问，否则将用户重定向到登录页，群组详情页不需要认证即可访问，不过会根据是否认证返回不同的视图模板。 在这里，仍然通过辅助函数 session 判断用户是否认证，其他的业务逻辑也都非常简单，无非是获取表单输入、查询数据库、写入数据库、返回响应视图等操作，后面我们会在介绍处理 HTTP 请求时详细解释其中的细节，这里，我们先了解下全貌即可。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.2 视图模板 然后我们需要创建几个新的视图模板，在 views 目录下 new.thread.html 来编写创建群组表单： {{ define \"content\" }} \u003cform role=\"form\" action=\"/thread/create\" method=\"post\"\u003e \u003cdiv class=\"lead\"\u003eStart a new thread with the following topic\u003c/div\u003e \u003cdiv class=\"form-group\"\u003e \u003ctextarea class=\"form-control\" name=\"topic\" id=\"topic\" placeholder=\"Thread topic here\" rows=\"4\"\u003e\u003c/textarea\u003e \u003cbr/\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-lg btn-primary pull-right\" type=\"submit\"\u003eStart this thread\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e {{ end }} 然后创建 thread.html 编写未认证情况下渲染的群组详情页视图（其中还包含了对群组主题的遍历和渲染）： {{ define \"content\" }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ range .Posts }} \u003cdiv class=\"panel-body\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment\"\u003e\u003c/i\u003e {{ .Body }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ end }} \u003c/div\u003e {{ end }} 以及 auth.thread.html 编写认证后的群组详情页视图（在未认证视图模板的基础上新增了提交主题的表单区块）： {{ define \"content\" }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ range .Posts }} \u003cdiv class=\"panel-body\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment\"\u003e\u003c/i\u003e {{ .Body }}\u003c/span\u003e \u003cdiv class=\"pull-right\"\u003e {{ .User.Name }} - {{ .CreatedAtDate }} \u003c/div\u003e \u003c/div\u003e {{ end }} \u003c/div\u003e \u003cdiv class=\"panel panel-info\"\u003e \u003cdiv class=\"panel-body\"\u003e \u003cform role=\"form\" action=\"/thread/post\" method=\"post\"\u003e \u003cdiv class=\"form-group\"\u003e \u003ctextarea class=\"form-control\" name=\"body\" id=\"body\" placeholder=\"Write your reply here\" rows=\"3\"\u003e\u003c/textarea\u003e \u003cinput type=\"hidden\" name=\"uuid\" value=\"{{ .Uuid }}\"\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-primary pull-right\" type=\"submit\"\u003eReply\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.3 注册路由 最后在 routes/routes.go 中注册群组相关路由： var webRoutes = WebRoutes{ ... // 其他路由 { \"newThread\", \"GET\", \"/thread/new\", handlers.NewThread, }, { \"createThread\", \"POST\", \"/thread/create\", handlers.CreateThread, }, { \"readThread\", \"GET\", \"/thread/read\", handlers.ReadThread, }, } ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"1.4 测试群组创建和浏览 这样，我们就完成了在线论坛项目群组创建和浏览的所有相关路由、处理器、视图编码，重新启动 HTTP 服务器，就可以在首页点击「Start a thread」链接创建新的群组了： 如果没有登录，会先跳转到登录页面，登录之后再次点击该链接就可以进入群组创建页面： 我们在输入框中输入群组主题「Golang」并点击右下角提交按钮，就可以成功创建一个新的群组并在首页看到了： ！然后，我们可以点击该群组的「Read more」链接进入群组详情页： 目前还没有任何主题，接下来，我们来编写创建主题的后端处理器方法和路由实现。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:1:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2. 创建新主题 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.1 处理器方法 我们在 handlers 目录下新增 post.go 来存放主题相关处理器方法： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // POST /thread/post // 在指定群组下创建新主题 func PostThread(writer http.ResponseWriter, request *http.Request) { sess, err := session(writer, request) if err != nil { http.Redirect(writer, request, \"/login\", 302) } else { err = request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user, err := sess.User() if err != nil { fmt.Println(\"Cannot get user from session\") } body := request.PostFormValue(\"body\") uuid := request.PostFormValue(\"uuid\") thread, err := models.ThreadByUUID(uuid) if err != nil { fmt.Println(\"Cannot read thread\") } if _, err := user.CreatePost(thread, body); err != nil { fmt.Println(\"Cannot create post\") } url := fmt.Sprint(\"/thread/read?id=\", uuid) http.Redirect(writer, request, url, 302) } } 我们只定义了一个创建主题的处理器方法，在该处理器方法中，仍然会验证用户是否已认证，只有认证用户才能创建主题，我们最后会调用 user.CreatePost 方法根据群组 ID、用户 ID 和主题内容创建新的主题记录，保存成功后，会返回创建该主题的群组详情页，并将与该群组关联的所有主题渲染出来。关于数据库和视图模板引擎的语法细节，后面我们会在对应的独立教程中详细介绍。 ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.2 注册路由 由于主题没有独立的视图模板，所以我们只需要在路由文件中注册创建主题对应的路由就可以了： { \"postThread\", \"POST\", \"/thread/post\", handlers.PostThread, }, ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"2.3 测试主题创建 再次重启 HTTP 服务器，就可以在之前的群组详情页创建新主题了： 点击「REPLY」按钮提交，页面会刷新并渲染主题内容： 回到论坛首页，你可以看到每个群组下的主题数目： ","date":"2020-06-05","objectID":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛5-创建群组和主题功能实现","uri":"/2020/development-of-online-forum-based-on-golang-5-create-thread-and-post/"},{"categories":["Golang学习之路"],"content":"上篇演示了首页路由、处理器、视图模板的实现，接着就要实现群组、主题的增删查改，不过，需要在认证后才能执行这些操作，所以本篇介绍如何实现用户认证相关功能。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"1. 全局辅助函数 我们先在 handlers 目录下创建一个 helper.go 文件，用于定义一些全局辅助函数（主要用在处理器中）： package handlers import ( \"errors\" \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"html/template\" \"net/http\" ) // 通过 Cookie 判断用户是否已登录 func session(writer http.ResponseWriter, request *http.Request) (sess models.Session, err error) { cookie, err := request.Cookie(\"_cookie\") if err == nil { sess = models.Session{Uuid: cookie.Value} if ok, _ := sess.Check(); !ok { err = errors.New(\"Invalid session\") } } return } // 解析 HTML 模板（应对需要传入多个模板文件的情况，避免重复编写模板代码） func parseTemplateFiles(filenames ...string) (t *template.Template) { var files []string t = template.New(\"layout\") for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s.html\", file)) } t = template.Must(t.ParseFiles(files...)) return } // 生成响应 HTML func generateHTML(writer http.ResponseWriter, data interface{}, filenames ...string) { var files []string for _, file := range filenames { files = append(files, fmt.Sprintf(\"views/%s.html\", file)) } templates := template.Must(template.ParseFiles(files...)) templates.ExecuteTemplate(writer, \"layout\", data) } // 返回版本号 func Version() string { return \"0.1\" } 目前提供了版本信息，判断用户是否登录，HTML 模板的解析与生成等逻辑，我们将 HTML 模板解析与生成逻辑提取出来，主要是为了避免重复编写类似的模板代码，比如现在，我们可以将 handlers/index.go 中的 Index 方法改写如下： func Index(w http.ResponseWriter, r *http.Request) { threads, err := models.Threads(); if err == nil { generateHTML(w, threads, \"layout\", \"navbar\", \"index\") } } 是不是看起来简单多了，更重要的是提高了代码的复用性。 在 session 函数中，通过从请求中获取指定 Cookie 字段里面存放的 Session ID，然后从 Session 存储器（这里存储驱动是数据库）查询对应 Session 是否存在来判断用户是否已认证，如果已认证则返回的 sess 不为空。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2. 用户认证相关处理器 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.1 编写处理器代码 接下来，在 handlers 目录下创建一个 auth.go 来存放用户认证相关处理器： package handlers import ( \"fmt\" \"github.com/xueyuanjun/chitchat/models\" \"net/http\" ) // GET /login // 登录页面 func Login(writer http.ResponseWriter, request *http.Request) { t := parseTemplateFiles(\"auth.layout\", \"navbar\", \"login\") t.Execute(writer, nil) } // GET /signup // 注册页面 func Signup(writer http.ResponseWriter, request *http.Request) { generateHTML(writer, nil, \"auth.layout\", \"navbar\", \"signup\") } // POST /signup // 注册新用户 func SignupAccount(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() if err != nil { fmt.Println(\"Cannot parse form\") } user := models.User{ Name: request.PostFormValue(\"name\"), Email: request.PostFormValue(\"email\"), Password: request.PostFormValue(\"password\"), } if err := user.Create(); err != nil { fmt.Println(\"Cannot create user\") } http.Redirect(writer, request, \"/login\", 302) } // POST /authenticate // 通过邮箱和密码字段对用户进行认证 func Authenticate(writer http.ResponseWriter, request *http.Request) { err := request.ParseForm() user, err := models.UserByEmail(request.PostFormValue(\"email\")) if err != nil { fmt.Println(\"Cannot find user\") } if user.Password == models.Encrypt(request.PostFormValue(\"password\")) { session, err := user.CreateSession() if err != nil { fmt.Println(\"Cannot create session\") } cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) http.Redirect(writer, request, \"/\", 302) } else { http.Redirect(writer, request, \"/login\", 302) } } // GET /logout // 用户退出 func Logout(writer http.ResponseWriter, request *http.Request) { cookie, err := request.Cookie(\"_cookie\") if err != http.ErrNoCookie { fmt.Println(\"Failed to get cookie\") session := models.Session{Uuid: cookie.Value} session.DeleteByUUID() } http.Redirect(writer, request, \"/\", 302) } 上述代码中定义了用户注册、登录、退出相关业务逻辑，非常简单，和 Laravel 认证脚手架生成的默认认证相关控制器非常相似。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.2 用户注册 用户注册逻辑比较简单，无非是填写注册表单（Signup 处理器方法），提交注册按钮将用户信息保存到数据库（SignupAccount 处理器方法）。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.3 用户登录 接下来，服务端会将用户重定向到登录页面（Login 处理器方法），用户填写登录表单后，就可以通过 Authenticate 处理器方法执行认证操作。 用户认证是基于 Cookie + Session 实现的，Session 的数据结构如下所示： type Session struct { Id int Uuid string Email string UserId int CreatedAt time.Time } 通过 Uuid 字段可以唯一标识这个 Session，因此可以看作是对外可见的全局 Session ID，在客户端 Cookie 存储的 Session ID 也是这个 Uuid。当用户认证成功之后，就会创建 Session，有了 Session 之后，就可以创建 Cookie 并写到响应中： cookie := http.Cookie{ Name: \"_cookie\", Value: session.Uuid, HttpOnly: true, } http.SetCookie(writer, \u0026cookie) 这样，下次用户访问在线论坛页面就会在请求头中带上包含 Session ID 的 Cookie，服务端通过解析这个 Uuid 并查询 Session 存储器（这里存储驱动是数据库）判断该用户 Session 是否存在，如果存在则用户认证通过，也就是前面辅助函数 session 所做的事情。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"2.3 用户退出 上述 Cookie 未设置过期时间，所以生命周期和 Session 一致，当浏览器关闭时，Cookie 就自动删除，下次打开浏览器需要重新认证。 最后用户退出处理器方法 Logout 方法则是方便用户主动退出，当用户点击退出按钮，可以执行该处理器方法销毁当前用户 Session 和认证 Cookie，并将用户重定向到首页。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:2:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"3. 用户认证相关视图模板 定义好认证处理器后，我们来编写与认证相关的视图模板，主要是登录页面和注册页面，在 views 目录下新增 login.html 编写登录页面： {{ define \"content\" }} \u003cform class=\"form-signin center\" role=\"form\" action=\"/authenticate\" method=\"post\"\u003e \u003ch2 class=\"form-signin-heading\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e ChitChat \u003c/i\u003e \u003c/h2\u003e \u003cinput type=\"email\" name=\"email\" class=\"form-control\" placeholder=\"Email address\" required autofocus\u003e \u003cinput type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required\u003e \u003cbr/\u003e \u003cbutton class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"\u003eSign in\u003c/button\u003e \u003cbr/\u003e \u003ca class=\"lead pull-right\" href=\"/signup\"\u003eSign up\u003c/a\u003e \u003c/form\u003e {{ end }} 然后创建 signup.html 编写注册页面： {{ define \"content\" }} \u003cform class=\"form-signin\" role=\"form\" action=\"/signup_account\" method=\"post\"\u003e \u003ch2 class=\"form-signin-heading\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e ChitChat \u003c/i\u003e \u003c/h2\u003e \u003cdiv class=\"lead\"\u003eSign up for an account below\u003c/div\u003e \u003cinput id=\"name\" type=\"text\" name=\"name\" class=\"form-control\" placeholder=\"Name\" required autofocus\u003e \u003cinput type=\"email\" name=\"email\" class=\"form-control\" placeholder=\"Email address\" required\u003e \u003cinput type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required\u003e \u003cbutton class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"\u003eSign up\u003c/button\u003e \u003c/form\u003e {{ end }} 此外，我们还为登录和注册页面定义了单独的布局模板 auth.layout.html： {{ define \"layout\" }} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eChitChat\u003c/title\u003e \u003clink href=\"/static/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/font-awesome.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/login.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"container\"\u003e {{ template \"content\" . }} \u003c/div\u003e \u003c!-- /container --\u003e \u003cscript src=\"/static/js/jquery-2.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/static/js/bootstrap.min.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e {{ end }} 以上视图模板已经在认证处理器方法中引用。 ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"4. 注册用户认证路由 最后，我们需要在 routes/routes.go 中注册用户认证相关路由： // 定义所有 Web 路由 var webRoutes = WebRoutes{ ... // 其他路由 { \"signup\", \"GET\", \"/signup\", handlers.Signup, }, { \"signupAccount\", \"POST\", \"/signup_account\", handlers.SignupAccount, }, { \"login\", \"GET\", \"/login\", handlers.Login, }, { \"auth\", \"POST\", \"/authenticate\", handlers.Authenticate, }, { \"logout\", \"GET\", \"/logout\", handlers.Logout, }, } ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"5. 测试用户认证功能 这样一来，我们就可以重启应用并访问用户注册页面 http://localhost:8080/signup 进行注册了： 注册成功后，页面会跳转到登录页面 http://localhost:8080/login： 输入刚才填写的注册邮箱和密码，点击「SIGN IN」按钮登录成功后，页面跳转到首页。 我们还没有对首页做额外的认证判断和处理，所以此时显示的页面效果和之前一样，为了区别用户认证与未认证状态，我们可以基于认证状态渲染不同的导航模板，对于认证用户，渲染 auth.navbar 模板，对于未认证用户，还是保持和之前一样，为此，我们需要在 views 目录下新增 auth.navbar.html 视图： {{ define \"navbar\" }} \u003cdiv class=\"navbar navbar-default navbar-static-top\" role=\"navigation\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header\"\u003e \u003cbutton type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"\u003e \u003cspan class=\"sr-only\"\u003eToggle navigation\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003c/button\u003e \u003ca class=\"navbar-brand\" href=\"/\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e\u003c/i\u003e ChitChat \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"navbar-collapse collapse\"\u003e \u003cul class=\"nav navbar-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"nav navbar-nav navbar-right\"\u003e \u003cli\u003e\u003ca href=\"/logout\"\u003eLogout\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 同时还要修改 handlers.Index 处理器方法实现： func Index(writer http.ResponseWriter, request *http.Request) { threads, err := models.Threads(); if err == nil { _, err := session(writer, request) if err != nil { generateHTML(writer, threads, \"layout\", \"navbar\", \"index\") } else { generateHTML(writer, threads, \"layout\", \"auth.navbar\", \"index\") } } } 再次重启应用，刷新首页，导航条的展示效果就不一样了： 此时显示的是「Logout」链接，点击即可退出应用： ","date":"2020-06-04","objectID":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/:5:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛4-通过Cookie和Session实现用户认证","uri":"/2020/development-of-online-forum-based-on-golang-4-user-authentication/"},{"categories":["Golang学习之路"],"content":"关于 Cookie 的使用是 Web 编程中的重要一部分，本篇介绍 Cookie 的基本知识和 Golang 中使用的方法。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:0:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"1. 使用Cookie来管理状态 HTTP 是无状态协议，不记录之前发生过的请求和响应，也因此无法根据历史状态信息处理当前请求。但假设我们正在浏览淘宝，然后在首页进行了登录，点击并跳转到商品页面时，因为 HTTP 的无状态特性，就需要重新进行登录，这带来了诸多不便。 不可否认，无状态协议有它的优点，由于不必保存状态，减少了服务器的 CPU 及内存资源消耗，同时也因为协议足够简单，才可以用到各种场景中。那么如何解决逛淘宝这种需要记录历史信息的场景呢，这里就用到 Cookie 技术。 Cookie 技术通过在 HTTP 请求和响应报文中写入 Cookie 信息来控制客户端的状态。首先，服务端在发送的响应报文内添加一个叫做 Set-Cookie 的首部字段信息，客户端接收到后会保存 Cookie。当下次客户端向服务器发送请求时，就会自动在请求报文中加入保存的 Cookie 值。服务器发现客户端发送过来的 Cookie 后，会检查究竟是哪个客户端发来的连接请求，然后对比服务器上的数据，得到之前的状态信息。过程如下图所示（图源为《图解HTTP》） 所以 Cookie 的实质是 HTTP 请求与响应报文中的一个首部字段信息，下面给出一些报文示例： 请求报文（没有 Cookie 信息时的状态） GET /reader/ HTTP/1.1 Host: hackr.jp *首部字段内没有Cookie的相关信息 响应报文（服务器端生成 Cookie 信息） HTTP/1.1 200 OK Date: Thu, 12 Jul 2012 07:12:20 GMT Server: Apache ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞ Content-Type: text/plain; charset=UTF-8 请求报文（自动发送保存的 Cookie 信息） GET /image/ HTTP/1.1 Host: hackr.jp Cookie: sid=1342077140226724 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:1:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2. 关于Cookie的首部字段 关于 Cookie 的相关说明没有被编入标准化 HTTP/1.1 的RFC2516中，下面介绍的是使用最广泛的 Cookie 标准。 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2.1 Set-Cookie Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒ path=/; domain=.hackr.jp; 当服务器准备开始管理客户端的状态时，会事先告知各种信息。下面的表格列举了Set-Cookie 的字段值。 属性 说明 NAME=VALUE 赋予Cookie的名称和其值（必须项） expires=DATE Cookie的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为Cookie适用对象的域名（若不指定则默认为创建Cookie的服务器域名） Secure 仅在HTTPS安全通信时才会发送Cookie HttpOnly 加以限制，使Cookie不能被JavaScript脚本访问 expires属性：有两种方法来设置过期时间：一种是直接设置 Expires 字段，一种是设置 MaxAge 字段。前者表示到期的具体时间点，后者表示 Cookie 的有效时长（单位是秒）。这并不是 Go 语言的设计，而是不同浏览器的混乱标准使然，比如虽然 HTTP/1.1 有意废弃 Expires，不过 IE 6、7、8 却不支持 MaxAge 字段。通常，考虑到默认时区问题，本地时间不可靠，推荐通过 MaxAge 字段设置 Cookie 过期时间，不过对于 Web 应用而言，通常不设置过期时间，让 Cookie 随着浏览器关闭而失效即可。 domain属性：domain 属性指定的域名可做到与结尾匹配一致，比如，当指定 example.com 后，除 example.com 本身外，www.example.com 或 www2.example.com 等都可以发送 Cookie，所以，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全 secure属性：指定 secure 属性的方法为 Set-Cookie: name=value; secure HttpOnly属性：指定 HttpOnly 属性的方法为 Set-Cookie: name=value; HttpOnly ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:1","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"2.2 Cookie Cookie: status=enable 在请求报文中添加该字段后，就相当于告诉服务器客户端想要获得 HTTP 状态管理支持。接收到多个Cookie时，同样可以以多个Cookie形式发送。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:2:2","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"3. Session 管理 某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见，为达到这个目标，需要添加认证功能。HTTP/1.1 实用的认证包括 BASIC认证、DIGEST认证、SSL客户端认证、FormBase认证等，由于使用上的便利性和安全性问题，前两种几乎不适用，SSL客户端认证则由于导入及费用问题未得到普及，目前常用的是最后一种：基于表单的认证。 基于表单的认证方法并不是在HTTP协议中定义的，而是由客户端通过表单向服务器提交登录信息，然后由服务器安装自定义的实现方式进行验证，不同的应用使用的验证方式多有不同，但多数情况下，是基于用户输入的用户ID（通常是任意字符串或邮件地址）和密码等登录信息进行认证。 鉴于 HTTP 是无状态协议，之前已认证成功额用户状态无法保留，因此一般使用 Cookie 来管理 Session(会话)。 如上图所示，基本的步骤为 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。 需要注意，上述介绍并不是唯一的实现方式，实际上，不仅基于表单认证的登录信息及认证过程没有标准化，服务端如何保持密码等登录信息也没有标准化。通常，一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:3:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4. Go中Cookie的设置与读取 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4.1 设置Cookie Go语言中通过 net/http 包中的 SetCookie 来设置 Cookie： http.SetCookie(w ResponseWriter, cookie *Cookie) w 表示需要写入的 response，cookie 是一个 struct，让我们来看看对象是怎样的： type Cookie str、uct { Name string Value string Path string Domain string Expires time.Time RawExpires string // MaxAge=0 意味着没有指定 Max-Age 的值 // MaxAge\u003c0 意味着现在就删除 Cookie，等价于 Max-Age=0 // MaxAge\u003e0 意味着 Max-Age 属性存在并以秒为单位存在 MaxAge int Secure bool HttpOnly bool Raw string Unparsed []string // 未解析的 attribute-value 属性位对 } 下面来看一个如何设置 Cookie 的例子： expiration := time.Now() expiration := expiration.AddDate(1, 0, 0) cookie := http.Cookie{ Name: \"username\", Value: \"zuolan\", Expires: expiration } http.SetCookie(writer, \u0026Cookie) ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:1","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"4.2 读取 Cookie 上面的例子演示了如何设置 Cookie 数据，这里演示如何读取 Cookie： cookie, _ := r.Cookie(\"username\") fmt.Fprint(w, cookie) 还有另外一种读取方式： for _, cookie := range r.Cookies() { fmt.Fprint(w, cookie.Name) } 可以看到通过 request 获取 Cookie 非常方便。 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:4:2","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"参考 上野宣[日]，图解HTTP，人民邮电出版社，2014 学院君，在 Go 语言中设置、读取和删除 HTTP Cookie，2020 ","date":"2020-06-01","objectID":"/2020/golang-set-and-use-cookie/:5:0","tags":["Go实战"],"title":"Golang设置与使用cookie","uri":"/2020/golang-set-and-use-cookie/"},{"categories":["Golang学习之路"],"content":"模板就是在写动态页面时不变的部分，服务端程序渲染可变部分生成动态网页，Go 语言提供了 html/template 包来支持模板渲染。 ","date":"2020-05-29","objectID":"/2020/golang-template/:0:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1. 基本语法 模板的基本语法来自于 text/template 包，与大多数语言一样，用 {{ 和 }} 来做标识，{{ }} 里可以是表达式，也可以是变量 ","date":"2020-05-29","objectID":"/2020/golang-template/:1:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.1 变量 模板中的变量通过{{.}} 来访问。Golang渲染template的时候，可以在模板文件中读取变量内的值并渲染到模板里。有两个常用的传入类型。一是struct，在模板内可以读取该struct的内容。二是map[string]interface{}，在模板内可以使用key来进行渲染。 以结构体为例，假设初始化了一个结构体 User type User struct { UserId int Username string Age uint Sex string } user := User{1, \"Steven\", 35, \"男\"} 模板获取数据的方式如下 {{.}}{{.Username}}{{.UserId}}{{.Age}}{{.Sex}} 那么渲染后的模板内容如下 {1 Steven 35 男}Steven135男 也可以在模板中定义变量，初始化后就可以进行调用，如下所示 {{$MyUserName := \"StevenWang\"}} {{$MyUserName}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:1","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.2 逻辑判断 Golang 模板支持 if 条件判断，当前支持最简单的 bool 类型和 string 类型，定义方式如下 {{if .confition}} {{end}} 当.condition是bool类型时，值为true表示执行。当.condition是string类型时，值非空表示执行。加入 else 时，形式如下 {{if .confition}} {{else}} {{end}} 此模板也支持if…else if嵌套，定义方式如下所示 {{if .confition}} {{else if .confition}} {{end}} Golang的模板提供了一些内置的模板函数来执行逻辑判断，下面列举目前常用的一些内置模板函数 函数语法 函数作用 {{if not .condition}} {{end}} not 非 {{if and .condition1 .condition2}} {{end}} and 与 {{if or .condition1 .condition2}} {{end}} or 或 {{if eq .var1 .var2}} {{end}} eq 等于 {{if ne .var1 .var2}} {{end}} ne 不等于 {{if lt .var1 .var2}} {{end}} lt 小于 {{if le .var1 .var2}}{{end}} le 小于等于 {{if gt .var1 .var2}}{{end}} gt 大于 {{if ge .var1 .var2}}{{end}} ge 大于等于 假设在 Go 程序中定义了一个map，如下 locals := make(map[string]interface{}) locals[\"username1\"] = \"Steven\" locals[\"username2\"] = \"Daniel\" 在模板文件中进行逻辑判断如下 {{if eq .username .user}} OK:账号名称一致 {{else if ne .username .user}} Err:账号名称不一致 {{end}} 逻辑判断也可以使用 with 作为关键词 {{with .condition}} {{end}} 或者 {{with .condition}} {{else}} {{end}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:2","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.3 循环遍历 Golang 的模板支持 range 循环来遍历 map、slice中的内容，语法如下 {{range $index, $value := .slice}} {{end}} 在这个range循环内，遍历数据通过$index和 $value来实现。还有一种遍历方式，语法格式如下所示 {{range .slice}} {{end}} 这种方式无法访问到$index和$key的值，需要通过{{.}}来访问对应的$value。这种情况下，在循环体内，外部变量需要使用{{$.}}来访问。 模板文件的示例代码如下 {{range $index, $value := .filelist}} \u003cfigure\u003e \u003ca href=\"/html/upload/{{$value}}\"\u003e\u003cimg src=\"/html/upload/{{$value}}\"/\u003e\u003c/a\u003e \u003cfigcaption\u003e {{$value}} \u003cbr/\u003e \u003ca href=\"/delete?id={{$value}}\"\u003e[删除]\u003c/a\u003e {{$.username}}上传 \u003c/figcaption\u003e \u003c/figure\u003e {{end}} 循环也有 else 语句，如果作为循环条件的数组、切片、映射或通道长度为0，就执行 else 后的语句。 {{range .slice}} {{else}} {{end}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:3","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"1.4 模板嵌套 在编写模板的时候，经常需要将公用的模板进行整合，比如每一个页面都有导航栏和页脚，通常的做法是将其编写为一个单独的模块，让所有的页面进行导入，这样就不用重复编写了。 任何网页都有一个主模板，然后可以在主模板内嵌入子模板来实现模块共享。当模板想要引入子模板时，通常使用如下语句 {{template \"navbar\"}} 这样就会载入名为 navbar 的子模版，同时，我们需要定义 navbar 子模版的实现 {{define \"navbar\"}} {{end}} 在定义中间的内容最终会替代源文件中的 {{template “navbar”}} 这一条语句 如果想要子模板获得父模板的变量，使用如下方法 {{template \"navbar\" .}} ","date":"2020-05-29","objectID":"/2020/golang-template/:1:4","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"2. 模板函数 上面的语法一般情况都是定义在前端文件中的，要对模板进行处理，html/template 还提供了一系列函数。 一个简单的例子如下 import \"text/template\" ... t, err := template.New(\"foo\").Parse(`{{define\"T\"}}Hello, {{.}}!{{end}}`) err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\") 涉及到的几个函数分别是 New，Parse 和 ExecuteTemplate，解释如下 // 创建一个名为name的模板 func New(name string) *Template // Parse方法将字符串text解析为模板 func (t *Template) Parse(src string) (*Template, error) // 将解析好的模板应用到data上，使用名为name的t关联的模板产生输出。 func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error 所以 New 和 Parse 创建一个模板并将字符串解析到该模板，但实际使用时模板文件通常是单独的，这时一般使用 Must 和 ParseFiles 函数。 ParseFiles方法解析filenames指定的文件里的模板定义并将解析结果与t关联。如果发生错误，会停止解析并返回nil，否则返回(t, nil)。至少要提供一个文件。 func (t *Template) ParseFiles(filenames ...string) (*Template, error) 可以看到 ParseFiles 返回 (*Template, error)，Must 函数正好用来封装这种返回形式的函数 func Must(t *Template, err error) *Template 它会在 err 非 nil 时 panic，一般用于变量初始化 var t = template.Must(template.New(\"name\").Parse(\"html\")) 另外，ExecuteTemplate 将输出指定到名为 name 的模板上，但还有一种简单形式如下 func (t *Template) Execute(wr io.Writer, data interface{}) error Execute方法将解析好的模板应用到data上，并将输出写入wr，唯一的区别就是没有绑定模板。 ","date":"2020-05-29","objectID":"/2020/golang-template/:2:0","tags":["Go实战"],"title":"Golang模板","uri":"/2020/golang-template/"},{"categories":["Golang学习之路"],"content":"本文介绍 gorilla/mux 包的使用。 我们已知 Go 标准库 net/http 提供的默认路由是 DefaultServeMux，虽然简单易上手，但存在很多不足，比如 不支持参数设定，例如 /user/:uid 这种泛类型匹配； 对 REST 风格接口支持不友好，无法限制访问路由的方法； 对于拥有很多路由规则的应用，编写大量路由规则非常繁琐。 为此，我们可以使用第三方库 gorilla/mux 提供的更加强大的路由处理器（mux 代表 HTTP request multiplexer，即 HTTP 请求多路复用器），和 http.ServeMux 实现原理一样，gorilla/mux 提供的路由器实现类 mux.Router 也会匹配用户请求与系统注册的路由规则，然后将用户请求转发过去。 type Router struct { // Configurable Handler to be used when no route matches. NotFoundHandler http.Handler // Configurable Handler to be used when the request method does not match the route. MethodNotAllowedHandler http.Handler // Routes to be matched, in order. routes []*Route // Routes by name for URL building. namedRoutes map[string]*Route // If true, do not clear the request context after handling the request. // Deprecated: No effect, since the context is stored on the request itself. KeepContext bool // Slice of middlewares to be called after a match is found middlewares []middleware // configuration shared with `Route` routeConf } mux.Router 主要具备以下特性： 实现了 http.Handler 接口，所以和 http.ServeMux 完全兼容； 可以基于 URL 主机、路径、前缀、scheme、请求头、请求参数、请求方法进行路由匹配； URL 主机、路径、查询字符串支持可选的正则匹配； 支持构建或反转已注册的 URL 主机，以便维护对资源的引用； 支持路由嵌套，以便不同路由可以共享通用条件，比如主机、路径前缀等。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:0:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"1. 使用入门 运行如下命令进行安装 $ go get -u github.com/gorilla/mux 一个简单的示例如下 func main() { r := mux.NewRouter() r.HandleFunc(\"/\", HomeHandler) r.HandleFunc(\"/products\", ProductsHandler) r.HandleFunc(\"/articles\", ArticlesHandler) http.ListenAndServe(\":8080\", r) } main 函数中的第一行显式初始化了 mux.Router 作为路由器，然后在这个路由器中注册路由规则，最后将这个路由器传入 http.ListenAndServe 方法，整个调用过程和之前并无二致，因为mux.Router 也实现了 Handler 接口。 路径中可以包含变量。变量的定义形式为 {name} 或 {name:pattern}，只能是小写字母，不支持其它字符，同时，name 可以是正则表达式，如下面的例子所示 r := mux.NewRouter() r.HandleFunc(\"/products/{key}\", ProductHandler) r.HandleFunc(\"/articles/{category}/\", ArticlesCategoryHandler) r.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler) 相应地，在闭包处理函数中，我们使用 mux.Vars() 解析路由参数： func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) w.WriteHeader(http.StatusOK) fmt.Fprintf(w, \"Category: %v\\n\", vars[\"category\"]) } ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:1:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2. 路由代码拆分 比较简单的情况下，所有的路由、处理器都放在应用入口文件中，一般是 main.go，但如果项目比较大，甚至仅仅是博客这种级别的项目，就要处理文章、用户、图片等众多资源，所以我们需要针对这种情况进行一定的优化。 优化的办法就是将路由器与控制器分离，为了使代码结构更加清晰明了，我们把服务器、路由器、路由定义、处理器方法全都拆分开。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.1 路由器 我们在项目根目录下新建 routes 目录用来存放路由定义及实现。 首先在 routes 目录下创建 routes.go 存放路由定义，文件内容如下 package routes import \"net/http\" // 定义一个 WebRoute 结构体用于存放单个路由 type WebRoute struct { Name string Method string Pattern string HandlerFunc http.HandlerFunc } // 声明 WebRoutes 切片存放所有 Web 路由 type WebRoutes []WebRoute // 定义所有 Web 路由 var webRoutes = WebRoutes{ } 在这里，我们定义了一个 WebRoute 结构体来表示单个路由，其中包含了路由名称、请求方法、匹配字符串模式、以及对应的处理器方法，路由器可以根据这些配置请求请求分发。 然后定义了一个 WebRoutes 切片来存放所有 WebRoute 类型的路由，最后初始化这个切片为空，表示还没有定义任何路由。 接下来，在 routes 目录下创建 router.go 用来编写路由器实现 package routes import \"github.com/gorilla/mux\" // 返回一个 mux.Router 类型指针，从而可以当作处理器使用 func NewRouter() *mux.Router { // 创建 mux.Router 路由器示例 router := mux.NewRouter().StrictSlash(true) // 遍历 web.go 中定义的所有 webRoutes for _, route := range webRoutes { // 将每个 web 路由应用到路由器 router.Methods(route.Method). Path(route.Pattern). Name(route.Name). Handler(route.HandlerFunc) } return router } StrictSlash 定义斜杠尾随行为，意思是，传入 true 时，如果路由路径是 /path 这种形式，将重定向到 /path/ ，反之亦然。传入 false 时，不会重定向，这两种情况不会看作一种。 Methods，Path，Name，Handler分别用来限定请求方法、匹配字符串模式、路由名和处理器方法。通过这种方式，我们将 routes.go 中定义的所有 Web 路由都应用到了使用 mux.NewRouter 创建的路由器，以便可以处理用户请求的路由匹配和分发。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:1","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.2 服务器 在入口文件 main.go 中使用如下方法启动服务器 package main import ( . \"github.com/shuzang/projectname/routes\" \"log\" \"net/http\" ) func main() { startWebServer(\"8080\") } func startWebServer(port string) { r := NewRouter() http.Handle(\"/\", r) log.Println(\"Starting HTTP service at \" + port) err := http.ListenAndServe(\":\"+port, nil) // Goroutine will block here if err != nil { log.Println(\"An error occured starting HTTP listener at port \" + port) log.Println(\"Error: \" + err.Error()) } } 我们将 Web 服务器启动逻辑封装到 startWebServer 方法中实现，该方法需要传入端口参数。在具体实现时，我们调用了 routes/router.go 中定义的 NewRouter 方法，将其返回值作为处理器传入 http.Handle 方法，最后调用 http.ListenAndServe 启动 Web 服务器并监听传入的端口号。 最后在 main 方法中调用 startWebServer 方法即可。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:2","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"2.3 处理器 上层代码写完后，现在定义处理器方法。在项目根目录下新建 handlers 目录存放处理器方法，这里举 2 个示例，分别定义在 common.go 和 user.go 两个文件中，用来处理通用请求和用户资源。 首先在 common.go 中编写首页请求处理器方法 package handlers import ( \"io\" \"net/http\" ) func Home(w http.ResponseWriter, r *http.Request) { io.WriteString(w, \"Welcome to my site\") } 然后在 user.go 中定义获取指定用户对应处理器方法 package handlers import ( \"github.com/gorilla/mux\" \"io\" \"net/http\" ) func GetUser(w http.ResponseWriter, r *http.Request) { // Get user from DB by id... params := mux.Vars(r) id := params[\"id\"] io.WriteString(w, \"Return user info with id = \" + id) } 这时要记得，routes/routes.go 中的路由切片还是空的，用实现的处理器填充它 var webRoutes = WebRoutes{ WebRoute{ \"Home\", \"GET\", \"/\", handlers.Home, }, WebRoute{ \"User\", \"GET\", \"/user/{id}\", handlers.GetUser, }, } ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:2:3","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3. 路由匹配规则 第一部分的路由匹配规则只是简单介绍，实际上，gorilla/mux 实现的匹配规则非常强大。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.1 常用匹配规则 限定请求方法 r.HandleFunc(\"/books/{title}\", CreateBook).Methods(\"POST\") r.HandleFunc(\"/books/{title}\", ReadBook).Methods(\"GET\") r.HandleFunc(\"/books/{title}\", UpdateBook).Methods(\"PUT\") r.HandleFunc(\"/books/{title}\", DeleteBook).Methods(\"DELETE\") 限定主机名或子域名 r.HandleFunc(\"/books/{title}\", BookHandler).Host(\"www.mybookstore.com\") 限定 Scheme r.HandleFunc(\"/secure\", SecureHandler).Schemes(\"https\") r.HandleFunc(\"/insecure\", InsecureHandler).Schemes(\"http\") 限定前缀和子路由 bookrouter := r.PathPrefix(\"/books\").Subrouter() bookrouter.HandleFunc(\"/\", AllBooks) bookrouter.HandleFunc(\"/{title}\", GetBook) 限定请求参数 r.HandleFunc(\"/request/header\", func(w http.ResponseWriter, r *http.Request) { header := \"X-Requested-With\" fmt.Fprintf(w, \"包含指定请求头[%s=%s]\", header, r.Header[header]) }).Headers(\"X-Requested-With\", \"XMLHttpRequest\") ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:1","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.2 自定义匹配规则 gorilla/mux 路由支持通过 MatcherFunc 方法自定义路由匹配规则，在该方法中，可以获取到请求实例 request，这样我们就可以拿到所有的用户请求信息，并对其进行判断，符合我们预期的请求才能匹配并访问该方法应用到的路由。 比如下面这个示例，我们限定只有来自 https://baidu.com 域名的请求才可以匹配到 /custom/matcher 路由 r.HandleFunc(\"/custom/matcher\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"请求来自指定域名: %s\", r.Referer()) }).MatcherFunc(func(request *http.Request, match *mux.RouteMatch) bool { return request.Referer() == \"https://baidu.com\" }) ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:2","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"3.3 路由命名 通过 Name 方法在路由规则中指定 postRouter := r.PathPrefix(\"/posts\").Subrouter() postRouter.HandleFunc(\"/\", listPosts).Methods(\"GET\").Name(\"posts.index\") postRouter.HandleFunc(\"/create\", createPost).Methods(\"POST\").Name(\"posts.create\") ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:3:3","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"4. 路由中间件 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:4:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"5. 处理静态资源响应 使用默认http包处理静态资源的方法如下 fs := http.FileServer(http.Dir(\"assets/\")) http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs)) 使用 gorilla/mux 时，处理方法很相似 r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 assets := http.FileServer(http.Dir(\"public\")) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) // 应用路由器到 HTTP 服务器 ... 虽然 gorilla/mux 路由器提供了对静态资源的支持，但是通常我们还是会基于 Nginx 来处理静态资源，然后将动态请求转发给 Go HTTP 服务器，因为 Nginx 作为一款强大的反向代理服务器，并发处理静态资源的能力非常强悍，没必要自己去处理这块逻辑。 ","date":"2020-05-29","objectID":"/2020/golang-use-gorilla/mux-package/:5:0","tags":["Go实战"],"title":"Golang使用gorilla、mux包","uri":"/2020/golang-use-gorilla/mux-package/"},{"categories":["Golang学习之路"],"content":"本文介绍 Golang 如何实现 HTTP 服务端及客户端。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:0:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1. HTTP协议客户端实现 Go语言标准库内置了net/http包，涵盖了HTTP客户端和服务端具体的实现方式。内置的net/http包提供了最简洁的HTTP客户端实现方式，无须借助第三方网络通信库，就可以直接使用HTTP中用得最多的GET和POST方式请求数据。 实现HTTP客户端就是客户端通过网络访问向服务端发送请求，服务端发送响应信息，并将相应信息输出到客户端的过程。实现客户端有多种方式，具体如下所示。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.1 使用http.NewRequest()方法 首先创建一个client（客户端）对象，其次创建一个request（请求）对象，最后使用client发送request。 package main import ( \"fmt\" \"net/http\" ) func main() { testHttpNewRequest() } func testHttpNewRequest() { //1.创建一个客户端 client := http.Client{} //2.创建一个请求，请求方式可以是GET或POST request, err := http.NewRequest(\"GET\", \"http://www.baidu.com\", nil) checkErr(err) //3.客户端发送请求 cookName := \u0026http.Cookie{Name: \"username\", Value: \"Steven\"} //添加cookie request.AddCookie(cookName) response, err := client.Do(request) checkErr(err) //设置请求头 request.Header.Set(\"Accept-Lanauage\", \"zh-cn\") defer response.Body.Close() //查看请求头的数据 fmt.Printf(\"Header:%+v\\n\", request.Header) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) //4.操作数据 if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") checkErr(err) } else { fmt.Println(\"网络请求失败\", response.Status) } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果如下 $ go run main.go Header:map[Accept-Lanauage:[zh-cn] Cookie:[username=Steven]] 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:1","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.2 调用client.Get() 方法 这种方法总共两个步骤，先创建一个client（客户端）对象，然后使用client调用Get()方法。 package main import ( \"fmt\" \"net/http\" ) func main() { testClientGet() } func testClientGet() { //1.创建一个客户端 client := http.Client{} //2.通过client请求 response, err := client.Get(\"http://www.baidu.com\") checkErr(err) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") defer response.Body.Close() } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果如下 $ go run main.go 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:2","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.3 使用client.Post()或client.PostForm()方法 这种方法也是两个步骤，先创建一个client（客户端）对象，然后使用client调用Post()或PostForm()方法。其实client的Post()或PostForm()方法，就是对http.NewRequest()的封装。 resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:3","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.4 使用http.Get() 方法 这种方式只有一个步骤，http的Get()方法就是对DefaultClient.Get()的封装。 package main import ( \"fmt\" \"net/http\" ) func main() { testHttpGet() } func testHttpGet() { //获取服务器数据 response, err := http.Get(\"http://www.baidu.com\") checkErr(err) fmt.Printf(\"响应状态码: %v\\n\", response.StatusCode) if response.StatusCode == 200 { fmt.Println(\"网络请求成功\") defer response.Body.Close() checkErr(err) } else { fmt.Println(\"请求失败\", response.Status) } } //检查错误 func checkErr(err error) { defer func() { if ins, ok := recover().(error); ok { fmt.Println(\"程序出现异常: \", ins.Error()) } }() if err != nil { panic(err) } } 运行结果为 $ go run main.go 响应状态码: 200 网络请求成功 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:4","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"1.5 使用http.Post()或http.PostForm()方法 http的Post()函数或PostForm()，就是对DefaultClient.Post()或DefaultClient.PostForm()的封装。这种方法也只需要一个步骤 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:1:5","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2. HTTP协议服务端实现 使用Go语言标准库内置的net/http包，就可以实现一个基本的HTTP服务端。一个基本的HTTP服务器主要应完成如下功能 处理动态请求：处理浏览网站，登录帐户或发布图片等用户传入的请求。 提供静态文件：将JavaScript，CSS和图像等静态文件提供给浏览器，服务于用户。 接受连接请求：HTTP服务器必须监听指定端口从而接收来自网络的连接请求。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:0","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.1 处理动态请求 我们可以使用http.HandleFunc函数注册一个新的 Handler 来处理动态请求。它的第一个参数是请求路径的匹配模式，第二个参数是一个函数类型，表示针对这个请求要执行的功能。下例中针对请求返回一个欢迎访问的提示语。 http.HandleFunc(\"/\", func (w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Welcome to my website!\") }) http.ResponseWriter类型包含了服务器端给客户端的响应数据。服务器端往里面写入了什么内容，浏览器的网页源码就是什么内容。*http.Request包含了客户端发送给服务器端的请求信息（路径、浏览器类型等）。 ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:1","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.2 提供静态文件 使用http.FileServer() 方法提供 Javascript，CSS或图片等静态文件。它的参数是文件系统接口，可以使用http.Dir()来指定文件所在的路径。如果该路径中有index.html文件，则会优先显示html文件，否则会显示文件目录。 fs := http.FileServer(http.Dir(\"static/\")) http.FileServer()的返回值正好是 Handler 类型，也就是可以提供文件访问服务的HTTP处理器。现在，我们只需要将一个URL指向它，期间我们可以使用http.StripPrefix() 去除某些URL前缀，返回值同样是一个 Handler类型 http.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs)) ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:2","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.3 接收连接请求 http.ListenAndServer()函数用来启动HTTP服务器，并且在指定的 IP 地址和端口上监听客户端请求 http.ListenAndServe(\":80\", nil) 函数实现如下，其中第一个参数为监听地址，第二个参数表示一个HTTP处理器 Handler。可以看到，底层调用的是 net/http 包的 ListenAndServe 方法，首先会初始化一个 Server 对象，然后调用该 Server 实例的 ListenAndServe 方法，进而调用 net.Listen(\"tcp\", addr)，也就是基于 TCP 协议创建 Listen Socket，并在传入的IP 地址和端口号上监听请求。 func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } func (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(ln) } 最终我们看到调用了 Server 实例的 Serve(net.Listener) 方法，这个方法里面起了一个 for 循环，在循环体中首先通过 net.Listener（即上一步监听端口中创建的 Listen Socket）实例的 Accept 方法接收客户端请求，接收到请求后根据请求信息创建一个 conn 连接实例，最后单独开了一个 goroutine，把这个请求的数据当做参数扔给这个 conn 去服务： for { rw, err := l.Accept() if err != nil { ... } connCtx := ctx if cc := srv.ConnContext; cc != nil { connCtx = cc(connCtx, rw) if connCtx == nil { panic(\"ConnContext returned nil\") } } tempDelay = 0 c := srv.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return go c.serve(connCtx) } 用户的每一次请求都是在一个新的 goroutine 去服务，相互不影响。客户端请求的具体处理逻辑都是在 c.serve 中完成的。 conn 实例的 serve 方法首先会通过 c.readRequest() 解析请求，然后在 serverHandler{c.server}.ServeHTTP(w, w.req) 的 ServeHTTP 方法中获取相应的 handler：handler := c.server.Handler，也就是我们刚才在调用函数 ListenAndServe 时候的第二个参数。 func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { handler := sh.srv.Handler if handler == nil { handler = DefaultServeMux } if req.RequestURI == \"*\" \u0026\u0026 req.Method == \"OPTIONS\" { handler = globalOptionsHandler{} } handler.ServeHTTP(rw, req) } 我们发现当 handler 为 nil，也就是 ListenAndServe() 的第二个参数为 nil 时，使用了默认的 http.DefaultServeMux，这是 ServeMux的默认实例 var DefaultServeMux = \u0026defaultServeMux var defaultServeMux ServeMux ServeMux的数据结构如下 type ServeMux struct { mu sync.RWMutex. // 由于请求涉及到并发处理，因此这里需要一个锁机制 m map[string]muxEntry // 路由规则字典，存放 URL 路径与处理器的映射关系 es []muxEntry // MuxEntry 切片（按照最长到最短排序） hosts bool // 路由规则中是否包含 host 信息 } 这里，我们需要重点关注的是 muxEntry 结构： type muxEntry struct { h Handler // 处理器具体实现 pattern string // 模式匹配字符串 } 最后我们来看一下 Handler 的定义，这是一个接口： type Handler interface { ServeHTTP(ResponseWriter, *Request) // 路由处理实现方法 } 当请求路径与 pattern 匹配时，就会调用 Handler 的 ServeHTTP 方法来处理请求。 http.HandleFunc(\"/\", sayHelloWorld) 当我们使用一个自定义的处理函数时，如上面的sayHelloWorld，并没有实现 Handler 接口，之所以可以成功添加到路由映射规则，是因为在底层通过 HandlerFunc() 函数将其强制转化为了 HandlerFunc 类型，而 HandlerFunc 类型实现了 ServeHTTP 方法，这样，sayHelloWorld 方法也就变相实现了 Handler 接口 func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } mux.Handle(pattern, HandlerFunc(handler)) } ... type HandlerFunc func(ResponseWriter, *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } 对于 sayHelloWorld 方法来说，它已然变成了 HandlerFunc 类型的函数类型，当我们在其实例上调用 ServeHTTP 方法时，调用的是 sayHelloWorld 方法本身。 前面我们提到，DefaultServeMux 是 ServeMux 的默认实例，当我们在 HandleFunc 中调用 mux.Handle 方法时，实际上是将其路由映射规则保存到 DefaultServeMux 路由处理器的数据结构中： func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern\") } if handler == nil { panic(\"http: nil handler\") } if _, exist := mux.m[pattern]; exist { panic(\"http: multiple registrations for \" + pattern) } if mux.m == nil { mux.m = make(map[string]muxEntry) } e := muxEntry{h: handler, pattern: pattern} mux.m[pattern] = e if pattern[len(pattern)-1] == '/' { mux.es = appendSorted(mux.es, e) } if pattern[0] != '/' { mux.hosts = true } } 还是以 sayHelloWorld 为例，这里的 pattern 字符串对应的是请求路径 /，handler 对应的是 sayHelloWorld 函数。 保存好路由映射规则之后，客户端请求的处理就默认调用ServeMux 实现的 ServeHTTP 方法： func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) { if r.RequestURI == \"*\" { w.Header().Set(\"Connection\", \"close\") w.WriteHeader(StatusBadRequest) return } h, _ := mux.Handler(r) h.ServeHTTP(w, r) } 如上所示，路由处理器接收到请求之后，如果 URL 路径是 *，则关闭连接，否则","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:3","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"2.4 获取客户端提交的数据 前面已经提到，客户端提交的数据全部位于 *http.Request 中，下面的例子虽然做了声明，但没有使用，本节介绍一下如何从 *http.request 中提取想要的数据 http.HandleFunc(\"/\", func (w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Welcome to my website!\") }) Request的部分结构如下 type Request struct { ... // Method指定HTTP方法（GET、POST、PUT等）。对客户端，\"\"代表GET。 Method string // Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。 Form url.Values // PostForm是解析好的POST或PUT的表单数据。 PostForm url.Values ... } 使用ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。 func (r *Request) ParseForm() error 然后使用 FormValue 返回以 key 为健查询 r.Form 得到的第一个值 func (r *Request) FormValue(key string) string PostFormValue则返回key为键查询r.PostForm字段得到的第一个值，用于POST和PUT func (r *Request) PostFormValue(key string) string 当提交的请求数据中有文件时，使用FormFile，可以返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。 func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error) 一个简单的实现如下 func loginActionHandler(w http.ResponseWriter, r *http.Request) { r.ParseForm() if r.Method == \"GET\" \u0026\u0026 r.ParseForm() == nil { username := r.FormValue(\"username\") pwd := r.FormValue(\"password\") if len(username) \u003c 4 || len(username) \u003e 10 { w.Write([]byte(\"用户名不符合规范\")) } if len(pwd) \u003c 6 || len(pwd) \u003e 16 { w.Write([]byte(\"密码不符合规范\")) } http.Redirect(w, r, \"/list\", http.StatusFound) return } else { w.Write([]byte(\"请求方式不对\")) return } w.Write([]byte(\"登录失败\")) } ","date":"2020-05-29","objectID":"/2020/golang-start-http-server/:2:4","tags":["Go实战"],"title":"Golang启动HTTP服务器","uri":"/2020/golang-start-http-server/"},{"categories":["Golang学习之路"],"content":"前两篇分别介绍了整体设计及数据表的创建、模型类的编写，本篇了解如何在服务端处理用户请求，并启动论坛首页。文章转自学院君的教程，略有改动。 用户请求的处理流程如下： 客户端发送请求； 服务端路由器（multiplexer）将请求分发给指定处理器（handler）； 处理器处理请求，完成对应的业务逻辑； 处理器调用模板引擎生成 HTML 并将响应返回给客户端。 接下来我们按照这个流程来编写服务端代码。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"1. 路由器定义 这里我们基于 gorilla/mux 来实现路由器，所以需要安装对应依赖： $ go get -u github.com/gorilla/mux 将路由器定义在 routes 目录下的 router.go 中 package routes import \"github.com/gorilla/mux\" // 返回一个 mux.Router 类型指针，从而可以当作处理器使用 func NewRouter() *mux.Router { // 创建 mux.Router 路由器示例 router := mux.NewRouter().StrictSlash(true) // 遍历 web.go 中定义的所有 webRoutes for _, route := range webRoutes { // 将每个 web 路由应用到路由器 router.Methods(route.Method). Path(route.Pattern). Name(route.Name). Handler(route.HandlerFunc) } return router } 将所有路由定义在同一目录的 routes.go 中： package routes import \"net/http\" // 定义一个 WebRoute 结构体用于存放单个路由 type WebRoute struct { Name string Method string Pattern string HandlerFunc http.HandlerFunc } // 声明 WebRoutes 切片存放所有 Web 路由 type WebRoutes []WebRoute // 定义所有 Web 路由 var webRoutes = WebRoutes{ } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"2. 启动HTTP服务器 最后在项目根目录下的 main.go 中引入上述路由器来启动 HTTP 服务器： package main import ( . \"github.com/xueyuanjun/chitchat/routes\" \"log\" \"net/http\" ) func main() { startWebServer(\"8080\") } // 通过指定端口启动 Web 服务器 func startWebServer(port string) { r := NewRouter() http.Handle(\"/\", r) // 通过 router.go 中定义的路由器来分发请求 log.Println(\"Starting HTTP service at \" + port) err := http.ListenAndServe(\":\" + port, nil) // 启动协程监听请求 if err != nil { log.Println(\"An error occured starting HTTP listener at port \" + port) log.Println(\"Error: \" + err.Error()) } } 这里我们指定 HTTP 服务器监听 8080 端口，使用的路由器正是上述 router.go 中 NewRouter 方法返回的 mux.Router 指针类型实例，这里可以看到引用的时候并没有带上包名前缀，之所以可以这么做是因为通过特殊符号 . 引入了 routes包，通过这种方式引入的包可以直接调用包中对外可见的变量、方法和结构体，而不需要加上包名前缀。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"3. 处理静态资源 在线论坛涉及到前端静态资源文件的处理，我们可以在 startWebServer 方法中新增如下这两行代码： r := NewRouter() // 通过 router.go 中定义的路由器来分发请求 // 处理静态资源文件 assets := http.FileServer(http.Dir(\"public\")) r.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", assets)) http.Handle(\"/\", r) // 应用路由器到 HTTP 服务器 ... 其中 http.FileServer 用于初始化文件服务器和目录为当前目录下的 public 目录。 然后在第二段代码中指定静态资源路由及处理逻辑：将 /static/ 前缀的 URL 请求去除 static 前缀，然后在文件服务器查找指定文件路径是否存在（public 目录下的相对地址）。 比如 URL 请求路径为 http://localhost:8080/static/css/bootstrap.min.css，对应的查找路径是： \u003capplication root\u003e/public/css/bootstrap.min.css 对于静态资源文件直接返回文件内容，不会进行额外处理。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4. 编写处理器实现 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.1 首页处理器方法 做好上述准备工作后，接下来，我们来创建论坛首页的路由处理器，在 handlers 目录下新增一个 index.go 来定义首页的处理器方法： package handlers import ( \"github.com/xueyuanjun/chitchat/models\" \"html/template\" \"net/http\" ) // 论坛首页路由处理器方法 func Index(w http.ResponseWriter, r *http.Request) { files := []string{\"views/layout.html\", \"views/navbar.html\", \"views/index.html\",} templates := template.Must(template.ParseFiles(files...)) threads, err := models.Threads(); if err == nil { templates.ExecuteTemplate(w, \"layout\", threads) } } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.2 创建视图模板 这里我们使用 Go 自带的 html/template 作为模板引擎，需要传入位于 views 目录下的视图模板文件，这里传入了多个模板文件，包括主布局文件 layout.html： {{ define \"layout\" }} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eChitChat\u003c/title\u003e \u003clink href=\"/static/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"/static/css/font-awesome.min.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e {{ template \"navbar\" . }} \u003cdiv class=\"container\"\u003e {{ template \"content\" . }} \u003c/div\u003e \u003c!-- /container --\u003e \u003cscript src=\"/static/js/jquery-2.1.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"/static/js/bootstrap.min.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e {{ end }} 顶部导航模板 navbar.html： {{ define \"navbar\" }} \u003cdiv class=\"navbar navbar-default navbar-static-top\" role=\"navigation\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"navbar-header\"\u003e \u003cbutton type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"\u003e \u003cspan class=\"sr-only\"\u003eToggle navigation\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003cspan class=\"icon-bar\"\u003e\u003c/span\u003e \u003c/button\u003e \u003ca class=\"navbar-brand\" href=\"/\"\u003e \u003ci class=\"fa fa-comments-o\"\u003e\u003c/i\u003e ChitChat \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"navbar-collapse collapse\"\u003e \u003cul class=\"nav navbar-nav\"\u003e \u003cli\u003e\u003ca href=\"/\"\u003eHome\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"nav navbar-nav navbar-right\"\u003e \u003cli\u003e\u003ca href=\"/login\"\u003eLogin\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 以及首页视图模板 index.html： {{ define \"content\" }} \u003cp class=\"lead\"\u003e \u003ca href=\"/thread/new\"\u003eStart a thread\u003c/a\u003e or join one below! \u003c/p\u003e {{ range . }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"panel-body\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }} posts. \u003cdiv class=\"pull-right\"\u003e \u003ca href=\"/thread/read?id={{.Uuid }}\"\u003eRead more\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} {{ end }} 引入多个视图模板是为了提高模板代码的复用性，因为对于同一个应用的不同页面来说，可能基本布局、页面顶部导航和页面底部组件都是一样的，关于视图模板的细节，我们在后面视图模板部分会详细介绍，这里简单了解下即可。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.3 渲染视图模板 我们可以从数据库查询群组数据并将该数据传递到模板文件，最后将模板视图渲染出来，对应代码如下： threads, err := models.Threads(); if err == nil { templates.ExecuteTemplate(w, \"layout\", threads) } 编译多个视图模板时，默认以第一个模板名作为最终视图模板名，所以这里第二个参数传入的是 layout，第三个参数传入要渲染的数据 threads，对应的渲染逻辑位于 views/index.html 中： {{ range . }} \u003cdiv class=\"panel panel-default\"\u003e \u003cdiv class=\"panel-heading\"\u003e \u003cspan class=\"lead\"\u003e \u003ci class=\"fa fa-comment-o\"\u003e\u003c/i\u003e {{ .Topic }}\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"panel-body\"\u003e Started by {{ .User.Name }} - {{ .CreatedAtDate }} - {{ .NumReplies }} posts. \u003cdiv class=\"pull-right\"\u003e \u003ca href=\"/thread/read?id={{.Uuid }}\"\u003eRead more\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{ end }} 其中 {{ range . }} 表示将处理器方法传入的变量，这里是 threads 进行循环。 ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"4.4 注册首页路由 最好，我们在 routes/routes.go 中注册首页路由及对应的处理器方法 Index： import \"github.com/xueyuanjun/chitchat/handlers\" // 定义所有 Web 路由 var webRoutes = WebRoutes{ { \"home\", \"GET\", \"/\", handlers.Index, }, } ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:4:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"5. 访问论坛首页 访问论坛首页之前，我们将相应的前端资源文件拷贝到 public 目录下，此时项目整体目录结构如下： 然后我们在项目根目录下运行如下代码启动 HTTP 服务器 $ go run main.go 然后我们在浏览器访问论坛首页 http://localhost:8080： ","date":"2020-05-29","objectID":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/:5:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛3-访问论坛首页","uri":"/2020/development-of-online-forum-based-on-golang-3-visit-forum-homepage/"},{"categories":["Golang学习之路"],"content":"在 Go 中，加密是很重要的一部分，本文对此进行介绍。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:0:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1. Hash 利用 Hash 算法可以将任意长度的二进制值（明文）映射为较短的固定长度的二进制值（Hash 值），是密码学的基础之一。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.1 流行的Hash算法 目前常见的Hash算法包括Message Digest（MD）系列和Secure HashAlgorithm（SHA）系列算法。 MD算法主要包括MD4和MD5两个算法。MD4（RFC 1320）是MIT的Ronald L. Rivest在1990年设计的，其输出为128位。MD4已被证明不够安全。MD5（RFC 1321）是Rivest于1991年发布的MD4改进版本。它对输入仍以512位进行分组，其输出是128位。MD5比MD4更加安全，但过程更加复杂，计算速度要慢一点。MD5已于2004年被成功碰撞，其安全性已不足以应用于商业场景。 SHA算法由美国国家标准与技术研究院（National Institute ofStandards and Technology，NIST）征集制定。SHA-0算法于1993年问世，1998年即遭破解。随后的修订版本SHA-1算法在1995年面世，它的输出为长度160位的Hash值，安全性更好。SHA-1设计采用了MD4算法类似原理。SHA-1已于2005年被成功碰撞，意味着无法满足商用需求。为了提高安全性，NIST后来制定出更安全的SHA-224、SHA-256、SHA-384和SHA-512算法（统称为SHA-2算法）。新一代的SHA-3算法也正在研究中。 目前MD5和SHA-1已经不够安全，推荐至少使用SHA-256算法。比特币系统就是使用SHA-256算法。 SHA-3算法又名Keccak算法。Keccak的输出长度有：512位、384位、256位、224位。 SHA-3并不是要取代SHA-2，因为SHA-2目前并没有暴露明显的弱点。由于对MD5出现成功的破解，以及对SHA-1出现理论上破解的方法，NIST认为需要一个与之前算法不同的、可替换的加密杂凑算法，也就是现在的SHA-3。区块链中的以太坊系统就是使用Keccak256算法 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:1","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.2 SHA-256 SHA-256算法输入报文的最大长度是264 bit，产生的输出是一个256bit的报文摘要。SHA-256算法步骤如下。 附加填充比特：对报文进行填充，使报文长度与448模512同余（长度=448 mod512），填充的比特数范围是1到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个1，再加很多个0，直到长度满足mod512=448。为什么是448？因为448+64=512。第二步会加上一个64bit的原始报文的长度信息。 附加长度值：将用64bit表示的初始报文（填充前）的位长度附加在步骤1的结果后（低位字节优先）。 初始化缓存：使用一个256bit的缓存来存放该Hash函数的中间及最终结果。该缓存表示为A=0x6A09E667，B=0xBB67AE85，C=0x3C6EF372，D=0xA54FF53A，E=0x510E527F，F=0x9B05688C，G=0x1F83D9AB，H=0x5BE0CD19。 处理512bit（16个字）报文分组序列：该算法使用了6种基本逻辑函数，由64步迭代运算组成。每步都以256bit缓存值ABCDEFGH为输入，然后更新缓存内容。 每步使用一个32bit Kt（常数值）和一个32bit Wt（分组后的报文）。 ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:2","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"1.3 示例代码 计算字符串的 SHA-256 使用如下函数原型 func Sum256(data []byte) [Size]byte ","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:1:3","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"2. 对称加密算法","date":"2020-05-28","objectID":"/2020/golang-cryptographic-algorithm/:2:0","tags":["Go实战"],"title":"Golang密码学算法","uri":"/2020/golang-cryptographic-algorithm/"},{"categories":["Golang学习之路"],"content":"在本篇教程中，我们将在 MySQL 中创建一个 chitchat 数据库作为论坛项目的数据库。我选择了在本地安装 MySQL Server，但也可以基于 Docker 容器运行。转自学院君的教程，略有改动。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"1. 项目初始化 首先创建项目目录，命名为 chitchat，然后初始化目录结构如下 各个子目录/文件的作用介绍如下： main.go：应用入口文件 config.json：全局配置文件 handlers：用于存放处理器代码（可类比为 MVC 模式中的控制器目录） logs：用于存放日志文件 models：用于存放与数据库交互的模型类 public：用于存放前端资源文件，比如图片、CSS、JavaScript 等 routes：用于存放路由文件和路由器实现代码 views：用于存放视图模板文件 在 Github 网页端创建同名仓库，然后在本地执行如下命令初始化仓库（我们使用 Github 存储代码） echo \"# chitchat\" \u003e\u003e README.md git init git add README.md git commit -m \"Initialize project directory\" git remote add origin https://github.com/shuzang/chitchat.git git push -u origin master 然后在 chitchat 目录下初始化 Go 项目， 后续通过 Go Module 来管理依赖 $ go mod init github.com/shuzang/chitchat ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"2. 创建数据表 在 MySQL Server 中创建 chitchat 数据库，然后创建数据表，数据表对应的 SQL 语句如下 createtableusers(idserialprimarykey,uuidvarchar(64)notnullunique,namevarchar(255),emailvarchar(255)notnullunique,passwordvarchar(255)notnull,created_attimestampnotnull);createtablesessions(idserialprimarykey,uuidvarchar(64)notnullunique,emailvarchar(255),user_idintegerreferencesusers(id),created_attimestampnotnull);createtablethreads(idserialprimarykey,uuidvarchar(64)notnullunique,topictext,user_idintegerreferencesusers(id),created_attimestampnotnull);createtableposts(idserialprimarykey,uuidvarchar(64)notnullunique,bodytext,user_idintegerreferencesusers(id),thread_idintegerreferencesthreads(id),created_attimestampnotnull); 使用 Navicat for MySQL 进行连接测试 大量的语句逐条执行很容易出错，可以通过脚本形式批量执行1。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3. 与数据库交互 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.1 数据库驱动 数据表创建完成后，接下来，需要在 Go 应用代码中与数据库交互，Go 语言开发组并没有为此提供官方的数据库驱动实现，只是提供了数据库交互接口，我们可以通过实现这些接口的第三方扩展包完成与 MySQL 数据库的交互，本项目选择的扩展包是 go-mysql-driver 。 我们可以在 Go 应用中编写模型类基于这个扩展包提供的方法与 MySQL 交互完成增删改查操作，开始之前，可以运行如下命令安装这个依赖： $ go get -u github.com/go-sql-driver/mysql ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:1","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.2 数据库连接 然后在 chitchat/models 目录下创建 db.go，并编写数据库连接初始化方法以及生成 UUID、哈希加密方法： package models import ( \"crypto/rand\" \"crypto/sha256\" \"database/sql\" \"fmt\" \"log\" _ \"github.com/go-sql-driver/mysql\" ) var Db *sql.DB func init() { var err error Db, err = sql.Open(\"mysql\", \"root:root@/chitchat?charset=utf8\u0026parseTime=true\") if err != nil { log.Fatal(err) } } // create a random UUID with from RFC 4122 // adapted from http://github.com/nu7hatch/gouuid func createUUID() (uuid string) { u := new([16]byte) _, err := rand.Read(u[:]) if err != nil { log.Fatalln(\"Cannot generate UUID\", err) } // 0x40 is reserved variant from RFC 4122 u[8] = (u[8] | 0x40) \u0026 0x7F // Set the four most significant bits (bits 12 through 15) of the // time_hi_and_version field to the 4-bit version number. u[6] = (u[6] \u0026 0xF) | (0x4 \u003c\u003c 4) uuid = fmt.Sprintf(\"%x-%x-%x-%x-%x\", u[0:4], u[4:6], u[6:8], u[8:10], u[10:]) return } // hash plaintext with sha-256 func Encrypt(plaintext string) (cryptext string) { cryptext = fmt.Sprintf(\"%x\", sha256.Sum256([]byte(plaintext))) return } 其中，Db 变量代表数据库连接池，通过 init 方法在 Web 应用启动时自动初始化数据库连接，这样，我们就可以在应用中通过 Db 变量对数据库进行增删改查操作了，这也是该变量首字母大写的原因，方便在 models 包之外被引用，具体的操作实现我们放到独立的模型文件中处理。 注：这里通过 sql.Open 初始化数据库连接，我们写死了数据库连接配置，在实际生产环境，这块配置值应该从配置文件或系统环境变量获取。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:2","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.3 用户模型相关类 有了代表数据库连接池的 Db 变量之后，就可以为每个数据表编写对应的模型类实现增删改查操作了，首先在 models 目录下创建 user.go 用于定义用户模型类 User 与 users 表进行交互，以及与 sessions 表进行关联： package models import \"time\" type User struct { Id int Uuid string Name string Email string Password string CreatedAt time.Time } // Create a new session for an existing user func (user *User) CreateSession() (session Session, err error) { statement := \"insert into sessions (uuid, email, user_id, created_at) values (?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, user.Email, user.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, email, user_id, created_at from sessions where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026session.Id, \u0026session.Uuid, \u0026session.Email, \u0026session.UserId, \u0026session.CreatedAt) return } // Get the session for an existing user func (user *User) Session() (session Session, err error) { session = Session{} err = Db.QueryRow(\"SELECT id, uuid, email, user_id, created_at FROM sessions WHERE user_id = ?\", user.Id). Scan(\u0026session.Id, \u0026session.Uuid, \u0026session.Email, \u0026session.UserId, \u0026session.CreatedAt) return } // Create a new user, save user info into the database func (user *User) Create() (err error) { // Postgres does not automatically return the last insert id, because it would be wrong to assume // you're always using a sequence.You need to use the RETURNING keyword in your insert to get this // information from postgres. statement := \"insert into users (uuid, name, email, password, created_at) values (?, ?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, user.Name, user.Email, Encrypt(user.Password), time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, created_at from users where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the User struct err = stmtout.QueryRow(uuid).Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.CreatedAt) return } // Delete user from database func (user *User) Delete() (err error) { statement := \"delete from users where id = ?\" stmt, err := Db.Prepare(statement) if err != nil { return } defer stmt.Close() _, err = stmt.Exec(user.Id) return } // Update user information in the database func (user *User) Update() (err error) { statement := \"update users set name = ?, email = ? where id = ?\" stmt, err := Db.Prepare(statement) if err != nil { return } defer stmt.Close() _, err = stmt.Exec(user.Name, user.Email, user.Id) return } // Delete all users from database func UserDeleteAll() (err error) { statement := \"delete from users\" _, err = Db.Exec(statement) return } // Get all users in the database and returns it func Users() (users []User, err error) { rows, err := Db.Query(\"SELECT id, uuid, name, email, password, created_at FROM users\") if err != nil { return } for rows.Next() { user := User{} if err = rows.Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt); err != nil { return } users = append(users, user) } rows.Close() return } // Get a single user given the email func UserByEmail(email string) (user User, err error) { user = User{} err = Db.QueryRow(\"SELECT id, uuid, name, email, password, created_at FROM users WHERE email = ?\", email). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt) return } // Get a single user given the UUID func UserByUUID(uuid string) (user User, err error) { user = User{} err = Db.QueryRow(\"SELECT id, uuid, name, email, password, created_at FROM users WHERE uuid = ?\", uuid). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.Password, \u0026user.CreatedAt) return } 创建 session.go 用于定义会话模型类 Session： package models import \"time\" type Session struct { Id int Uuid string Email string UserId int Created","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:3","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3.4 主题模型相关类 编写好用户相关模型类后，接下来在同级目录下创建 thread.go，定义群组模型类 Thread 与 threads 表进行交互： package models import \"time\" type Thread struct { Id int Uuid string Topic string UserId int CreatedAt time.Time } // format the CreatedAt date to display nicely on the screen func (thread *Thread) CreatedAtDate() string { return thread.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } // get the number of posts in a thread func (thread *Thread) NumReplies() (count int) { rows, err := Db.Query(\"SELECT count(*) FROM posts where thread_id = ?\", thread.Id) if err != nil { return } for rows.Next() { if err = rows.Scan(\u0026count); err != nil { return } } rows.Close() return } // get posts to a thread func (thread *Thread) Posts() (posts []Post, err error) { rows, err := Db.Query(\"SELECT id, uuid, body, user_id, thread_id, created_at FROM posts where thread_id = ?\", thread.Id) if err != nil { return } for rows.Next() { post := Post{} if err = rows.Scan(\u0026post.Id, \u0026post.Uuid, \u0026post.Body, \u0026post.UserId, \u0026post.ThreadId, \u0026post.CreatedAt); err != nil { return } posts = append(posts, post) } rows.Close() return } // Get all threads in the database and returns it func Threads() (threads []Thread, err error) { rows, err := Db.Query(\"SELECT id, uuid, topic, user_id, created_at FROM threads ORDER BY created_at DESC\") if err != nil { return } for rows.Next() { conv := Thread{} if err = rows.Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt); err != nil { return } threads = append(threads, conv) } rows.Close() return } // Get a thread by the UUID func ThreadByUUID(uuid string) (conv Thread, err error) { conv = Thread{} err = Db.QueryRow(\"SELECT id, uuid, topic, user_id, created_at FROM threads WHERE uuid = ?\", uuid). Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt) return } // Get the user who started this thread func (thread *Thread) User() (user User) { user = User{} Db.QueryRow(\"SELECT id, uuid, name, email, created_at FROM users WHERE id = ?\", thread.UserId). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.CreatedAt) return } 以及 post.go 编写主题模型类与 posts 表进行交互： package models import \"time\" type Post struct { Id int Uuid string Body string UserId int ThreadId int CreatedAt time.Time } func (post *Post) CreatedAtDate() string { return post.CreatedAt.Format(\"Jan 2, 2006 at 3:04pm\") } // Get the user who wrote the post func (post *Post) User() (user User) { user = User{} Db.QueryRow(\"SELECT id, uuid, name, email, created_at FROM users WHERE id = ?\", post.UserId). Scan(\u0026user.Id, \u0026user.Uuid, \u0026user.Name, \u0026user.Email, \u0026user.CreatedAt) return } 此外，我们到 user.go 中为 User 模型新增如下两个方法与 Thread、Post 模型进行关联，用于创建新的群组和主题： // Create a new thread func (user *User) CreateThread(topic string) (conv Thread, err error) { statement := \"insert into threads (uuid, topic, user_id, created_at) values (?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, topic, user.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, topic, user_id, created_at from threads where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026conv.Id, \u0026conv.Uuid, \u0026conv.Topic, \u0026conv.UserId, \u0026conv.CreatedAt) return } // Create a new post to a thread func (user *User) CreatePost(conv Thread, body string) (post Post, err error) { statement := \"insert into posts (uuid, body, user_id, thread_id, created_at) values (?, ?, ?, ?, ?)\" stmtin, err := Db.Prepare(statement) if err != nil { return } defer stmtin.Close() uuid := createUUID() stmtin.Exec(uuid, body, user.Id, conv.Id, time.Now()) stmtout, err := Db.Prepare(\"select id, uuid, body, user_id, thread_id, created_at from posts where uuid = ?\") if err != nil { return } defer stmtout.Close() // use QueryRow to return a row and scan the returned id into the Session struct err = stmtout.QueryRow(uuid).Scan(\u0026post.Id, \u0026post.Uuid, \u0026post.Body,","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:3:4","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"4. 小结 在上述编写的模型类中，模型类与数据表的映射由 go-mysql-driver 底层实现，每次从数据库查询到结果之后，可以通过 Scan 方法将数据表字段值映射到对应的结构体模型类，而将模型类保存到数据库时，又可以基于字段映射关系将结构体属性值转化为对应的数据表字段值。 底层数据库交互逻辑定义好了之后，接下来，我们就可以编写上层实现代码了，下一篇介绍在线论坛项目上层路由和处理器方法的实现。 mysql下如何执行sql脚本 ↩︎ ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/:4:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛2-通过模型类与MySQL数据库交互","uri":"/2020/development-of-online-forum-based-on-golang-2-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"转自学院君的教程1 ，这里进行复现并深入理解，文章内容可能略有调整。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:0:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"1. 项目介绍 要完成的是一个简单的在线论坛项目，主要仿照 Google 网上论坛 进行开发，但功能和界面要简化很多，包括 用户认证功能（注册、登录、退出等） 认证后的用户可以创建新的群组（帖子）、以及在群组中发表主题（跟帖） 访客用户访问论坛首页可以查看群组列表，进入指定群组页面可以查看对应的主题信息 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:1:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"2. 技术方案 采用典型的 MVC 架构2，以群组详情页为例，假设对应的 URL 是 http://chitchat.test/thread/read?id=123，其中 chitchat.test 是请求域名，thread/read 是请求路由（查看群组），?id=123 是请求参数（群组ID），通过域名确定应用所在的服务器 IP，通过端口号（此处没有显式展示，一般默认是 80 端口）确定应用进程，应用接收到请求后，通过路由将请求分发到指定处理器方法（路由器，或者叫做多路复用器做的就是这个工作，是整个应用请求分发的入口），通过请求参数对数据库进行查询，再将视图响应发送给请求用户，如果数据库查询没有结果，则返回 404 响应。这里，数据库承担的是 M 的角色（Model），视图响应承担的是 V 的角色（View），处理器方法承担的是 C 的角色（Controller）： 上图中 Client 代表发起请求的用户，虚框内是部署在服务器已启动的在线论坛应用，Multiplexer 代表路由器（比如 gorilla/mux ），Handler 代表处理器/处理器方法，数据库操作位于处理器方法中，Templates 代表最终展示给用户的经过模板引擎编译过的视图模板。 我们需要在本地按照这个 MVC 架构基于业务流程编写代码，最后将测试过的应用代码编译打包，部署到远程服务器（这样才能被普通用户访问），并启动该应用，等待客户端请求，这样就完成了整个应用开发流程。 ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:2:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"3. 数据模型 根据我们之前拟定的需求，至少需要三个模型： 用户（User） 群组（Thread） 主题（Post） 另外，我们在本项目开发时，会把用户会话（Session）也存储到数据库（用于认证），所以需要一个额外的会话模型，此外，为了简化应用，我们不会真的像 Google 网上论坛那样对用户做权限管理，整个应用只包含一种用户类型，并且具备所有操作权限： 学院君，基于 Go 语言开发在线论坛 ↩︎ 知乎，MVC架构模式详细说明以及与三层架构的区别 ↩︎ ","date":"2020-05-27","objectID":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/:3:0","tags":["Go实战"],"title":"基于Go语言开发在线论坛1-整体设计与数据模型","uri":"/2020/development-of-online-forum-based-on-golang-1-overall-design-and-data-model/"},{"categories":["Golang学习之路"],"content":"Go 官方提供了database 包，database 包下有 sql/driver。该包用来定义操作数据库的接口，这保证了无论使用哪种数据库，操作方式都是相同的。但 Go 官方并没有提供连接数据库的 driver，如果要操作数据库，还需要第三方的 driver 包。这里介绍 go-mysql-driver 的使用。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:0:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"1. 安装 在执行了 go mod 的项目目录下执行如下安装命令 $ go get -u github.com/go-sql-driver/mysql Win10 下，go-sql-driver 包将被安装到 %GOPATH%\\pkg\\mod\\github.com\\go-sql-driver\\mysql@v1.5.0 目录下，其它项目使用时不必重复下载，执行上述命令即可直接引入。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:1:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"2. 导入 示例代码如下 import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) Golang 提供了database/sql 包，用于对 SQL 数据库的访问。它提供了一系列接口方法，用于访问关系数据库但并不会提供数据库特有的方法，那些特有的方法交给数据库驱动去实现。 对于数据库操作来说，开发者不应该直接使用导入的驱动包所提供的方法，而应该使用 sql.DB 对象所提供的统一的方法。因此在导入 MySQL 驱动时，使用了匿名导入包的方式，即将 go-sql-driver 包重命名为特殊符号 _。采用这种方式只会执行其中的 init 函数和初始化其全局变量，无法调用函数。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:2:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"3. 连接数据库 连接数据库使用 sql 包中的 Open() 函数，原型如下 func Open(driverName, dataSourceName string) (*DB, error) driverName：使用的驱动名。这个名字其实就是数据库驱动注册到 database/sql 时所使用的名字 dataSourceName：数据库连接信息。它包含了数据库的用户名、密码、数据库主机以及需要连接的数据库名等信息。 使用示例如下 db, err := sql.Open(\"mysql\", \"用户名:密码@tcp(IP:端口)/数据库?charset=utf8\") sql.Open() 返回的 sql.DB 对象是 Goroutine 并发安全的。sql.DB 通过数据库驱动为开发者提供管理底层数据库连接的打开和关闭操作。sql.DB 帮助开发者管理数据库连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果开发者没有把连接释放回连接池，会导致过多连接使系统资源耗尽。 sql.DB 的设计目标就是作为长连接（一次连接多次数据交互）使用，不宜频繁开关。比较好的做法是，为每个不同的 datastore 建一个DB 对象，保持这些对象打开。如果需要短连接（一次连接一次数据交互），就把 DB 作为参数传入函数，而不要在函数中开关。 ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:3:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"4. 增删改数据 直接调用DB对象的 Exec() 方法如下所示 func (db *DB) Exec(query string, args ...interface{}) (Result, error) 通过db.Exec()插入数据，通过返回的 err 可知插入失败的原因，通过返回的结果可以进一步查询本次插入数据影响的行数（RowsAffected）和最后插入的ID（如果数据库支持查询最后插入ID）。事实上，Result 是对已执行的 SQL 命令的总结，类型定义如下 type Result interface { // LastInsertId返回一个数据库生成的回应命令的整数。 // 当插入新行时，一般来自一个\"自增\"列。 // 不是所有的数据库都支持该功能，该状态的语法也各有不同。 LastInsertId() (int64, error) // RowsAffected返回被update、insert或delete命令影响的行数。 // 不是所有的数据库都支持该功能。 RowsAffected() (int64, error) } Exec() 方法的使用方式如下所示 result,err := db.Exec(\"INSERT INTO user_info (username, departname, created) VALUES (?,?,?)\", \"Steven\", \"区块链教学部\"， \"2017-10-1\") 预编译语句（PreparedStatement）提供了诸多好处。PreparedStatement 可以实现自定义参数的查询，通常来说比手动拼接字符串SQL语句高效；PreparedStatement 还可以防止SQL注入攻击。因此，开发中应尽量使用它。 通常使用 PreparedStatement 和 Exec() 完成 INSERT、UPDATE、DELETE 操作。使用DB对象的Prepare() 方法获得预编译对象 stmt，然后调用 Exec() 方法，语法如下所示。 func (db *DB) Prepare(query string) (*Stmt, error) 具体用法如下 stmt, err := db.Prepare(\"INSERT INTO user_info SET username=?, departnamt=?, created=?\") result, err := stmt.Exec(\"Jackson\", \"研发部\", \"2017-10-1\") 获取影响数据库的行数，可以根据该数值判断是否操作（插入、删除或修改）成功。语法如下所示。 count, err := result.RowsAffected() 预编译对象 stmt 属于 Stmt 类型，是一个准备好的状态，可以安全地被多个 Goroutine 同时使用，类型定义与方法集如下，定义在 DB 对象上的 Exec 和 Stmt 对象上的 Exec 传入参数有区别，后者不需要 SQL 语句，但作用应该是相同的。 type Stmt struct { // 内含隐藏或非导出字段 } func (s *Stmt) Exec(args ...interface{}) (Result, error) func (s *Stmt) Query(args ...interface{}) (*Rows, error) func (s *Stmt) QueryRow(args ...interface{}) *Row func (s *Stmt) Close() error ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:4:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"5. 查询数据 数据查询的一般步骤如下 调用 db.Query() 方法执行 SQL 语句，此方法返回一个 Rows 作为查询结果，语法如下所示 func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 注意，Rows 作为查询结果，其游标指向结果集的第零行 将 rows.Next() 方法的返回值作为 for 循环的条件，迭代查询数据，语法如下所示。 func (rs *Rows) Next() bool Next 的返回值不是简单的一个对下一个结果是否存在的判断，而是准备下一行结果用于 Scan 方法进行扫描，如果准备好，返回 true，如果没有下一行或准备时出现错误，返回 false 在循环中，通过 rows.Scan()方法读取每一行数据，语法如下所示。 func (rs *Rows) Scan(dest ...interface{}) error rows.Scan() 方法的参数顺序很重要，必须和查询结果的列相对应（数量和顺序都需要一致）。假设 SELECT * From user_info where age ＞=20 AND age ＜ 30 查询的列顺序是 id, name, age，和插入操作顺序相同，rows.Scan() 的参数传入也需要按照此顺序 rows.Scan(＆id, ＆name, ＆age)，不然会造成数据读取的错位。 调用db.Close()关闭查询，Close 关闭 DB对象，释放任何打开的资源，但实际上因为 DB 句柄通常被多个 Go 协程共享，不会被关闭。 查询多行数据的一个完整示例如下所示 stmt, err := db.Prepare(\"SELECT * FROM user_info WHERE uid\u003c?\") rows, err := stmt.Query(10) // 注意这里的 Query 也是 stmt 的方法 user := new(UserTable) for rows.Next() { err := rows.Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { panic(err) continue } fmt.Println(*user) } 因为 Golang 是强类型语言，所以查询数据时先定义数据类型。数据库中的数据有3种可能状态：存在值、存在零值、未赋值，因此可以将待查询的数据类型定义为 sql.NullString、sql.NullInt64 类型等。可以通过 Valid 值来判断查询到的值是赋值状态还是未赋值状态。 每次 db.Query() 操作后，都建议调用 rows.Close()。因为 db.Query() 会从数据库连接池中获取一个连接，这个底层连接在结果集（rows）未关闭前会被标记为处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部 EOF 错误，自动调用 rows.Close()。但如果出现异常，提前退出循环，rows 不会关闭，连接不会回到连接池中，连接也不会关闭，则此连接会一直被占用。因此通常使用 defer rows.Close() 来确保数据库连接可以正确放回到连接池中。rows.Close() 操作是幂等操作，而一个幂等操作的特点是：其任意多次执行所产生的影响与一次执行的影响相同。所以即便对已关闭的 rows 再执行 close() 也没关系。 谈到这里，我们可以注意到 Close 方法一共有三种，分别定义在 DB、Stmt、Rows 三个方法上，用于关闭数据库连接、预准备状态和查询结果，不过本质上都是释放某个连接池中的连接。 单条数据通过 QueryRow() 方法查询，语法如下所示。 func (db *DB) QueryRow(query string, args ...interface{}) *Row 使用示例如下 var username, departname, created string err := db.QueryRow(\"SELECT username, departname, created FROM user_info WHERE uid=?\", 3).Scan(\u0026username, \u0026departname, \u0026created) ","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:5:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"6. 示例代码 定义一个表结构如下 mysql\u003e CREATE TABLE user_info ( -\u003e uid INT(10) NOT NULL AUTO_INCREMENT, -\u003e username VARCHAR(64) DEFAULT NULL, -\u003e departname VARCHAR(64) DEFAULT NULL, -\u003e created DATE DEFAULT NULL, -\u003e PRIMARY KEY(uid) -\u003e ); Query OK, 0 rows affected, 1 warning (0.03 sec) mysql\u003e DESC user_info; +------------+-------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +------------+-------------+------+-----+---------+----------------+ | uid | int | NO | PRI | NULL | auto_increment | | username | varchar(64) | YES | | NULL | | | departname | varchar(64) | YES | | NULL | | | created | date | YES | | NULL | | +------------+-------------+------+-----+---------+----------------+ 4 rows in set (0.00 sec) 编写一个完整的测试代码，使用上述提到的所有数据库操作 package main import ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" ) // 定义数据库连接信息 type DbConn struct { Dsn string // 数据库驱动字符串 Db *sql.DB } // 数据库中的用户表的映射对象 type UserTable struct { Uid int Username string Department string Created string } func main() { var err error dbConn := DbConn{ Dsn: \"root:@tcp(127.0.0.1:3306)/testdb?charset=utf8\", } dbConn.Db, err = sql.Open(\"mysql\", dbConn.Dsn) if err != nil { fmt.Println(err) } defer dbConn.Db.Close() //1. 测试直接使用 DB 的 Exec() 方法增删改 execData(\u0026dbConn) //2. 测试使用预编译语句和 Exec() 方法增删改 preExecData(\u0026dbConn) //3. 查询单行数据(以最后一条数据为例) result := dbConn.QueryRowData(\"select * from user_info where uid = (select max(uid) from user_info)\") fmt.Println(result) //4. 查询多行数据 result1 := dbConn.QueryData(\"select * from user_info where uid\u003c10\") fmt.Println(len(result1)) //5. 查询多行数据（使用预编译语句） result2 := dbConn.PreQueryData(\"select * from user_info where uid\u003c? order by uid desc\", 10) fmt.Println(len(result2)) //遍历查询的结果集 for k, v := range result2 { fmt.Println(\"uid: \", k, v) } } func execData(dbConn *DbConn) { count, id, err := dbConn.ExecData(\"insert user_info (username,departname,created) values ('Josh', 'business group','2020-06-14')\") if err != nil { fmt.Println(err.Error()) } else { fmt.Println(\"受影响的行数：\", count) fmt.Println(\"新添加数据的id：\", id) } } func (dbConn *DbConn) ExecData(sqlString string) (count, id int64, err error) { result, err := dbConn.Db.Exec(sqlString) if err != nil { fmt.Println(err) return } if id, err = result.LastInsertId(); err != nil { fmt.Println(err) return } if count, err = result.RowsAffected(); err != nil { fmt.Println(err) return } return count, id, nil } func preExecData(dbConn *DbConn) { count, id, err := dbConn.PreExecData(\"insert user_info (username,departname,created) values ('Jackson', 'Education Department','2020-06-14')\") if err != nil { fmt.Println(err.Error()) } else { fmt.Println(\"受影响的行数：\", count) fmt.Println(\"新添加数据的id：\", id) } } func (dbConn *DbConn) PreExecData(sqlString string, args ...interface{}) (count, id int64, err error) { stmt, err := dbConn.Db.Prepare(sqlString) defer stmt.Close() if err != nil { fmt.Println(err) return } result, err := stmt.Exec(args...) if err != nil { fmt.Println(err) return } if id, err = result.LastInsertId(); err != nil { fmt.Println(err) return } if count, err = result.RowsAffected(); err != nil { fmt.Println(err) return } return count, id, nil } func (dbConn *DbConn) QueryRowData(sqlString string) (data UserTable) { user := new(UserTable) err := dbConn.Db.QueryRow(sqlString).Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { fmt.Println(err) return } return *user } func (dbConn *DbConn) QueryData(sqlString string) (resultSet map[int]UserTable) { rows, err := dbConn.Db.Query(sqlString) defer rows.Close() if err != nil { fmt.Println(err) return } resultSet = make(map[int]UserTable) user := new(UserTable) for rows.Next() { err := rows.Scan(\u0026user.Uid, \u0026user.Username, \u0026user.Department, \u0026user.Created) if err != nil { fmt.Println(err) continue } resultSet[user.Uid] = *user } return resultSet } func (dbConn *DbConn) PreQueryData(sqlString string, args ...interface{}) (resultSet map[int]UserTable) { stmt, err := dbConn.Db.Prepare(sqlString) defer st","date":"2020-05-26","objectID":"/2020/golang-interact-with-mysql/:6:0","tags":["Go实战"],"title":"Golang数据库编程","uri":"/2020/golang-interact-with-mysql/"},{"categories":["Golang学习之路"],"content":"实际开发中对代码进行测试是不可缺少的工作，在go中可以通过testing包来进行代码的测试。testing包和go test命令相互配合，能够完成代码的自动化测试。 在实际开发中，对代码进行测试是不可缺少的工作，在go中可以通过testing包对代码进行单元测试和性能测试。 基本说明 testing包是与go test命令配合使用的，编写测试代码需要使用testing包，而执行测试需要使用go test命令。执行测试时，会自动读取源码目录下名为*_test.go的文件，生成并运行测试用的可执行文件，并最终在终端输出测试信息。输出的信息类似于 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... testing包的说明位于：Package testing go test的说明可通过执行 go help test查看 单元测试 假设当前我们在源代码目录拥有名为hello.go的源码文件，其内容如下： package hello import \"fmt\" //Hello print \"hello! func Hello() { fmt.Println(\"hello!\") } 首先编写测试用例，即在hello.go文件同目录下创建hello_test.go文件，编辑其内容如下： package hello import \"testing\" func TestHello(t *testing.T) { Hello() } 注意，单元测试的函数头一般符合如下形式，其中Xxx是测试函数名。无论原函数名首字母是否大写，测试函数中函数名的首字母必须大写，原话为where Xxx does not start with a lowercase letter. func TestXxx(t *testing.T) 在这两个文件目录下执行go test命令 PS F:\\Go\u003e ls Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2019/9/19 19:31 154 hello.go -a---- 2019/9/19 19:45 222 hello_test.go PS F:\\Go\u003e go test hello! PASS ok _/F_/Go 0.248s 根据输出结果可知测试通过 性能测试 在hello.go中新增Add函数 package hello import \"fmt\" //Hello print \"hello! func Hello() { fmt.Println(\"hello!\") } //Add add para func Add(i int) int { return i } 在hello_test.go文件中添加Add的性能测试函数 package hello import ( \"fmt\" \"testing\" ) func TestHello(t *testing.T) { Hello() } func BenchmarkAdd(b *testing.B) { var sum int for i := 0; i \u003c b.N; i++ { sum += Add(1) } fmt.Println(sum) } 性能测试的函数头也符合与单元测试相似的形式 func BenchmarkXxx(b *testing.B) 执行带bench参数的go test命令 PS F:\\Go\u003e go test -bench . hello! 1 goos: windows goarch: amd64 BenchmarkHello-4 100 10000 1000000 100000000 2000000000 2000000000 0.32 ns/op PASS ok _/F_/Go 1.019s 以上命令只执行了性能测试函数，BenchmarkHello执行了2000000000次，每次的平均执行时间为0.32ns，总的执行时间为1.019s。测试通过。 go test命令的参数 以上是基本的单元测试和性能测试命令，go test命令还拥有大量的参数，可以对测试进行定制。 usage: go test [build/test flags] [packages] [build/test flags \u0026 test binary flags] 如上，go test命令接受用于本身的两个参数和用于生成的测试结果文件的两个参数。 用于test命令本身的参数列表如下 -bench regexp 只运行与正则表达式匹配的性能测试，默认不执行任何性能测试。 对于测试，正则表达式由斜杠（/）字符拆分为正则表达式序列 要运行所有的性能测试, 使用 '-bench .' 或 '-bench=.'. -benchtime t Run enough iterations of each benchmark to take t, specified as a time.Duration (for example, -benchtime 1h30s). The default is 1 second (1s). The special syntax Nx means to run the benchmark N times (for example, -benchtime 100x). -count n 运行每个测试和性能测试n次（默认1次） 如果设置了 -cpu 参数, 为每个 GOMAXPROCS 值运行 n 次 -cover 启用测试覆盖率分析。这里要注意，测试覆盖率分析是通过在编译前注释源码来实现的，因此，出现错误时报告的行 号可能不对应。 -covermode set,count,atomic 为正在测试的包设置测试覆盖率分析的模式。 默认为 \"set\" 启用了 -race 则为 \"atomic\". 各模式说明： set: bool: 这个声明运行了吗 count: int: 这个声明运行了多少次 atomic: int: count, but correct in multithreaded tests; significantly more expensive. 需要设置 -cover -coverpkg pattern1,pattern2,pattern3 在每个测试中对与模式匹配的包应用测试覆盖率分析。默认情况下，每个测试只分析正在测试的包。 运行 'go help packages' 可获得包模式的说明 需要设置 -cover -cpu 1,2,4 指定应为其执行测试或性能测试的GOMAXPROCS值的列表。默认值是GOMAXPROCS的当前值。 -failfast 第一次测试失败后不开启新的测试 -list regexp 列出与正则表达式匹配的测试、性能测试或示例测试。 但不会运行任何测试、性能测试或示例测试。 只列出顶级测试。不会显示子测试或子性能测试。 -parallel n 允许调用t.parallel的测试函数并行执行。 n是要同时运行的最大测试数；默认设置为GOMAXPROCS的值。 该参数只适用于单个测试二进制文件。 并行测试不同的package参加 'go help build' 命令的说明 -run regexp 仅运行与正则表达式匹配的那些测试和示例测试。 对于测试，正则表达式由斜杠（/）字符拆分为正则表达式序列 -short 测试长时间运行时声明需要缩短时间，默认关闭。 -timeout d 如果测试文件的运行时间长于 d, panic。 如果d为 0, 未超时。 默认为 10 分钟 (10m). -v 详细输出：记录所有运行的测试。即使测试成功，也打印日志。 -vet list 在“go test”期间配置“go vet”的调用，从而使用以逗号分隔的vet检查列表。 如果list为空，则“go test”运行“go vet”，其中列出了一系列被认为值得解决的检查。 如果list是“off”，则“go test”根本不会运行“go vet”。 用于生成的测试结果文件的参数列表如下 -benchmem 打印性能测试的内存分配统计信息 -blockprofile block.out Write a goroutine blocking profile to the specified file when all tests are complete. Writes test binary as -c would. -blockprofilerate n Control the detail provided in goroutine blocking profiles by calling runtime.SetBlockProfileRate with n. See 'go doc runtime.SetBlockProfileRate'. The profiler aims to sample, on average, one blocking event every n nanoseconds the program spends blocked. By default, if -test.blockprofile is set without this flag, all blocking events are recorded, equivalent to -test.","date":"2019-12-22","objectID":"/2019/golang-syntax-12-test/:0:0","tags":["Go语法"],"title":"Golang语法基础12-测试","uri":"/2019/golang-syntax-12-test/"},{"categories":["Golang学习之路"],"content":"Go中有两套错误处理的方式 普通错误： 在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 ，如果返回nil，表示没有错误 异常：使用panic和recover 主调函数总是应该检查收到的错误，不要忽略，否则可能导致严重的后果。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:0:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1. 普通错误 Go有一个预定义的error接口类型 type error interface { Error() string } errors包中有一个errorString结构体实现了该接口，其实 errors 包实现很简单，如下 package errors // New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1.1 定义错误 当我们需要一个新的错误类型，可以使用errors包的errors.New函数接收合适的信息来创建，如下例 err := errors.New(\"math - square root of negative number\") 从上面的实现中可以看到调用 errors.New 其实就是将传入的字符串给了结构体 errorString，由于该结构体实现了 error 接口，因此 New 函数返回的时候将结构体赋给了一个 error 接口变量，所以以后我们在主调函数输出该返回值时，会输出结构体的值。 拿一个计算平方根的函数举例，可以这样使用 func Sqrt(f float64) (float64, error) { if f \u003c 0 { return 0, errors.New(\"math - square root of negative number\") } //implementation of Sqrt } 然后像下面这样调用Sqrt函数 if f, err := Sqrt(-1); err != nil { fmt.Printf(\"Error: %s\\n\", err) } 使用fmt.Printf将错误信息打印出来，定义的错误信息通过会有像Error:这样的前缀，所以错误信息的内容不要以大写字母开头，如上例中使用math而不是Math 大部分情况自定义错误类型都是很有用的方法，可以将底层错误信息之外的其它有用信息打印出来。如果有不同的错误条件，就可以用类型断言判断错误场景，并做一些补救和恢复 switch err := err.(type) { case ParseError: PrintParseError(err) case PathError: PrintPathError(err) ... default: fmt.Printf(\"Not a special error, just %s\\n\", err) } 包也可以用额外的方法定义特定的错误，如net.Error: package net type Error interface { Timeout() bool // Is the error a timeout? Temporary() bool // Is the error temporary? } 如前所述，所有的例子都遵循同一种命名规范： 错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:1","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"1.2 输出更多的错误信息 fmt.Errorf()是一个常用的fmt包的函数，用于输出更多的错误信息，而不是单单一个字符串。如前面平方根的例子 if f \u003c 0 { return 0, fmt.Errorf(\"math: squre root of negative number %g\", f) } 实际上，fmt.Errorf和errors.New一样都返回error类型的变量 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:1:2","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2. 异常 或者称为运行时异常，指的是那些无法预测的错误。比如数组下标越界或类型断言失败，就会触发异常，并且伴随着程序终止返回一个runtime.Error接口类型的值，这个值和普通错误的区别在于有一个RuntimeError()方法 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.1 panic panic就是Go中用于生成异常的方法。当错误不可修复、程序无法继续运行时，使用panic函数来产生一个中止程序的运行时错误，panic接收任意类型的参数，通常是字符串，这个参数会在程序终止时被打印出来。中止程序和打印参数的过程由Go runtime负责。一个例子如下 package main import \"fmt\" func main() { fmt.Println(\"Starting the program\") panic(\"A severe error occurred: stopping the program!\") fmt.Println(\"Ending the program\") } 输出如下 Starting the program panic: A severe error occurred: stopping the program! goroutine 1 [running]: main.main() F:/Gotest/main.go:7 +0x9c exit status 2 一个检测到错误然后使用panic抛出异常的完整例子如下 if err != nil { panic(\"ERROR occurred:\" + err.Error()) } 但panic抛出异常并中止程序是最后的办法，如果有修复的可能就不应该使用 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:1","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.2 panicking 在多层嵌套的函数调用中使用panic，可以马上中止当前函数的执行，所有的defer语句都会保证执行并把控制权交还给接收到panic的函数调用者。这样向上冒泡直到最顶层，并执行（每层的）defer，在栈顶处程序崩溃，并在命令行中用传给panic的值报告错误情况：这个终止的过程就是panicking。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:2","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"2.3 recover revocer函数用于让程序从panicking重新获得控制权，停止终止过程进而恢复正常执行，但recover只能在defer修饰的函数中使用。如果正常执行，调用recover会返回nil，没有其它效果。 简而言之，panicking有两个结果，一个是程序终止，一个是遇到defer修饰的recover()函数然后恢复。一个例子如下 func protect(g func()) { defer func() { log.Println(\"done\") // Println executes normally even if there is a panic if err := recover(); err != nil { log.Printf(\"run time panic: %v\", err) } }() log.Println(\"start\") g() // possible runtime-error } 将panic，defer和recover结合的完整例子如下 package main import ( \"fmt\" ) func badCall() { panic(\"bad end\") } func test() { defer func() { if e := recover(); e != nil { fmt.Printf(\"Panicing %s\\r\\n\", e) } }() badCall() fmt.Printf(\"After bad call\\r\\n\") // \u003c-- wordt niet bereikt } func main() { fmt.Printf(\"Calling test\\r\\n\") test() fmt.Printf(\"Test completed\\r\\n\") } 输出 Calling test Panicing bad end Test completed ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:2:3","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"3. 错误处理的一些原则 这是在编写自己的包时需要遵循的一些原则，有助于别人调用和程序正常运行 在包内部，总是在panic后使用recover，不要让panic返回的层次超出当前包的范围 向包的调用者返回错误值，而不是panic 在包内部的不可导出函数中有深层次调用时，将panic转换成error来通知调用者出错信息 根据此原则，一个parse包如下，作用是把输入的字符串解析为整数切片 package parse import ( \"fmt\" \"strings\" \"strconv\" ) // A ParseError indicates an error in converting a word into an integer. type ParseError struct { Index int // The index into the space-separated list of words. Word string // The word that generated the parse error. Err error // The raw error that precipitated this error, if any. } // String returns a human-readable error message. func (e *ParseError) String() string { return fmt.Sprintf(\"pkg parse: error parsing %q as int\", e.Word) } // Parse parses the space-separated words in in put as integers. func Parse(input string) (numbers []int, err error) { defer func() { if r := recover(); r != nil { var ok bool err, ok = r.(error) if !ok { err = fmt.Errorf(\"pkg: %v\", r) } } }() fields := strings.Fields(input) numbers = fields2numbers(fields) return } func fields2numbers(fields []string) (numbers []int) { if len(fields) == 0 { panic(\"no words to parse\") } for idx, field := range fields { num, err := strconv.Atoi(field) if err != nil { panic(\u0026ParseError{idx, field, err}) } numbers = append(numbers, num) } return } 该包定义了自己的ParseError，当没有东西需要转换或转换成整数失败时，产生panic，但可导出的Parse函数会从panic中recover并整合信息返回一个错误给调用者。 一个调用parse包的实例如下 package main import ( \"fmt\" \"./parse/parse\" ) func main() { var examples = []string{ \"1 2 3 4 5\", \"100 50 25 12.5 6.25\", \"2 + 2 = 4\", \"1st class\", \"\", } for _, ex := range examples { fmt.Printf(\"Parsing %q:\\n \", ex) nums, err := parse.Parse(ex) if err != nil { fmt.Println(err) // here String() method from ParseError is used continue } fmt.Println(nums) } } 输出 Parsing \"1 2 3 4 5\": [1 2 3 4 5] Parsing \"100 50 25 12.5 6.25\": pkg: pkg parse: error parsing \"12.5\" as int Parsing \"2 + 2 = 4\": pkg: pkg parse: error parsing \"+\" as int Parsing \"1st class\": pkg: pkg parse: error parsing \"1st\" as int Parsing \"\": pkg: no words to parse ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:3:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"4. 闭包处理错误 根据上面的原则，只要有函数返回，就应该检查是否有错误发生，但这会导致重复乏味的代码。结合 defer/panic/recover 机制和闭包可以得到一种更加优雅的写法。不过这种写法的限制是所有函数都需要是同一种签名。 假设所有函数签名都是下面这种形式 func f(a type1, b type2) 参数的数量和类型是不相关的，我们给这个类型一个名字： fType1 = func f(a type1, b type2) 使用两个辅助函数帮忙完成整个过程 check：用来检查是否有错误和panic发生的函数 func check(err error) { if err != nil { panic(err) } } errorhandler：接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数, 其中包含有 defer/recover 机制 func errorHandler(fn fType1) fType1 { return func(a type1, b type2) { defer func() { if err, ok := recover().(error); ok { log.Printf(“run time panic: %v”, err) } }() fn(a, b) } } 当错误发生时会 recover 并打印在日志中，check() 函数会在所有的被调函数中调用，像这样： ```go func f1(a type1, b type2) { f, _, err := // call function/method check(err) t, err := // call function/method check(err) _, err2 := // call function/method check(err2) } 通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 check(err) 即可。在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值。 最最重要的一点，Goroutine 中抛出的异常，只能在本协程中使用 recover 捕获，主协程是无法接收到的，同时，子协程发生的 panic 如果没有被捕获，会导致整个程序中断。 ","date":"2019-12-20","objectID":"/2019/golang-syntax-11-error-and-panic/:4:0","tags":["Go语法"],"title":"Golang语法基础11-错误处理","uri":"/2019/golang-syntax-11-error-and-panic/"},{"categories":["Golang学习之路"],"content":"首先来回顾在操作系统中学过的一些概念。进程(processes)是程序执行的基本单位，运行在一个独立的内存地址空间中；一个进程由多个线程(threads)组成，线程的存在是为了能够同时执行多个任务，最大化利用时间，防止产生等待，线程间是共享内存地址空间的。从windows资源管理器看这一点能看的很明白，如下，每个应用程序是一个进程，Typora程序下有两个线程在同时运行。 并发是建立在多线程之上的概念，将CPU的执行时间划分为许多很小的间隔，多个线程不断地切换执行，从上层看起来就像在同时执行一样，但本质上依然是线性的。并行则是程序在某个特定的事件同时运行在多个CPU上，多核处理器为并行提供了可能。因此，并发也可能是并行的。 操作系统课程中一个最主要的问题就是多线程对共享内存空间的访问，我们学到的解决方式是通过加互斥锁来实现，但在设计实现上是一个复杂的过程，非常容易出错，鉴于操作系统考试的惨痛经历，现在完全不想回忆。Go中的标准库sync中有一些工具可以用来实现互斥锁的相关操作，但它显然没有Go自身支持的Goroutines高效。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:0:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"1. Goroutines Go原生支持并发，依靠的是协程(goroutine)和通道(channel)两个概念。goroutines的概念是为了和processes、threads、coroutines等概念区别。其中coroutines也叫做协程，而且这才是常规意义下的协程，goroutines只在Go中有效。 coroutines是比线程更轻的一个概念，只使用很少的内存和资源。它对栈进行分隔，从而动态地增加或缩减内存的使用，栈的管理也是自动的，在协程退出后自动释放空间。协程可以运行在多个线程间，也可以运行在线程内，它的创建廉价到可以在同一地址空间存在100000个。这一概念也存在于其它语言(C#, Java等)中，它与goroutines的区别在于： Go协程意味着并行(或者可以以并行的方式部署)，协程一般不是 Go协程通过通道来通信，协程则通过让出与恢复操作来通信 理论上，Go协程比协程更加强大。 以一个简单模型来描述goroutine：它是一个和其它协程在同一地址空间并发执行的函数。通过在函数或方法名前加上go关键字来创建和运行一个协程，运行结束后安静的退出(没有任何返回值)。 go list.Sort() //并行的运行list.Sort，不等待 Go程序中必须含有的main()函数可以看作一个协程，尽管它没有通过go关键字启动，在程序初始化的过程中(init()函数运行)，goroutine也可以运行。 单纯的结束协程的概念是不够具体的，协程需要和通道来配合 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:1:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2. Channel 并发编程的困难之处在于实现对共享变量的正确访问，互斥量的方式是复杂的，Go鼓励采用一种不同的方法，即在通道(channel)上传递共享值，如同Unix管道一般，通道用于发送类型化的数据，在任何给定的时间，只有一个协程可以对通道中的数据进行访问，从而完成协程间的通信，也避开了所有由共享内存导致的陷阱。这种通过通道进行通信的方式保证同步性的同时，数据的所有权也因此被传递。 这一设计理念最终简化为一句话：不要通过共享内存来通信，而通过通信来共享内存。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.1 声明与初始化 声明通道的基本形式如下，未初始化的通道值为nil var identifier chan datatype 通道只能传输一种类型的数据，比如chan int或chan string，可以是任意类型，包括空接口interface{}和通道自己 和map相同，通道也是引用类型，因此使用make进行初始化，可以指定第二个参数用来指定缓冲区的大小，即通道可容纳的数据个数，这一个值默认是0，意思是无缓冲，无缓冲的通道将通信、值的交换、同步三者结合，保证两个协程的计算处于已知状态。 var ci chan string ci = make(chan string) // unbuffered channel of integers cj := make(chan int, 0) // unbuffered channel of integers cs := make(chan *os.File, 100) // buffered channel of pointers to Files ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:1","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.2 通信操作符\u003c- 这一操作符直观的表示数据的传输：信息按照箭头方向流动。 流向通道(发送)用ch \u003c- int1表示，意为利用通道ch发送变量int1 从通道流出(接收)用int2 = \u003c- ch表示，意为变量int2从通道ch接收数据，如果int2没有声明过，可以使用int2 := \u003c- ch \u003c- ch则用于表示丢弃当前值，获取通道的下一个值，可以用来验证，如 if \u003c- ch != 1000 { ... } 为了可读性通道的命名通常以 ch 开头或者包含 chan。通道的发送和接收都是原子操作，总是互不干扰的完成。下面的示例展示了通信操作符的使用。 package main import ( \"fmt\" \"time\" ) func main() { ch := make(chan string) go sendData(ch) go getData(ch) time.Sleep(1e9) } func sendData(ch chan string) { ch \u003c- \"Washington\" ch \u003c- \"Tripoli\" ch \u003c- \"London\" ch \u003c- \"Beijing\" ch \u003c- \"Tokyo\" } func getData(ch chan string) { var input string // time.Sleep(2e9) for { input = \u003c-ch fmt.Printf(\"%s \", input) } } //Output: Washington Tripoli London Beijing tokyo 如果2个协程需要通信，必须给它们同一个通道作为参数。上例中 main() 函数中启动了两个协程：sendData() 通过通道 ch 发送了 5 个字符串，getData() 按顺序接收它们并打印出来。 一些同步的细节如下： main() 等待了 1 秒让两个协程完成，如果不这样(注释掉time.Sleep(1e9))，sendData() 就没有机会输出。 getData() 使用了无限循环：它随着 sendData() 的发送完成和 ch 变空也结束了。 如果我们移除一个或所有 go 关键字，程序无法运行，Go 运行时会抛出 panic。这是因为运行时(runtime)会检查所有的协程是否在等待什么东西(从通道读取或写入某个通道)，这意味着陷入死锁，程序无法继续执行。 通道的发送和接收顺序是无法预知的，如果使用打印状态来输出，由于两者间的时间延迟，打印的顺序和真实发生的顺序是不同的。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:2","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.3 通道阻塞 前面提到默认情况下通信是同步且无缓冲的，因此通道的发送/接收操作在对方准备好之前是阻塞的。 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据 对于同一个通道，接收操作在发送者可用之前是阻塞的（协程或函数中的） 下例中的协程在无限循环中不断地给通道发送数据，但由于没有接收者，只输出了数字0 package main import \"fmt\" func main() { ch1 := make(chan int) go pump(ch1) // pump hangs fmt.Println(\u003c-ch1) // prints only 0 } func pump(ch chan int) { for i := 0; ; i++ { ch \u003c- i } } //Output:0 定义一个新的协程用来接收通道值可以持续输出 package main import \"fmt\" func main() { ch1 := make(chan int) go pump(ch1) go suck(ch1) time.Sleep(1e9) } func pump(ch chan int) { for i := 0; ; i++ { ch \u003c- i } } func suck(ch chan int) { for { fmt.Println(\u003c-ch) } } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:3","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.4 信号量模式 信号量模式的意思是利用通道阻塞特性，等待所有计算完成后才让程序退出，用于并行执行函数或for循环，加快程序执行速度，一个例子瑞小安 type Empty interface {} var empty Empty ... data := make([]float64, N) res := make([]float64, N) sem := make(chan Empty, N) ... for i, xi := range data { go func (i int, xi float64) { res[i] = doSomething(i, xi) sem \u003c- empty } (i, xi) } // wait for goroutines to finish for i := 0; i \u003c N; i++ { \u003c-sem } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:4","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.5 通道工厂 编程时常用一种通道工厂的模式，即不将通道作为参数传递给协程，而是用函数来生成一个通道并返回 package main import ( \"fmt\" \"time\" ) func main() { stream := pump() go suck(stream) time.Sleep(1e9) } func pump() chan int { ch := make(chan int) go func() { for i := 0; ; i++ { ch \u003c- i } }() return ch } func suck(ch chan int) { for { fmt.Println(\u003c-ch) } } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:5","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.6 给通道使用for循环 for 循环的 range 语句可以用在通道 ch 上，便可以从通道中获取值，像这样： for v := range ch { fmt.Printf(\"The value is %v\\n\", v) } 这样的使用依然必须和通道的写入和关闭相配合， 不能单独存在 package main import ( \"fmt\" \"time\" ) func main() { suck(pump()) time.Sleep(1e9) } func pump() chan int { ch := make(chan int) go func() { for i := 0; ; i++ { ch \u003c- i } }() return ch } func suck(ch chan int) { go func() { for v := range ch { fmt.Println(v) } }() } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:6","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"2.7 关闭通道 通道可以被显式的关闭，不过只有发送者才需要关闭通道，接收者永远不需要。 ch := make(chan float64) defer close(ch) 测试通道是否关闭则可以使用ok操作符 v, ok := \u003c-ch // ok is true if v received value 一个完整的例子如下 package main import \"fmt\" func main() { ch := make(chan string) go sendData(ch) getData(ch) } func sendData(ch chan string) { ch \u003c- \"Washington\" ch \u003c- \"Tripoli\" ch \u003c- \"London\" ch \u003c- \"Beijing\" ch \u003c- \"Tokio\" close(ch) } func getData(ch chan string) { for { input, open := \u003c-ch if !open { break } fmt.Printf(\"%s \", input) } } 但是使用for-range读取通道是更好的办法，因为这会自动检测通道是否关闭 for input := range ch { process(input) } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:2:7","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"3. Select 从不同的并发执行的协程中获取值可以通过关键字select来完成，它和switch控制语句非常相似，其行为像是“你准备好了吗”的轮询机制；select监听进入通道的数据，也可以是用通道发送值的时候。 select { case u:= \u003c- ch1: ... case v:= \u003c- ch2: ... ... default: // no value ready to be received ... } select 做的事情是：选择处理列出的多个通信情况中的一个。 如果都阻塞了，会等待直到其中一个可以处理 如果多个可以处理，随机选择一个 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。 使用default可以保证发送不被阻塞，但没有default的监听模式也可能被使用，通过break语句退出循环。一个完整的例子如下 package main import ( \"fmt\" \"time\" ) func main() { ch1 := make(chan int) ch2 := make(chan int) go pump1(ch1) go pump2(ch2) go suck(ch1, ch2) time.Sleep(1e9) } func pump1(ch chan int) { for i := 0; ; i++ { ch \u003c- i * 2 } } func pump2(ch chan int) { for i := 0; ; i++ { ch \u003c- i + 5 } } func suck(ch1, ch2 chan int) { for { select { case v := \u003c-ch1: fmt.Printf(\"Received on channel 1: %d\\n\", v) case v := \u003c-ch2: fmt.Printf(\"Received on channel 2: %d\\n\", v) } } } 有 2 个通道 ch1 和 ch2，三个协程 pump1()、pump2() 和 suck()。在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也在无限循环中轮询输入，通过 select 语句获取 ch1 和 ch2 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:3:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4. 应用 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:0","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.1 惰性生成器 生成器是指当被调用时返回一个序列中下一个值的函数，例如： generateInteger() =\u003e 0 generateInteger() =\u003e 1 generateInteger() =\u003e 2 .... 生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和cpu）：这是一项在需要时对表达式进行求值的技术。例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和go协程的函数能轻易实现这个需求。 下例中实现了一个使用 int 型通道来实现的生成器。通道被命名为yield和resume，这些词经常在协程代码中使用。 package main import ( \"fmt\" ) var resume chan int func integers() chan int { yield := make(chan int) count := 0 go func() { for { yield \u003c- count count++ } }() return yield } func generateInteger() int { return \u003c-resume } func main() { resume = integers() fmt.Println(generateInteger()) //=\u003e 0 fmt.Println(generateInteger()) //=\u003e 1 fmt.Println(generateInteger()) //=\u003e 2 } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:1","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.2 Futures 模式 所谓Futures就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。 Futures模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于Futures需要返回一个值。 一个例子： 假设我们有一个矩阵类型，我们需要计算两个矩阵A和B乘积的逆，首先我们通过函数Inverse(M)分别对其进行求逆运算，再将结果相乘。如下函数InverseProduct()实现了如上过程： func InverseProduct(a Matrix, b Matrix) { a_inv := Inverse(a) b_inv := Inverse(b) return Product(a_inv, b_inv) } 在这里例子中，a和b的求逆句子的过程可以同时进行，因此换用并行计算方式如下： func InverseProduct(a Matrix, b Matrix) { a_inv_future := InverseFuture(a) // start as a goroutine b_inv_future := InverseFuture(b) // start as a goroutine a_inv := \u003c-a_inv_future b_inv := \u003c-b_inv_future return Product(a_inv, b_inv) } InverseFuture函数以goroutine的形式起了一个闭包，该闭包会将矩阵求逆结果放入到future通道中： func InverseFuture(a Matrix) chan Matrix { future := make(chan Matrix) go func() { future \u003c- Inverse(a) }() return future } 对计算密集型的场景，使用Futures模式是很有意义的 ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:2","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"4.3 C/S模式 客户端/服务器(C/S)模式是goroutines和channels最常见的应用。 客户端(Client)可以是运行在任意设备上的任意程序，它会按需发送请求(request)至服务器。服务器(Server)接收到这个请求后开始相应的工作，然后再将响应(response)返回给客户端。典型情况下一般是多个客户端（即多个请求）对应一个（或少量）服务器。例如我们日常使用的浏览器客户端，其功能就是向服务器请求网页。而Web服务器则会向浏览器响应网页数据。 使用Go的服务器通常会在协程中执行向客户端的响应，故而会对每一个客户端请求启动一个协程。一个常用的操作方法是客户端请求自身中包含一个通道，而服务器则向这个通道发送响应。 下面是请求Request的结构，响应暗含在请求的结构里面 type Request struct { a, b int replyc chan int // reply channel inside the Request } 服务器无限循环从chan *Request接收请求，为了避免某个请求长时间操作造成堵塞，为每个请求启动一个协程，然后启动run()函数处理该请求，处理后的值送到chan *Reply通道。 func server(op binOp, service chan *Request) { for { req := \u003c-service; // requests arrive here // start goroutine for request: go run(op, req); // don’t wait for op to complete } } type binOp func(a, b int) int func run(op binOp, req *Request) { req.replyc \u003c- op(req.a, req.b) } 但以上过程仅仅是对客户端的请求是并发处理的，实际上，server本身也是以协程方式启动的 func startServer(op binOp) chan *Request { reqChan := make(chan *Request); go server(op, reqChan); return reqChan; } startServer会在main函数中被调用，下面是main函数调用示例，一共发送了100个请求到服务器进行处理， 只有它们全部被送达后我们才会按相反的顺序检查响应： func main() { adder := startServer(func(a, b int) int { return a + b }) const N = 100 var reqs [N]Request for i := 0; i \u003c N; i++ { req := \u0026reqs[i] req.a = i req.b = i + N req.replyc = make(chan int) adder \u003c- req // adder is a channel of requests } // checks: for i := N - 1; i \u003e= 0; i-- { // doesn’t matter what order if \u003c-reqs[i].replyc != N+2*i { fmt.Println(“fail at”, i) } else { fmt.Println(“Request “, i, “is ok!”) } } fmt.Println(“done”) } //Output: Request 99 is ok! Request 98 is ok! ... Request 1 is ok! Request 0 is ok! done 完整的程序如下，因为server在main函数返回后是被强制结束的，下面还针对这一点做出改进，方法是提供一个退出通道给server package main import \"fmt\" type Request struct { a, b int replyc chan int // reply channel inside the Request } type binOp func(a, b int) int func run(op binOp, req *Request) { req.replyc \u003c- op(req.a, req.b) } func server(op binOp, service chan *Request, quit chan bool) { for { select { case req := \u003c-service: go run(op, req) case \u003c-quit: return } } } func startServer(op binOp) (service chan *Request, quit chan bool) { service = make(chan *Request) quit = make(chan bool) go server(op, service, quit) return service, quit } func main() { adder, quit := startServer(func(a, b int) int { return a + b }) const N = 100 var reqs [N]Request for i := 0; i \u003c N; i++ { req := \u0026reqs[i] req.a = i req.b = i + N req.replyc = make(chan int) adder \u003c- req } // checks: for i := N - 1; i \u003e= 0; i-- { // doesn't matter what order if \u003c-reqs[i].replyc != N+2*i { fmt.Println(\"fail at\", i) } else { fmt.Println(\"Request \", i, \" is ok!\") } } quit \u003c- true fmt.Println(\"done\") } ","date":"2019-12-16","objectID":"/2019/golang-syntax-10-goroutine-and-channel/:4:3","tags":["Go语法"],"title":"Golang语法基础10-协程与通道","uri":"/2019/golang-syntax-10-goroutine-and-channel/"},{"categories":["Golang学习之路"],"content":"结构体是一种非常重要的结构，用到的地方非常多，在 Go 中，结构体还是实现面向对象编程的基础。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:0:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1. 结构体 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.1 定义与初始化 结构体定义方式如下： type identifier struct { field1 type1 field2 type2 ... } 大括号中的每一行称为一个字段，每个字段都有一个类型和一个名字，在一个结构体中，字段名必须是唯一的。结构体名和字段名的命名遵循可见性规则，即使用首字母的大小写来表示可导出和不可导出。但是需要注意，一个可导出的结构体类型中可以存在不可导出的字段。 结构体的字段可以是任意类型，甚至可以是结构体本身、函数或者接口。一个简单的结构体定义示例如下 type T struct { a,b int } 结构体是自定义数据类型，因此我们可以向基本数据类型一样声明/定义一个结构体类型的变量，声明时会分配内存并默认使用每个字段类型的零值来初始化。我们也可以手动初始化一个结构体，使用点号符给字段赋值，示例如下。另外，访问结构体内字段的值时同样使用点号符，这种使用点号符赋值和获取字段值的方式叫做选择器(selector)， var s T s.a = 5 s.b = 8 由于结构体也是值类型，使用new函数创建。注意，使用 new 得到的 t 是指向结构体的指针。 var t *T = new(T) t := new(T) // 简单方便地写法，最常用 至此我们注意到，使用结构体时我们可能遇到两种类型：结构体类型和结构体指针类型，这两种类型都可以通过选择器的方式来使用，如下，v.i 和 p.i 都可以得到正确的值，在理解的时候可以想象底层对结构体指针 p 自动做了解引用，如 (*p).i。 type myStruct struct { i int } var v myStruct // v是结构体类型变量 var p *myStruct // p是指向一个结构体类型变量的指针 v.i p.i (*p).i 除使用选择器初始化结构体字段外，一种更简短更常用的结构体初始化方法如下 ms := struct1{10, 15.5, \"Chris\"} //结构体类型 ms := \u0026struct1{10, 15.5, \"Chris\"} //结构体指针类型 ms := \u0026struct1{f1:15.5，i1:10} //括号内声明字段名，这样可以不按定义的字段顺序，甚至省略部分字段 其中第二行称为混合字面量语法，但底层仍然会调用new()，因此与使用 new() 初始化是等同的。以type Point struct {x,y int}为例，这几种初始化方式的内存布局如下 从上图可以看出，结构体和它包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套其它的结构体，同样如此。 type Rect1 struct {Min, Max Point } type Rect2 struct {Min, Max *Point } 一个使用结构体的完整例子如下 package main import \"fmt\" type struct1 struct { i1 int f1 float32 str string } func main() { ms := new(struct1) ms.i1 = 10 ms.f1 = 15.5 ms.str= \"Chris\" fmt.Printf(\"The int is: %d\\n\", ms.i1) fmt.Printf(\"The float is: %f\\n\", ms.f1) fmt.Printf(\"The string is: %s\\n\", ms.str) fmt.Println(ms) } //Output: The int is: 10 The float is: 15.500000 The string is: Chris \u0026{10 15.5 Chris} ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:1","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.2 结构体标签 实际上，一个完整的结构体定义，在字段名和类型外，还有一个标签(tag)部分。标签是一个字符串，用来对字段进行一定的说明，对程序功能没有太大的作用，因此前面才没有介绍。正如我们说的，它的主要作用就是对字段进行说明，标签只有包 reflect 能获取。 package main import ( \"fmt\" \"reflect\" ) type TagType struct { // tags field1 bool \"An important answer\" field2 string \"The name of the thing\" field3 int \"How much there are\" } func main() { tt := TagType{true, \"Barak Obama\", 1} for i := 0; i \u003c 3; i++ { refTag(tt, i) } } func refTag(tt TagType, ix int) { ttType := reflect.TypeOf(tt) ixField := ttType.Field(ix) fmt.Printf(\"%v\\n\", ixField.Tag) } //Output: An important answer The name of the thing How much there are ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:2","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.3 匿名字段与内嵌结构体 结构体的字段名其实和变量很相似，不需要时也可以用空白符 _ 代替，但实际上，也可以直接省略，即整个字段只有类型，此时类型就是字段名，这种字段叫做匿名字段。如下例，通过类型 t.float32 来获取存储在匿名字段中的数据，也因为这种调用方式，一个结构体中对每一种数据类型只能有一个匿名字段。 package main import \"fmt\" type T struct { a int float32 // anonymous field } func main() { t := T{6, 7.5} fmt.Println(t.float32) } //Output: {6 7.5} 由于结构体本身也是一种数据类型，因此也可以作为匿名字段使用，称为内嵌结构体。通过内嵌结构体可以实现 OO 编程种的继承。 package main import \"fmt\" type A struct { ax, ay int } type B struct { A bx, by float32 } func main() { b := B{A{1, 2}, 3.0, 4.0} fmt.Println(b.ax, b.ay, b.bx, b.by) fmt.Println(b.A) } //Output: 1 2 3 4 {1 2} 使用内嵌结构体的时候，很可能会出现命名冲突（继承来的字段名和当前结构体的某个字段名相同），这种情况下外层的名字会覆盖内层的名字，但两者的内存空间都会保留，下例中d.b的调用不会出错，指的是float32，而不是B.b，进行内层调用可以使用d.B.b type B struct {a, b int} type D struct {B; b float32} var d D 但下面这种情况，c.a的调用会导致编译器错误,只能由程序员手动修改 type A struct {a int} type B struct {a, b int} type C struct {A; B} var c C ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:3","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"1.4 结构体工厂 可以为结构体定义一个工厂来创建结构体实例，工厂的名字通常以new或New开头，这是一种很常用的方法。假设定义了如下File结构体类型 type File struct { fd int //文件描述符 name string //文件名 } 下面是为File结构体创建的工厂，返回一个指向结构体的指针 func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } return \u0026File{fd, name} } 然后这样调用它 f := NewFile(10, \"./test.txt\") 这种方式可以模拟OO编程中使用new的实例化，如果要完全等同，还需要利用可见性规则禁止使用Go内置的new()函数 type matrix struct { ... } func NewMatrix(params) *matrix { m := new(matrix) // 初始化 m return m } 然后在其它包里就只能使用工厂创建结构体实例 package main import \"matrix\" ... wrong := new(matrix.matrix) // 编译失败（matrix 是私有的） right := matrix.NewMatrix(...) // 实例化 matrix 的唯一方式 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:1:4","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2. 方法 Go中的方法是作用在接收者上的一个函数，接收者是某种类型的变量。定义方法的一般格式如下 func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... } 在func关键字之后，方法名之前的括号中声明接收者和接收者类型。同样还可以看到，方法的本质仍然是函数，只不过是针对特定变量的函数，除了括号中的接收者声明，其它部分和普通函数没有不同。 接收者几乎可以是任何类型的变量，包括基本数据类型、数组的别名类型、结构体、函数等，但不可以是接口，因为方法是需要实现的，而接口只是抽象定义。 如果接收者变量recv已经在其它地方进行了初始化，Method1是它的方法名，那么方法的调用格式为recv.Method1()，同结构体相似，如果recv是指针，调用时自动解引用。 如果方法不需要使用recv的值，可以用空白符_替换它 func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... } 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）。 一个接收者变量加上它的方法等价于面向对象中的一个类，区别只在于Go中方法的代码与变量定义是分离的，只要在同一个包中即可。 因为方法是函数，所以方法同样不允许重载，但不同的接收者变量可以有相同名字的方法，即使它们在同一个包中，一个例子如下 func (a *denseMatrix) Add(b Matrix) Matrix func (a *sparseMatrix) Add(b Matrix) Matrix 一个结构体方法的例子如下 package main import \"fmt\" type TwoInts struct { a int b int } func main() { two1 := new(TwoInts) two1.a = 12 two1.b = 10 fmt.Printf(\"The sum is: %d\\n\", two1.AddThem()) fmt.Printf(\"Add them to the param: %d\\n\", two1.AddToParam(20)) two2 := TwoInts{3, 4} fmt.Printf(\"The sum is: %d\\n\", two2.AddThem()) } func (tn *TwoInts) AddThem() int { return tn.a + tn.b } func (tn *TwoInts) AddToParam(param int) int { return tn.a + tn.b + param } //Output: The sum is: 22 Add them to the param: 42 The sum is: 7 一个非结构体类型(数组别名)方法的例子如下 package main import \"fmt\" type IntVector []int func (v IntVector) Sum() (s int) { for _, x := range v { s += x } return } func main() { fmt.Println(IntVector{1, 2, 3}.Sum()) // 输出是6 } 变量和定义在它上面的方法必须在同一个包里定义，如下例是错误的，这也是为什么不能定义int这样的基本类型的方法，但可以定义基本类型的别名的方法 package main import \"container/list\" func (p *list.List) Iter() { // ... } func main() { lst := new(list.List) for _= range lst.Iter() { } } ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:0","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.1 函数和方法的区别 函数将变量作为参数：Function1(recv) 方法在变量上被调用：recv.Method1() 在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。 不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called 接收者必须有一个显式的名字，这个名字必须在方法中被使用。 receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。 在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:1","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.2 指针或值作为接收者 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。一个例子如下 package main import ( \"fmt\" ) type B struct { thing int } func (b *B) change() { b.thing = 1 } func (b B) write() string { return fmt.Sprint(b) } func main() { var b1 B // b1是值 b1.change() fmt.Println(b1.write()) b2 := new(B) // b2是指针 b2.change() fmt.Println(b2.write()) } /* 输出： {1} {1} */ 指针方法和值方法都可以在指针或非指针上被调用，如上例，b1是值类型，而change()方法作用在指针类型上，b1.change()会被自动转换为(\u0026b1).change()；b2是指针类型，但write()方法是值类型，b2.write()会被自动转换成(*b2).write() ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:2","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.3 利用方法读取结构体中的未导出字段 本文开始对结构体的介绍中，提到结构体对外部可见，而结构体中的字段对外部不可见是可能发生的，对于这种情况，读取或修改结构体中的字段值可以通过作用在结构体上的方法完成，一个例子如下 package person type Person struct { firstName string lastName string } func (p *Person) FirstName() string { return p.firstName } func (p *Person) SetFirstName(newName string) { p.firstName = newName } 对其中定义的结构体字段进行调用 package main import ( \"./person\" \"fmt\" ) func main() { p := new(person.Person) // p.firstName undefined // (cannot refer to unexported field or method firstName) // p.firstName = \"Eric\" p.SetFirstName(\"Eric\") fmt.Println(p.FirstName()) // Output: Eric } ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:3","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.4 内嵌类型的方法与继承 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法 ， 这个机制提供了一种简单的方式来模拟面向对象语言中的子类和继承相关的效果。一个示例如下 package main import ( \"fmt\" \"math\" ) type Point struct { x, y float64 } func (p *Point) Abs() float64 { return math.Sqrt(p.x*p.x + p.y*p.y) } type NamedPoint struct { Point name string } func main() { n := \u0026NamedPoint{Point{3, 4}, \"Pythagoras\"} fmt.Println(n.Abs()) // 打印5 } 使用同名方法可以覆盖父类型中的方法，比如在上例中添加如下代码，会打印100 func (n *NamedPoint) Abs() float64 { return n.Point.Abs() * 100. } 因为一个结构体可以嵌入多个匿名类型，所以实际上可以实现简单的多重继承，如下例所示 package main import ( \"fmt\" ) type Camera struct{} func (c *Camera) TakeAPicture() string { return \"Click\" } type Phone struct{} func (p *Phone) Call() string { return \"Ring Ring\" } type CameraPhone struct { Camera Phone } func main() { cp := new(CameraPhone) fmt.Println(\"Our new CameraPhone exhibits multiple behaviors...\") fmt.Println(\"It exhibits behavior of a Camera: \", cp.TakeAPicture()) fmt.Println(\"It works like a Phone too: \", cp.Call()) } //Output: Our new CameraPhone exhibits multiple behaviors... It exhibits behavior of a Camera: Click It works like a Phone too: Ring Ring ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:4","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"2.5 在类型中嵌入功能 主要有两种方法来实现在类型中嵌入功能： A：聚合（或组合）：包含一个所需功能类型的具名字段。 B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。 假设有一个 Customer 类型，我们想让它通过 Log 类型来包含日志功能，Log 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 Log 类型，然后将它作为特定类型的一个字段，并提供 Log()，它返回这个日志的引用。 使用聚合方式实现如下 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string log *Log } func main() { c := new(Customer) c.Name = \"Barak Obama\" c.log = new(Log) c.log.msg = \"1 - Yes we can!\" // shorter c = \u0026Customer{\"Barak Obama\", \u0026Log{\"1 - Yes we can!\"}} // fmt.Println(c) \u0026{Barak Obama 1 - Yes we can!} c.Log().Add(\"2 - After me the world will be a better place!\") //fmt.Println(c.log) fmt.Println(c.Log()) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) Log() *Log { return c.log } //Output: 1 - Yes we can! 2 - After me the world will be a better place! 使用内嵌方式实现如下 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string Log } func main() { c := \u0026Customer{\"Barak Obama\", Log{\"1 - Yes we can!\"}} c.Add(\"2 - After me the world will be a better place!\") fmt.Println(c) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) String() string { return c.Name + \"\\nLog:\" + fmt.Sprintln(c.Log) } //Output: Barak Obama Log:{1 - Yes we can! 2 - After me the world will be a better place!} 内嵌的类型不需要指针，Customer 也不需要 Add 方法，它使用 Log 的 Add 方法，Customer 有自己的 String 方法，并且在它里面调用了 Log 的 String 方法。 如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。 因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-8-struct-and-method/:2:5","tags":["Go语法"],"title":"Golang语法基础8-结构体与方法","uri":"/2019/golang-syntax-8-struct-and-method/"},{"categories":["Golang学习之路"],"content":"本篇介绍 Golang 中的接口与反射。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:0:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1. 接口 类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集，我们可以使用接口来定义方法集，但是这种定义是抽象的，不包含方法的代码实现，接口中也不能包含变量。 接口定义的基本格式如下 type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ... } ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.1 接口理解 接口可以是空的，也就是不包含任何方法，空接口的底层实现是一个名为 eface 的结构体 type eface struct { _type *_type data unsafe.Pointer } type _type struct { size uintptr // type size ptrdata uintptr // size of memory prefix holding all pointers hash uint32 // hash of type; avoids computation in hash tables tflag tflag // extra type information flags align uint8 // alignment of variable with this type fieldalign uint8 // alignment of struct field with this type kind uint8 // enumeration for C alg *typeAlg // algorithm table gcdata *byte // garbage collection data str nameOff // string form ptrToThis typeOff // type for pointer to this type, may be zero } 非空接口的底层实现与空接口不同，是一个名为 iface 的结构体，非空接口中定义的方法的具体实现都放在 itab.fun 变量中 type iface struct { tab *itab data unsafe.Pointer } // layout of Itab known to compilers // allocated in non-garbage-collected memory // Needs to be in sync with // ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs. type itab struct { inter *interfacetype _type *_type link *itab bad int32 inhash int32 // has this itab been added to hash? fun [1]uintptr // variable sized } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type imethod struct { //这里的 method 只是一种函数声明的抽象，比如 func Print() error name nameOff ityp typeOff } itab 可以简单理解为 接口类型+具体类型，interfacetype 是接口类型，包含包路径、方法等信息。_type 则是具体类型，空接口也包含这个字段。 关于接口值的理解是一件很重要的事，但是比较复杂。我们通过了解接口的内存布局来理解接口的本质，从而理解接口值。先看一个例子 type Stringer interface { String() string } type Binary uint64 func (i Binary) String() string { return strconv.Uitob64(i.Get(), 2) } func (i Binary) Get() uint64 { return uint64(i) } func main() { b := Binary{} s := Stringer(b) fmt.Print(s.String()) } 对比非空接口的底层实现，发现接口在内存中实际上由两个成员组成，如下图，tab 指向虚表，data 指向实际引用的数据 虚表描绘了实际的类型信息及接口的方法集，具体有哪些部分我们以及从 itab 结构体中看到了。注意在这里是 Stringer 接口的函数指针列表，而不是实际类型 Binary 的函数指针列表，只有在运行时遇到 s := Stringer(b) 这样的语句，才会生成接口对应的 Binary 类型的虚表。这样，当判定一种类型是否满足某个接口时，只需要判断类型的方法集是否完全包含接口的方法集即可。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.2 接口值 我们可以将一个变量声明为接口类型，var ai Namer，未初始化时，接口值为 nil。 type Shape interface { Area() float32 } func main() { var s Shape fmt.Println(\"value of s is\", s) fmt.Printf(\"type of s is %T\\n\", s) } //Output: value of s is \u003cnil\u003e type of s is \u003cnil\u003e 我们可以理解接口变量的值为 nil，那么为什么类型也是 nil 呢？上一小节我们理解接口的时候知道，接口其实就是定义在结构体中的两个指针，未初始化时这两个指针都是 nil，因此接口值是 nil，接口类型也是nil。 当我们初始化接口变量后，两个指针都有了具体指向的值，此时接口的值就是接口指向的类型的值，接口的类型就是实现了接口的变量类型。如下例，变量 i 本身是接口类型 Namer，先后指向实现了接口类型的 St1 和 St2 两个空结构体，其值和类型就发生了变化。 type Namer interface { Name() } type St1 struct { a int } func (st1 St1) Name() { fmt.Println(st1.a) } type St2 struct{} func (St2) Name() {} func main() { var i Namer = St1{2} fmt.Printf(\"type is %T\\n\", i) fmt.Printf(\"value is %v\\n\", i) i = St2{} fmt.Printf(\"type is %T\\n\", i) fmt.Printf(\"value is %v\\n\", i) } //Output: type is main.St1 value is {2} type is main.St2 value is {} ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.3 接口的实现 接口的实现是一种隐式的实现，只要某个类型的方法集完全包含接口的方法集，就属于实现了该接口，实现了接口的变量可以赋值给接口值。 package main import \"fmt\" type Shaper interface { Area() float32 } type Square struct { side float32 } func (sq *Square) Area() float32 { return sq.side * sq.side } func main() { sq1 := new(Square) sq1.side = 5 var areaIntf Shaper areaIntf = sq1 // shorter,without separate declaration: // areaIntf := Shaper(sq1) // or even: // areaIntf := sq1 fmt.Printf(\"The square has area: %f\\n\", areaIntf.Area()) } //Output: The square has area: 25.000000 空接口可以声明为 interface{}，同时因为空接口不包含任何方法，所以任何类型都默认实现了空接口。举个例子，fmt 包中的 Println() 函数，可以接收多种类型的值，比如：int、string、array等。这是因为它的形参就是接口类型，可以接收任意类型的值。 func Println(a ...interface{}) (n int, err error) {} 多个类型可以实现同一个接口，如下例，一个类型也可以实现多个接口。 package main import \"fmt\" type Shaper interface { Area() float32 } type Square struct { side float32 } func (sq *Square) Area() float32 { return sq.side * sq.side } type Rectangle struct { length, width float32 } func (r Rectangle) Area() float32 { return r.length * r.width } func main() { r := Rectangle{5, 3} // Area() of Rectangle needs a value q := \u0026Square{5} // Area() of Square needs a pointer // shapes := []Shaper{Shaper(r), Shaper(q)} // or shorter shapes := []Shaper{r, q} fmt.Println(\"Looping through shapes for area ...\") for n, _ := range shapes { fmt.Println(\"Shape details: \", shapes[n]) fmt.Println(\"Area of this shape is: \", shapes[n].Area()) } } //Output: Looping through shapes for area ... Shape details: {5 3} Area of this shape is: 15 Shape details: \u0026{5} Area of this shape is: 25 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.4 接口嵌套 Go 中的接口可以包含一个或多个其它接口，这相当于直接将这些内嵌接口的方法列举在外层接口中。下例中File接口包含了ReadWrite和Lock接口的所有方法 type ReadWrite interface { Read(b Buffer) bool Write(b Buffer) bool } type Lock interface { Lock() Unlock() } type File interface { ReadWrite Lock Close() } ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:4","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.5 类型断言 如果一个变量是接口变量，实际上其值的类型是不确定的，我们使用类型断言来检测值的具体类型 v := varI.(T) varI是一个接口变量，T是待检测类型，这一语句的作用是检测 varI 的动态类型是否和 T 一致，实质是将 varI 转换为 T 类型的值 package main import ( \"fmt\" \"math\" ) type Square struct { side float32 } type Circle struct { radius float32 } type Shaper interface { Area() float32 } func main() { var areaIntf Shaper sq1 := new(Square) sq1.side = 5 areaIntf = sq1 // Is Square the type of areaIntf? if t, ok := areaIntf.(*Square); ok { fmt.Printf(\"The type of areaIntf is: %T\\n\", t) } if u, ok := areaIntf.(*Circle); ok { fmt.Printf(\"The type of areaIntf is: %T\\n\", u) } else { fmt.Println(\"areaIntf does not contain a variable of type Circle\") } } func (sq *Square) Area() float32 { return sq.side * sq.side } func (ci *Circle) Area() float32 { return ci.radius * ci.radius * math.Pi } //Output: The type of areaIntf is: *main.Square areaIntf does not contain a variable of type Circle 类型断言可能失败，为了更安全的使用类型断言，使用如下的方式 if v, ok := varI.(T); ok { // checked type assertion Process(v) return } // varI is not of type T 由于断言是一个比较的过程，因此需要多次尝试，使用 switch 语句最为简便，不过要求所有 case 语句中列举的类型(nil除外)都必须实现对应的接口。 switch t := areaIntf.(type) { case *Square: fmt.Printf(\"Type Square %T with value %v\\n\", t, t) case *Circle: fmt.Printf(\"Type Circle %T with value %v\\n\", t, t) case nil: fmt.Printf(\"nil value: nothing to check?\\n\") default: fmt.Printf(\"Unexpected type %T\\n\", t) } //Output: Type Square *main.Square with value \u0026{5} 类型断言还有一种反向用法，就是测试它是否实现了某个接口，如下 type Stringer interface { String() string } if sv, ok := v.(Stringer); ok { fmt.Printf(\"v implements String(): %s\\n\", sv.String()) // note: sv, not v } 所以我们可以意识到，断言格式 varI.(T) 中的 varI 可以是任意变量，T 是任意类型，断言的实质就是将变量转换为 T 类型的值，然后进行比较。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:5","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1.6 使用指针接收者和值接收者实现接口 虽然作用于变量的方法不区分变量是指针还是值，但是遇到接口时，会变得稍微复杂一点。 package main import ( \"fmt\" ) type List []int func (l List) Len() int { return len(l) } func (l *List) Append(val int) { *l = append(*l, val) } type Appender interface { Append(int) } func CountInto(a Appender, start, end int) { for i := start; i \u003c= end; i++ { a.Append(i) } } type Lener interface { Len() int } func LongEnough(l Lener) bool { return l.Len()*10 \u003e 42 } func main() { // A bare value var lst List // compiler error: // cannot use lst (type List) as type Appender in argument to CountInto: // List does not implement Appender (Append method has pointer receiver) // CountInto(lst, 1, 10) if LongEnough(lst) { // VALID:Identical receiver type fmt.Printf(\"- lst is long enough\\n\") } // A pointer value plst := new(List) CountInto(plst, 1, 10) //VALID:Identical receiver type if LongEnough(plst) { // VALID: a *List can be dereferenced for the receiver fmt.Printf(\"- plst is long enough\\n\") } } 在 lst 上调用 CountInto 时会导致一个编译器错误，因为 CountInto 需要一个 Appender，而它的方法 Append 只定义在指针上。 在 lst 上调用 LongEnough 是可以的，因为 Len 定义在值上。 在 plst 上调用 CountInto 是可以的，因为 CountInto 需要一个 Appender，并且它的方法 Append 定义在指针上。 在 plst 上调用 LongEnough 也是可以的，因为指针会被自动解引用。 Go语言规范中接口方法集的调用规则为： 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集 类型 T 的可调用方法集包含接受者为 T 的所有方法 类型 T 的可调用方法集不包含接受者为 *T 的方法 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:1:6","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2. 反射 反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时，程序无法获取自身的信息。 支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。 Go 语言的反射系统无法获取到一个可执行文件空间或者一个包中的所有类型信息，仅仅是在运行时通过 reflect 包来访问指定的类型信息。 https://mp.weixin.qq.com/s/qJVfEWngSDg3It3UytPuxA ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.1 方法和类型的反射 Go 的反射包中比较重要和常用的有三个类型：Kind，Type，Value，其中 Type用来表示一个Go类型，Value为Go值提供了反射接口。 reflect.TypeOf 和 reflect.ValueOf 分别是定义在这两者之上的方法，函数原型如下 func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value 其本质是检查接口的动态类型和动态值，一般用来返回被检查对象的类型和值。例如，x被定义为var x float64 = 3.4，那么reflect.TypeOf(x)返回type: float64，reflect.ValueOf(x)返回value: 3.4 因此，使用ValueOf转换获得的值，依然拥有自己的类型和值，反射包的Value有不少方法都可以作用于它，比如kind方法返回一个常量来表示类型，Type方法也返回值的类型，Int和Float等方法可以获取存储在内部的值，Interface方法可以还原接口值。示例如下 package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 fmt.Println(\"type:\", reflect.TypeOf(x)) v := reflect.ValueOf(x) fmt.Println(\"value:\", v) fmt.Println(\"type:\", v.Type()) fmt.Println(\"kind:\", v.Kind()) fmt.Println(\"value:\", v.Float()) fmt.Println(v.Interface()) fmt.Printf(\"value is %5.2e\\n\", v.Interface()) y := v.Interface().(float64) fmt.Println(y) } //Output: type: float64 value: 3.4 type: float64 kind: float64 value: 3.4 3.4 value is 3.40e+00 3.4 由于x是一个float64类型的值，因此使用v.Float()获取它的实际值，其它类型的值可以使用Int(), Bool(), Complex, String() Kind方法总是返回底层类型，如 type MyInt int var m MyInt = 5 v := reflect.ValueOf(m) v.Kind()将返回reflect.Int ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.2 通过反射修改值 无论如何，利用反射修改值总是应该极为谨慎的，而且，不是所有的反射值都可以修改，是否可修改可通过CanSet()方法检测。v := reflect.ValueOf(x)函数传递了一个x的拷贝，对拷贝的修改无法影响原值，因此，若想修改原值，应传递指针，v = reflect.ValueOf(\u0026x)。此时v的类型是*float64，但依然不可修改，还需要最后一步，使用Elem()方法，至此才能使用SetFloat()修改原值，一个完整的例子如下 package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 v := reflect.ValueOf(x) // setting a value: // v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value fmt.Println(\"settability of v:\", v.CanSet()) v = reflect.ValueOf(\u0026x) // Note: take the address of x. fmt.Println(\"type of v:\", v.Type()) fmt.Println(\"settability of v:\", v.CanSet()) v = v.Elem() fmt.Println(\"The Elem of v is: \", v) fmt.Println(\"settability of v:\", v.CanSet()) v.SetFloat(3.1415) // this works! fmt.Println(v.Interface()) fmt.Println(v) } //Output: settability of v: false type of v: *float64 settability of v: false The Elem of v is: \u003cfloat64 Value\u003e settability of v: true 3.1415 \u003cfloat64 Value\u003e ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"2.3 结构体的反射 对结构体进行反射，需要使用NumField()方法返回结构内的字段数量，然后通过for循环用索引获得每个字段的值Field(i)，最后可以使用索引调用签名在结构体上的方法：Method(i).Call(nil) package main import ( \"fmt\" \"reflect\" ) type NotknownType struct { s1, s2, s3 string } func (n NotknownType) String() string { return n.s1 + \" - \" + n.s2 + \" - \" + n.s3 } // variable to investigate: var secret interface{} = NotknownType{\"Ada\", \"Go\", \"Oberon\"} func main() { value := reflect.ValueOf(secret) // \u003cmain.NotknownType Value\u003e typ := reflect.TypeOf(secret) // main.NotknownType // alternative: //typ := value.Type() // main.NotknownType fmt.Println(typ) knd := value.Kind() // struct fmt.Println(knd) // iterate through the fields of the struct: for i := 0; i \u003c value.NumField(); i++ { fmt.Printf(\"Field %d: %v\\n\", i, value.Field(i)) // error: panic: reflect.Value.SetString using value obtained using unexported field //value.Field(i).SetString(\"C#\") } // call the first method, which is String(): results := value.Method(0).Call(nil) fmt.Println(results) // [Ada - Go - Oberon] } //Output: main.NotknownType struct Field 0: Ada Field 1: Go Field 2: Oberon [Ada - Go - Oberon] 但是尝试修改会得到错误，结构体中只有被导出字段才是可设置的。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:2:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3. 总结：面向对象 面向对象最重要的三个方面：封装、继承和多态，在Go中都可以寻找到替代的实现方式 封装(数据隐藏)：即Go中的可见性规则，不同于别的OO语言中的4种访问性，Go只有两种 继承： 用组合或内嵌实现，结构体一篇中谈到过这个。 多态：用接口实现。某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:0","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.1 组合实现继承 组合的含义是包含所需功能的具名字段 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string log *Log } func main() { c := new(Customer) c.Name = \"Barak Obama\" c.log = new(Log) c.log.msg = \"1 - Yes we can!\" // shorter c = \u0026Customer{\"Barak Obama\", \u0026Log{\"1 - Yes we can!\"}} // fmt.Println(c) \u0026{Barak Obama 1 - Yes we can!} c.Log().Add(\"2 - After me the world will be a better place!\") //fmt.Println(c.log) fmt.Println(c.Log()) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) Log() *Log { return c.log } //Output: 1 - Yes we can! 2 - After me the world will be a better place! ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:1","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.2 内嵌实现继承 内嵌的含义是匿名的实现所需功能 package main import ( \"fmt\" ) type Log struct { msg string } type Customer struct { Name string Log } func main() { c := \u0026Customer{\"Barak Obama\", Log{\"1 - Yes we can!\"}} c.Add(\"2 - After me the world will be a better place!\") fmt.Println(c) } func (l *Log) Add(s string) { l.msg += \"\\n\" + s } func (l *Log) String() string { return l.msg } func (c *Customer) String() string { return c.Name + \"\\nLog:\" + fmt.Sprintln(c.Log) } //Output: Barak Obama Log:{1 - Yes we can! 2 - After me the world will be a better place!} 内嵌看起来更简单一点，因此最合适的办法就是利用内嵌创建一些小的、可复用的类型作为工具箱，来被其它类型调用。 ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:2","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"3.3 多重继承 package main import ( \"fmt\" ) type Camera struct{} func (c *Camera) TakeAPicture() string { return \"Click\" } type Phone struct{} func (p *Phone) Call() string { return \"Ring Ring\" } type CameraPhone struct { Camera Phone } func main() { cp := new(CameraPhone) fmt.Println(\"Our new CameraPhone exhibits multiple behaviors...\") fmt.Println(\"It exhibits behavior of a Camera: \", cp.TakeAPicture()) fmt.Println(\"It works like a Phone too: \", cp.Call()) } //Output: Our new CameraPhone exhibits multiple behaviors... It exhibits behavior of a Camera: Click It works like a Phone too: Ring Ring ","date":"2019-11-26","objectID":"/2019/golang-syntax-9-interface-and-reflect/:3:3","tags":["Go语法"],"title":"Golang语法基础9-接口与反射","uri":"/2019/golang-syntax-9-interface-and-reflect/"},{"categories":["Golang学习之路"],"content":"1. 函数声明与定义 Go中有三种类型的函数： 普通的带有名字的函数 匿名函数 方法（Methods，在结构体部分介绍） 普通函数声明的基本格式为 func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) 定义就需要添加大括号和函数体 func functionName(param1 type1, param2 type2,...) (ret1 type1, ret2 type2,...) { ... } 两个括号中分别为参数列表和返回值列表，参数个数和返回值个数允许为0。左大括号必须与声明语句在同一行，流程控制部分已经见过这个规定，这是编译器强制规定。 当函数执行到代码块最后一行，也就是最后一个}之前，或者执行到return语句的时候就会退出。 main函数是每个程序必须包含的，一般来说是启动后第一个执行的函数，但如果有init()函数会先执行该函数。 main函数既没有参数，也没有返回值，如果添加了两者中任一者，都会引发构建错误。main函数一旦返回就表示程序已成功执行并立即退出。同样，init()函数也没有返回值 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:1:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"2. 函数调用 同一个包内，可以直接使用函数名调用该函数，不同包内，需要添加包名，如下所示 pack1.functionName(arg1, arg2, ..., argn) pack1是包名，functionName是该包中的一个函数，括号里是传入的实参。一个简单的调用其它函数的例子如下 package main func main() { println(\"In main before calling greeting\") greeting() println(\"In main after calling greeting\") } func greeting() { println(\"In greeting: Hi!!!!!\") } //Output: In main before calling greeting In greeting: Hi!!!!! In main after calling greeting Go中不允许函数重载 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:2:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3. 函数参数与返回值 除了mian()和init()函数外，其它函数都可以拥有参数和返回值。而且任意一个有返回值的函数都必须以return或panic语句结尾，return可以返回多个值，多值返回是Go的一大特性。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.1 参数传递类型 Go中的参数传递类型有两种：按值传递和按引用传递。 Go默认使用按值传递来传递参数，也就是传递参数的副本，因此参数在函数中被更改后不会影响原值。如果希望函数运行的同时改变原变量的值，应该添加取地址符\u0026，传递变量的指针，也就是按引用传递，按引用传递时，传入的是指针的副本，但指向的值依然是原变量。 函数调用时，切片、映射、接口、通道这些引用类型默认使用按引用传递 几乎在任何情况下，按引用传递的消耗都比按值传递小 按引用传递可以直接修改外部变量的值，因此被修改的变量不再需要使用return返回 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:1","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.2 命名参数 函数定义时，形参一般都有名字，不过也可以定义没有形参名的函数，只有形参类型，比如func f(int, int, float64)，返回值同样如此。只有类型的返回值称为非命名返回值，有名字的返回值称为命名返回值。一个例子如下 package main import \"fmt\" var num int = 10 var numx2, numx3 int func main() { numx2, numx3 = getX2AndX3(num) PrintValues() numx2, numx3 = getX2AndX3_2(num) PrintValues() } func PrintValues() { fmt.Printf(\"num = %d, 2x num = %d, 3x num = %d\\n\", num, numx2, numx3) } func getX2AndX3(input int) (int, int) { return 2 * input, 3 * input } func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3 return } //Output: num = 10, 2x num = 20, 3x num = 30 num = 10, 2x num = 20, 3x num = 30 命名返回值会被初始化为相应类型的零值，返回时只需要一条简单的不带参数的return语句（带参数也不会出错）。 当需要返回多个非命名返回值时，需要使用括号包围，如(int, int)，但对命名返回值，即使只有一个返回值，也要用括号包围。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:2","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.3 空白符 空白符_用来匹配不需要的返回值，然后丢弃掉，之前已经介绍过。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:3","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.4 变长参数 如果函数最后一个参数是...type的形式，那么函数就可以处理一个变长的参数，这个长度可以是0，这样的函数称为变参函数 func myFunc(a, b, arg ...int) {} 变长参数的本质是一个切片，如下例 func Greeting(prefix string, who ...string) Greeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\") 变量who的值为 []string{\"Joe\", \"Anna\", \"Eileen\"} 如果参数本身就存在一个切片类型中，比如切片slice1，则可以通过slice1...的形式传递参数，之前的切片部分使用append函数时已经这样使用过 package main import \"fmt\" func main() { x := min(1, 3, 2, 0) fmt.Printf(\"The minimum is: %d\\n\", x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf(\"The minimum in the slice is: %d\", x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v \u003c min { min = v } } return min } //Output: The minimum is: 0 The minimum in the slice is: 1 一个接受变长参数的函数可以将这个参数作为其它函数的参数进行传递 func F1(s ...string) { F2(s...) F3(s) } func F2(s ...string) { } func F3(s []string) { } ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:4","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"3.5 函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，只要函数返回值个数、返回值类型和返回值顺序同调用函数的形参列表定义相同，称之为回调。下面是一个将函数作为参数的简单例子 package main import ( \"fmt\" ) func main() { callback(1, Add) } func Add(a, b int) { fmt.Printf(\"The sum of %d and %d is: %d\\n\", a, b, a+b) } func callback(y int, f func(int, int)) { f(y, 2) // this becomes Add(1, 2) } //Output: The sum of 1 and 2 is: 3 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:3:5","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"4. 内置函数 Go语言拥有一些不需要导入就可以使用的内置函数，之前已经接触过一些，比如len, cap, append，以下是内置函数列表 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:4:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"5. 匿名函数与闭包 匿名函数是类似 func(x, y int) int { return x + y } 这样没有名字的函数。 匿名函数可以被直接调用，下面是一个计算从 1 到 1 百万整数的总和的匿名函数。表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。 func() { sum := 0 for i := 1; i \u003c= 1e6; i++ { sum += i } }() 另外，匿名函数可以像其它函数一样接受参数，下例展示了如何传递参数到匿名函数中 func (u string) { fmt.Println(u) … }(v) 还应该知道的，匿名函数可以被赋值给某个变量，如fplus := func(x, y int) int { return x + y }，这样函数的地址就保存到了变量中，之后可以通过变量名对函数进行调用：fplus(3, 4) 所谓闭包就是函数及其引用环境的组合，这么说比较难理解，举个例子 func f(i int) func() int { return func() int { i++ return i } } 在这里例子里，返回值是一个函数，这个函数本身没有定义变量，而是引用了它所在环境的变量 i，这就形成了一个闭包。从这里可以看出，闭包与匿名函数息息相关，因为匿名函数被用作函数返回值非常合适。下面是一个完整的例子 package main import \"fmt\" func main() { var f = Adder() fmt.Print(f(1), \" - \") fmt.Print(f(20), \" - \") fmt.Print(f(300)) } func Adder() func(int) int { var x int return func(delta int) int { x += delta return x } } //Output: 1 - 21 - 321 从这里例子中我们注意到 x 的值是不断累加的，这也就意味着闭包函数其实会保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。 这里可以理解为函数被赋值给 f 之后，其实将整个闭包包括环境都赋值给了 f，变量 f 的生存周期内，其值是不变的，所以结果才会累积。 这种返回值为另一个函数的函数的形式也被称之为工厂函数，在需要创建一系列相似的函数的时候非常有用。下面的函数演示了如何动态返回追加后缀的函数： func MakeAddSuffix(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } 现在可以生成如下函数 addBmp := MakeAddSuffix(\".bmp\") addJpeg := MakeAddSuffix(\".jpeg\") 然后调用它们 addBmp(\"file\") // returns: file.bmp addJpeg(\"file\") // returns: file.jpeg ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:5:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"6. defer和追踪 关键字 defer 是 Go 中一个非常有用的特性，作用是将某个语句或函数推迟到函数返回之前执行。准确的说，defer 的执行时机有三种： 包含 defer 语句的函数返回前 包含 defer 语句的函数执行到末尾 所在的 goroutine 发生 panic 时 一个例子如下 func main() { defer fmt.Println(\"Fourth\") fmt.Println(\"First\") fmt.Println(\"Third\") } //Output: First Third Fourth defer 语句中调用的函数参数的值在 defer 语句被定义时就确定了，如下例 i := 1 defer fmt.Println(\"Deferred print:\", i) i++ fmt.Println(\"Normal print:\", i) // Output: Normal print: 2 Deferred print: 1 但与匿名函数结合起来后，变量的值在函数运行时才会确定 func f1() (r int) { r = 1 defer func() { r++ fmt.Println(r) }() r = 2 return } func main() { f1() } // Output: 3 上例中出现了 return 语句，defer 与 return 的执行顺序比较复杂，这里要先理解两件事 defer 函数执行时机是外层函数设置返回值之后，即将返回之前 return xxx 操作并不是原子的 下面的例子中， return 0 实际上可以拆分为 r = 0; return 两条语句，因此输出是1不是0 func f1() (r int) { defer func() { r++ }() return 0 } func main() { fmt.Println(f1()) } 来一个更复杂的例子 func double(x int) int { return x + x } func triple(x int) (r int) { defer func() { r += x }() return double(x) } func main() { fmt.Println(triple(3)) } // Output: 9 上面的例子实际上等价于 func triple(x int) (r int) { r = double(x) func() { r += x }() return } 多个 defer 同时使用时，以逆序执行，即后进先出 func f() { for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } } //Output: 4 3 2 1 0 defer 关键字一般用于释放某些已分配的资源或在函数执行完进行一些收尾工作，比如 关闭文件流 //open a file defer file.Close() 解锁一个加锁的资源 mu.Lock() defer mu.Unlock() 打印最终报告 printHeader() defer printFooter() 关闭数据库链接 //open a database connection defer disconnectFromDB() ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:6:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"7. 编写规范 Go是编译型的语言，因此函数的编写顺序无关紧要，但鉴于可读性的需求，最好遵循一定的编程规范，我这里采用的是Uber开源在github的编码规范，有两条主要规则 函数应按粗略的调用顺序排序 同一文件中的函数应按接收者排序，意即可被外部访问的函数（参考可见性规则）应放在前面，普通工具函数放在后面。另外，在类型定义（结构体、接口等）后，可被外部访问的函数前，可能会出现类似于newXYZ()这样的新建某个类型的函数。一个简单的例子如下 type something struct{ ... } func newSomething() *something { return \u0026something{} } func (s *something) Cost() { return calcCost(s.weights) } func calcCost(n []int) int {...} 最后，main函数放在所有函数的最后。 ","date":"2019-11-25","objectID":"/2019/golang-syntax-7-function/:7:0","tags":["Go语法"],"title":"Golang语法基础7-函数","uri":"/2019/golang-syntax-7-function/"},{"categories":["Golang学习之路"],"content":"只有基本的数据类型无法适应所有的情况，当需要存储和处理大量数据时，通常会使用数组、映射、链表等数据结构，称之为容器(container)。在Go语言中，由于数组不够灵活，增加了切片(slice)类型，切片也是一种容器。 C语言没有提供容器封装，开发者需要自己根据性能需求进行封装，或者使用第三方提供的容器。C++ 语言的容器通过标准库提供，如 vector 对应数组，list 对应双链表，map 对应映射等。 本篇只介绍数组和切片，映射类型放在下篇介绍，链表类型在数据结构中介绍。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:0:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"1. 数组 数组是有限个相同类型的数据的集合，Go语言中数组声明的格式为 var identifier [len]type 数组元素可以是任意基本类型，数组本身，结构体甚至接口（空），当元素类型是数组本身时，即为二维或多维数组。 应注意，数组长度也是数组类型的一部分，[5]int和[10]int是两个不同类型。 数组元素通过索引来读取或修改，不同于字符串，数组是可变的。索引的范围从0到len(arr)-1，内置函数len()可用来获取数组长度，数组长度最大为2Gb。 声明数组时所有的元素都会被自动初始化为元素类型的零值，初始化的过程是按照数组元素的顺序进行的。 当数组元素较少时，可以在声明时直接进行初始化，一些表达方式如下 var arr1 = [3]int{1, 2, 3} var arr2 = [10]int{1, 2, 3} //剩下的元素会自动补全，其值为0 var arr3 = [3]string{2:\"test\"} //只有索引2被赋予了实际的值，其它元素都初始化为空字符串 数组长度的位置也可以使用省略号，此时数组长度会根据提供的值的个数自动推断 arr := [...]int{1, 2, 3} fmt.Println(len(arr)) //3 数组元素较多时使用for循环初始化 var arr [100]int //使用for循环初始化 for i:=0; i \u003c len(arr); i++ { arr[i] = i * 2 } Go语言中数组是一种值类型，而不像C语言是指向首元素的指针，因此可以使用内置函数new()来创建数组（new()用来创建值类型，返回所创建类型的指针） var arr1 = new([5]int) 这种方式和var arr2 [5]int的区别是，arr1的类型是*[5]int，而arr2的类型是[5]int，一个简单的式子可以帮助理解 arr2 := *arr1 当像上式这样进行赋值时，我们把arr1的值做了一次拷贝，因此修改arr2不会对arr1产生影响。同理，函数中数组作为参数传入时，传入值类型的数组不会改变原值，但是直接传入数组作为参数，当数组很大时会消耗很多内存，可以传入数组的指针或使用切片来解决。以下是传入指针的例子。 package main import \"fmt\" func f(a [3]int) { fmt.Println(a) } func fp(a *[3]int) { fmt.Println(a) } func main() { var ar = [3]int{1, 2, 3} f(ar) // passes a copy of ar fp(\u0026ar) // passes a pointer to ar } 数组可以组装成多维数组，一个二维数组可以理解为一个数组类型的数组，以下演示一个二维数组的声明 // 声明一个二维整型数组，两个维度的长度分别是 4 和 2 var array [4][2]int // 声明并初始化数组中索引为 1 和 3 的元素 array = [4][2]int{1: {20, 21}, 3: {40, 41}} // 声明并初始化数组中指定的元素 array = [4][2]int{1: {0: 20}, 3: {1: 41}} ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:1:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2. 切片 切片（slice）就是动态数组，可以理解为对数组一个连续片段的引用，是一个引用类型。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2.1 声明与使用 切片声明的格式如下，基本就是去掉了数组声明中的长度 var identifier []type 未初始化的切片默认为nil，长度为0。切片的初始化格式为 var slice []type = arr[start:end] 表示slice是数组arr从start索引到end-1索引之间的元素构成的子集，切片的大小可以和数组相等，但应注意到终止索引的项并不包含在切片内。一些切片的方式如下 var arr = [5]int{1,2,3,4,5} s := arr[:] s := arr[0:5] //这两个切片都等于整个数组 s := arr[:3] s := arr[0:3] //这两式输出都是[1,2,3] s := arr[2:] s := arr[2:5] //这两式输出都是[3,4,5] 切片是可索引的，但切片的索引与原数组的索引不一定相同，如上例最后一行，s[0] = arr[2]。 切片的长度在运行时可修改，最小为0最大为相关数组的长度，具体的长度值可通过len()函数获得。 cap()函数可以计算切片的容量，也就是切片最长可以达到多少。举个例子，如果 s 是一个切片，cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量。容量之所以从s[0]开始计数，是因为切片只能向后移动，任何试图获取切片第一个元素之前的数组元素的做法都会导致编译错误。 arr := [5]int{1, 2, 3, 4, 5} s := arr[2:4] //len(s)为2，cap(s)为3 两个直接创建切片的例子如下 s := [3]int{1,2,3}[:] x := []int{2,3,4,5,6} 但本质上这两者都是先创建的数组，然后取了与数组等长的切片。 注：切片本身已是引用，它没有指针，因此不要对它使用取地址符。 在上面的数组部分我们谈到当数组很大时，直接将数组作为参数传给函数会占用大量内存，因此我们介绍了如何传入数组的指针，这里我们再介绍如何传入切片：我们应当在函数中声明参数为切片类型，调用函数时，把数组分片，创建一个切片引用传递给该函数，示例如下 func sum(a []int) int { s := 0 for i := 0; i \u003c len(a); i++ { s += a[i] } return s } func main() { var arr = [5]int{0, 1, 2, 3, 4} sum(arr[:]) } 数组作为值类型使用new()来创建，而切片作为引用类型，需要使用make()。 var slice []type = make([]type, len) slice := make([]type, len) //简写形式 其中第二个参数len是数组的长度，也是slice的初始长度，例如定义s1 := make([]int, 10)，那么cap(s1) == len(s1) == 10 也可以在声明时利用第三个参数指定切片容量 slice := make([]type, len, cap) 因此，下面两种方法可生成相同切片 make([]int, 50, 100) new([100]int)[0:50] 字符串可以看作是一个不可变的字节数组，因此也可以切分为切片使用。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:1","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"2.2 常用操作 由于切片的灵活性，会经常使用切片进行一些操作，这里简单介绍几种。 重组 使用make创建切片的时候可以指定容量，因此必要时可以改变切片长度直到达到容量上限，改变切片长度的过程称为切片重组（reslice），如将切片扩展1位 s = s[0:len(s)+1] //len(s)+1 \u003c= cap(s) 复制 增加切片的容量必须创建一个新的更大的切片并把原分片的内容都拷贝过来。切片拷贝使用copy()函数，函数原型如下 copy(destSlice, srcSlice []T) int 作用是将 srcSlice 复制到 destSlice，两者类型必须一致，返回值为实际复制的元素个数。源地址和目标地址可能会有重叠。复制的元素个数是 srcSlice 和 dstSlice 的长度最小值。示例如下 sl_from := []int{1, 2, 3} sl_to1 := make([]int, 5) sl_to2 := make([]int, 2) n1 := copy(sl_to1, sl_from) // n1 = 3, s1_to1 = [1,2,3,0,0] n2 := copy(sl_to2, sl_from) // n2 = 2, s1_to2 = [1,2] 追加 追加也是一种切片扩容的方式，主要使用append()函数，函数原型是 func append(s []T, x ...T) []T 作用是将0个或多个具有相同类型T的元素追加到切片s后面病并回新的切片，追加的元素类型需要和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。 sl3 := []int{1, 2, 3} sl3 = append(sl3, 4, 5, 6) // sl2 = [1,2,3,4,5,6] 删除 删除切片元素没有专用语法，需要使用切片本身的特性。分为三种情况：从开始位置删除，从中间位置删除，从末尾删除 从开始位置删除 直接移动数据指针 a = []int{1, 2, 3} a = a[1:] // 删除开头1个元素 a = a[N:] // 删除开头N个元素 不移动数据指针，而是将后面的数据向开头移动 a = []int{1, 2, 3} a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 使用copy()函数 a = []int{1, 2, 3} a = a[:copy(a, a[1:])] // 删除开头1个元素 a = a[:copy(a, a[N:])] // 删除开头N个元素 从中间位置删除 对剩余的元素做一次整体移动，可以使用copy()或append() a = []int{1, 2, 3, ...} a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素 从末尾删除 a = []int{1, 2, 3} a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 删除开头和末尾都是删除中间的特殊情况 插入 插入的一般方式是使用两次append()函数 a = append(a[:i], append([]T{x}, a[i:]...)...) //在索引i的位置插入元素x a = append(a[:i], append(make([]T, j), a[i:]...)...) //在索引i的位置插入长度为j的新切片 a = append(a[:i], append(b, a[i:]...)...) //在索引i的位置插入切片b的所有元素 映射(map)其实就是数据结构里的哈希表，但不少语言都已经把它作为了内置的数据类型。映射是元素对的无序集合，由键(key)和值(value)两部分构成，可以通过键快速查找值（比线性查找快，但实际上比通过数组或切片索引直接读取要慢）。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:2:2","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3. 映射 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:0","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.1 声明与初始化 Golang 中的 map 是引用类型，声明方法如下 //语法格式 var mapname map[keytype]valuetype //示例 var map1 map[string]int 凡是可以用 == 或 != 操作符比较的类型都可以作为键的类型，比如string、int、float、只包含基本类型的结构体、指针和接口，而数组、切片以及含有数组切片的结构体无法作为键类型。值的类型是任意的，当值类型是一些复杂结构时，往往有比较特殊的用途，比如 函数。值类型为函数时可以视作分支结构，key用来选择要执行的函数。 空接口。我们可以用空接口作为值类型存储任意类型的值，只是在使用前需要做一次类型断言。 切片。通过将值类型定义为切片类型，应对一个Key对应多个值的情况，示例如下 mp1 := make(map[int][]int) map 可以动态增长，声明时不关心长度，使用时其长度使用内置函数len()获取。 未初始化的 map 值为 nil，如果此时试图给map添加元素会导致运行时错误，因此添加元素必须首先初始化。map初始化的方法有两种 直接使用大括号，在数组与切片的初始化中已经见过这种方法，示例如下 var mapLit map[string]int mapLit = map[string]int{\"one\":1, \"two\":2} 使用make，map是引用类型，因此使用make初始化。以make方式初始化其实相当于mapLit := map[string]int{} mapLit := make(map[string]int) 虽然map可以动态增长，没有长度限制，但是也可以在一开始标明其初始容量 mapLit := make(map[string]int, 100) 当map增长到容量上限后，继续增加新的键值对，map的大小会自动加1，因此容量对map并没有多大影响。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:1","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.2 访问与删除map中的元素 如果 key1 是 map1 的 key，那么 map1[key1] 就是对应 key1 的值，map中就通过这种类似数组索引的方式访问元素 val1 := map1[key1] 上式将 key1 对应的值赋给了 val1，但反过来，也可以通过这种形式设置对应key1的值，如下 map1[key1] = val1 访问 map 中不存在的 key 会获得它所对应的值类型的空值，因此我们还需要有一种办法来判断键值对是否存在，这样才能区分到底是键值对本身不存在，还是值是空值。实际上通过键来访问值会返回两个结果，如下 val1, ok := map1[key1] 当键值对存在时，ok 的值为 true，而当键值对不存在时，ok 的值为 false。如果只想判断某个键值对是否存在，可以将返回的真正的值设置为匿名变量 _, ok := map1[key1] map中元素的删除使用内置函数delete()，格式如下 delete(mapname, keyname) 如果键值对不存在，删除操作也不会产生错误 mapLit := map[string]int{\"one\": 1, \"two\": 2} delete(mapLit, \"one\") 但 Golang 并没有提供清空 map 中所有元素的方法，清空 map 的唯一办法就是重新 make 一个新的 map mapLit := map[string]int{\"one\": 1, \"two\": 2} mapLit = make(map[string]int) ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:2","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.3 遍历map for-range可用于遍历map for key, value := range map1 { ... } 其中第一个返回值 key 是 map 中的 key 值，第二个返回值 value 则是 key 对应的 value 值。如果只关心值，可以省略键 for _, value := range map1 { ... } 而如果只关心键，则可以省略值 for key := range map1 { fmt.Printf(\"key is: %d\\n\", key) } 还需要知道的一点是，for-range 结构虽然能遍历整个 map，但我们并不知道 map 中键值对排列的顺序，并不是按 key 的顺序排列的，也不是按 value 的顺序排列。 如果想要为 map 排序，那么就需要先通过遍历将 map 的所有数据复制到切片中，再对切片排序，最后打印出来 // the telephone alphabet: package main import ( \"fmt\" \"sort\" ) var barVal = map[string]int{\"alpha\": 34, \"bravo\": 56, \"charlie\": 23} func main() { fmt.Println(\"unsorted:\") for k, v := range barVal { fmt.Printf(\"Key: %v, Value: %v ; \", k, v) } keys := make([]string, len(barVal)) i := 0 for k := range barVal { keys[i] = k i++ } sort.Strings(keys) fmt.Println() fmt.Println(\"sorted:\") for _, k := range keys { fmt.Printf(\"Key: %v, Value: %v ; \", k, barVal[k]) } } //Output: unsorted: Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; sorted: Key: alpha, Value: 34 ; Key: bravo, Value: 56 ; Key: charlie, Value: 23 ; 上例按key进行了排序并输出，如果想要更好的显示，可以使用结构体切片 type name struct { key string value int } ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:3","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"3.4 map类型的切片 map类型的切片是一个很有意思的结构，构造它需要使用两次make()函数，第一次分配切片，第二次分配切片中的每个map元素 package main import \"fmt\" func main() { // Version A: items := make([]map[int]int, 5) for i:= range items { items[i] = make(map[int]int, 1) items[i][1] = 2 } fmt.Printf(\"Version A: Value of items: %v\\n\", items) // Version B: NOT GOOD! items2 := make([]map[int]int, 5) for _, item := range items2 { item = make(map[int]int, 1) // item is only a copy of the slice element. item[1] = 2 // This 'item' will be lost on the next iteration. } fmt.Printf(\"Version B: Value of items: %v\\n\", items2) } //Output: Version A: Value of items: [map[1:2] map[1:2] map[1:2] map[1:2] map[1:2]] Version B: Value of items: [map[] map[] map[] map[] map[]] 应该意识到，for-range 结构中，value 只是值的拷贝，对它做操作不会影响原值，因此上例中第二种写法是错误的，真正的 map 元素并没有得到初始化。 ","date":"2019-11-18","objectID":"/2019/golang-syntax-6-array-slice-and-map/:3:4","tags":["Go语法"],"title":"Golang语法基础6-数组、切片与映射","uri":"/2019/golang-syntax-6-array-slice-and-map/"},{"categories":["Golang学习之路"],"content":"本篇介绍字符串的相关操作，涉及string和strconv两个标准库，以及介绍输入输出的基本方法，涉及fmt和bufio两个标准库。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:0:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1. 字符串操作 对字符串的操作无论在什么语言里都是很重要的，因此在基本数据类型中介绍过字符串之后，这里仍然专门拿出一篇来介绍关于字符串的处理。 如我们之前所述，内置的字符串操作是字符串的拼接，通过拼接符+来完成。 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) //Output: //hello, world! 但使用拼接符+并不是最高效的做法，同时，由于字符串是一种内容不可变的值类型，无法直接通过索引操作其内的任意字符。Go语言内置了strings包来提供对字符串的种种操作，方便我们使用，当然，很多时候也会使用strconv包，这个包的使用我们在类型转换部分提到过。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.1 判断包含关系 HasPrefix 判断字符串 s 是否以 prefix 开头： strings.HasPrefix(s, prefix string) bool HasSuffix 判断字符串 s 是否以 suffix 结尾： strings.HasSuffix(s, suffix string) bool 示例如下 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"This is an example of a string\" fmt.Printf(\"T/F? Does the string \\\"%s\\\" have prefix %s? \", str, \"Th\") fmt.Printf(\"%t\\n\", strings.HasPrefix(str, \"Th\")) } //Output: //T/F? Does the string \"This is an example of a string\" have prefix Th? true 更一般化的，Contains 判断字符串 s 是否包含 substr： strings.Contains(s, substr string) bool ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:1","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.2 获取子字符串的位置 Index 返回字符串 str 在字符串 s 中的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： strings.Index(s, str string) int LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str： strings.LastIndex(s, str string) int 如果需要查询非 ASCII 编码的字符在父字符串中的位置，使用以下函数来对字符进行定位： strings.IndexRune(s string, r rune) int 示例如下 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"Hi, I'm Marc, Hi.\" fmt.Printf(\"The position of \\\"Marc\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Marc\")) fmt.Printf(\"The position of the first instance of \\\"Hi\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Hi\")) fmt.Printf(\"The position of the last instance of \\\"Hi\\\" is: \") fmt.Printf(\"%d\\n\", strings.LastIndex(str, \"Hi\")) fmt.Printf(\"The position of \\\"Burger\\\" is: \") fmt.Printf(\"%d\\n\", strings.Index(str, \"Burger\")) } /*Output: The position of \"Marc\" is: 8 The position of the first instance of \"Hi\" is: 0 The position of the last instance of \"Hi\" is: 14 The position of \"Burger\" is: -1 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:2","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.3 统计出现次数 Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数： strings.Count(s, str string) int 示例 package main import ( \"fmt\" \"strings\" ) func main() { var str string = \"Hello, how is it going, Hugo?\" var manyG = \"gggggggggg\" fmt.Printf(\"Number of H's in %s is: \", str) fmt.Printf(\"%d\\n\", strings.Count(str, \"H\")) fmt.Printf(\"Number of double g's in %s is: \", manyG) fmt.Printf(\"%d\\n\", strings.Count(manyG, \"gg\")) } /*Output: Number of H's in Hello, how is it going, Hugo? is: 2 Number of double g’s in gggggggggg is: 5 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:3","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.4 替换与重复 Replace 用于将字符串 str 中的前 n 个字符串 old 替换为字符串 new，并返回一个新的字符串，如果 n = -1 则替换所有字符串 old 为字符串 new： strings.Replace(str, old, new, n) string Repeat 用于重复 count 次字符串 s 并返回一个新的字符串： strings.Repeat(s, count int) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { var origS string = \"Hi there! \" var newS string newS = strings.Repeat(origS, 3) fmt.Printf(\"The new repeated string is: %s\\n\", newS) } //Output: //The new repeated string is: Hi there! Hi there! Hi there! ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:4","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.5 大小写转换 ToLower 将字符串中的 Unicode 字符全部转换为相应的小写字符： strings.ToLower(s) string ToUpper 将字符串中的 Unicode 字符全部转换为相应的大写字符： strings.ToUpper(s) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { var orig string = \"Hey, how are you George?\" var lower string var upper string fmt.Printf(\"The original string is: %s\\n\", orig) lower = strings.ToLower(orig) fmt.Printf(\"The lowercase string is: %s\\n\", lower) upper = strings.ToUpper(orig) fmt.Printf(\"The uppercase string is: %s\\n\", upper) } /*Output: The original string is: Hey, how are you George? The lowercase string is: hey, how are you george? The uppercase string is: HEY, HOW ARE YOU GEORGE? */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:5","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.6 修剪与分割 可以使用 strings.TrimSpace(s) 来剔除字符串开头和结尾的空白符号； 可以使用 strings.Trim(s, \"cut\") 来将开头和结尾的指定字符串（cut）去除掉。 如果只想剔除开头或者结尾的字符串，则可以使用 TrimLeft 或者 TrimRight 来实现。 strings.Fields(s) 将会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。 strings.Split(s, sep) 用于自定义分割符号来对指定字符串进行分割，同样返回 slice。 因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:6","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"1.7 拼接 Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串： strings.Join(sl []string, sep string) string 示例 package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over the lazy dog\" sl := strings.Fields(str) fmt.Printf(\"Splitted in slice: %v\\n\", sl) for _, val := range sl { fmt.Printf(\"%s - \", val) } fmt.Println() str2 := \"GO1|The ABC of Go|25\" sl2 := strings.Split(str2, \"|\") fmt.Printf(\"Splitted in slice: %v\\n\", sl2) for _, val := range sl2 { fmt.Printf(\"%s - \", val) } fmt.Println() str3 := strings.Join(sl2,\";\") fmt.Printf(\"sl2 joined by ;: %s\\n\", str3) } /*Output: Splitted in slice: [The quick brown fox jumps over the lazy dog] The - quick - brown - fox - jumps - over - the - lazy - dog - Splitted in slice: [GO1 The ABC of Go 25] GO1 - The ABC of Go - 25 - sl2 joined by ;: GO1;The ABC of Go;25 */ ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:1:7","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2. 输入输出 编写程序进行数据的读写必不可少，一般会用到fmt, os和bufio三个包，下面对一些读写方式进行总结。 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:0","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.1 读取用户输入 用户输入来自三种：标准输入，字符串，io.Reader类型 来自标准输入 读取用户输入一般指的是读取用户的键盘（控制台）输入，定义为标准输入os.Stdin，最常用的方法是使用fmt包提供的Scan开头的函数。 func Scan(a ...interface{}) (n int, err error) func Scanf(format string, a ...interface{}) (n int, err error) func Scanln(a ...interface{}) (n int, err error) Scan从标准输入扫描文本，将成功读取的空白分隔的值传递给函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。 Scanf从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值传递给函数的参数。返回成功扫描的条目个数和遇到的任何错误。 Scanln类似Scan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。 一个示例程序如下： package main import \"fmt\" var firstName, lastName string func main() { fmt.Println(\"Please enter your full name: \") fmt.Scanln(\u0026firstName, \u0026lastName) // fmt.Scanf(\"%s %s\", \u0026firstName, \u0026lastName) } 来自字符串 读取来自字符串的输入一般使用fmt包中SScan开头的函数 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) SScan开头的函数基本和Scan相似，唯一的不同是多了第一个参数str，代表从字符串str扫描文本。一个示例程序如下： package main import \"fmt\" func main() { var name string var age int n, err := fmt.Sscanf(\"Kim is 22 years old\", \"%s is %d years old\", \u0026name, \u0026age) if err != nil { panic(err) } fmt.Printf(\"%d: %s, %d\\n\", n, name, age) } //Output 2: Kim, 22 来自io.Reader类型 主要是使用Fscan开头的函数 func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) 同样，与Scan的不同是第一个参数r是io.Reader类型，示例程序如下： package main import ( \"fmt\" \"os\" \"strings\" ) func main() { var ( i int b bool s string ) r := strings.NewReader(\"5 true gophers\") //返回一个io.Reader类型 n, err := fmt.Fscanf(r, \"%d %t %s\", \u0026i, \u0026b, \u0026s) if err != nil { fmt.Fprintf(os.Stderr, \"Fscanf: %v\\n\", err) } fmt.Println(i, b, s) fmt.Println(n) } 5 true gophers 3 ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:1","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.2 输出指定内容 输出和读取输入基本是是相反的，各函数原型如下： func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) func Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) 示例程序如下： package main import ( \"fmt\" \"io\" \"os\" ) func main() { const name, age = \"Kim\", 22 fmt.Printf(\"%s is %d years old.\\n\", name, age) s := fmt.Sprintf(\"%s is %d years old.\\n\", name, age) io.WriteString(os.Stdout, s) // Ignoring error for simplicity. n, err := fmt.Fprintf(os.Stdout, \"%s is %d years old.\\n\", name, age) if err != nil { fmt.Fprintf(os.Stderr, \"Fprintf: %v\\n\", err) } fmt.Printf(\"%d bytes written.\\n\", n) } //Output Kim is 22 years old. Kim is 22 years old. Kim is 22 years old. 21 bytes written. ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:2","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.3 使用bufio包 使用fmt进行读写，读写次数比较多时，时间耗费极大。go提供了一个bufio包，使用该包可以大幅提高文件读写效率。 bufio包原理 介绍来自茹姐-GO语言基础进阶教程：bufio包。io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。 读入 package main import ( \"fmt\" \"bufio\" \"os\" ) func main() { inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please enter some input: \") input, err := inputReader.ReadString('\\n') if err == nil { fmt.Printf(\"The input was: %s\\n\", input) } } bufio.NewReader() 构造函数的签名为：func NewReader(rd io.Reader) *Reader inputReader 是一个指向 bufio.Reader 的指针。inputReader := bufio.NewReader(os.Stdin) 这行代码，将会创建一个读取器，并将其与标准输入绑定。返回的读取器对象提供一个方法 ReadString(delim byte)，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。在上面的例子中，我们会读取键盘输入，直到回车键（\\n）被按下。 写出 package main import ( \"os\" \"fmt\" \"bufio\" ) func main() { w1 := bufio.NewWriter(os.Stdout) for i:=1;i\u003c=1000;i++{ w1.WriteString(fmt.Sprintf(\"%d:hello\",i)) } w1.Flush() } ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:3","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"2.4 文件读写 主要是使用os.Open函数打开文件，以及defer关键字和close方法在程序结束时关闭文件。 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func main() { inputFile, inputError := os.Open(\"input.dat\") if inputError != nil { fmt.Printf(\"An error occurred on opening the inputfile\\n\" + \"Does the file exist?\\n\" + \"Have you got acces to it?\\n\") return // exit the function on error } defer inputFile.Close() inputReader := bufio.NewReader(inputFile) for { inputString, readerError := inputReader.ReadString('\\n') fmt.Printf(\"The input was: %s\", inputString) if readerError == io.EOF { return } } } 未完待续… ","date":"2019-11-11","objectID":"/2019/golang-syntax-5-string-input-and-output/:2:4","tags":["Go语法"],"title":"Golang语法基础5-字符串操作与输入输出","uri":"/2019/golang-syntax-5-string-input-and-output/"},{"categories":["Golang学习之路"],"content":"本文介绍 Golang 中的运算符和流程控制 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:0:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"1. 运算符 Go语言的运算符有6种，如下表所示 运算符类型 运算符 算术运算符 +，-，*，/，%，++，– 关系运算符 ==，!=，\u003e，\u003c，\u003e=，\u003c= 逻辑运算符 \u0026\u0026，||，! 位运算符 \u0026，|，^，«，»，\u0026^ 赋值运算符 =，+=，-=，*=，/=，%=，«=，»=，\u0026=，^=，!= 其它运算符 \u0026，* 基本的运算规则都与C语言相同，一些注意事项列举如下 算术运算符中自增自减运算符只能作为语句使用，不能用于表达式 a++ // 允许 a-- // 允许 a = a++ //不允许，编译错误 a[i] = b[i++] //不允许，编译错误 整数除以0会导致编译错误，如果编译时未检出会导致程序崩溃。浮点数除以0.0会返回无穷大，用+Inf表示 逻辑运算符具有短路效果 位运算符是对整数在内存中的二进制位进行操作的，假定A = 60，B = 13，则 A = 0011 1100 B = 0000 1101 A\u0026B = 0000 1100 // 结果为12 A|B = 0011 1101 // 结果为61 A^B = 0011 0001 // 结果为49 A\u003c\u003c2 = 1111 0000 // 结果为240 A\u003e\u003e2 = 0000 1111 // 结果为15 其它运算符中的\u0026是取地址符，*是指针变量 运算符的优先级是不同的，下表从上往下代表优先级从高到低 优先级 运算符 7 ^ ，! 6 * ，/ ，% ，« ，»， \u0026， \u0026^ 5 +， -， | ，^ 4 ==， !=， \u003c ，\u003c= ，\u003e=， \u003e 3 \u003c- 2 \u0026\u0026 1 || 二元运算符的运算方向均是从左到右，必要时可以使用括号提升优先级或更清楚地表达。 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:1:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2. 控制结构 除去顺序结构外，Go语言提供的基本流程控制结构包括 条件结构 if-else 结构 switch 结构 select 结构，用于channel的选择（协程与通道部分） 循环结构 for for-range 同时，Go还提供了关键字break、continue和goto用来辅助进行流程控制，以及return语句提前结束执行。 注1：在这些结构中，Go都省略了条件语句两侧的小括号，使视觉上更加简洁。 注2：除case关键字后的语句，即使代码块只有一行，大括号也不可省略 注3：左大括号必须和关键字在同一行，对多分支结构中的else关键字，右大括号也要和它在一行。这两条规则是编译器的强制规定。 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.1 if-else 结构 if-else 结构的基本形态与C语言相同。可以省略else关键字变成单分支结构，也可以添加else if变成多分支，但为了代码简洁，过多的分支最好换用switch结构实现。 if condition1 { // do something } else { // do something else } 当双分支结构在代码块的末尾时，通常会将else中原本的代码块迁移出来放在最后，如 if condition { return true } return false Go中 if 还可以在条件语句前添加一个初始化语句，以分号分隔 if initialization; condition { // do something } 例如 if val := 10; val \u003e max { // do something } 但需要注意的时，使用简短方式 := 声明和初始化的变量作用域只限于 if 结构的代码块内，属于局部变量。 由于Go语言并行赋值的特性，if 语句经常用于测试多返回值函数的错误。返回某个值以及true表示成功，返回零值（或nil）以及false表示失败 if value, ok := readData(); ok { … } 当不使用true或false时，也可以使用一个error类型的变量来代替作为第二个返回值，成功执行，error的值为nil，失败返回的值会包含相应的错误信息。 var err error if err := file.Chmod(0664); err != nil { fmt.Println(err) return err } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:1","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.2 switch 结构 switch结构的基本形态依然同C语言相同 switch var1 { case val1: ... case val2: ... default: ... } 不同的是，Go中switch语句接受任意形式的表达式，如上例中var1可以是任何类型，而val1和val2可以是同类型的任意值，不局限于数值。 可以同时测试多个可能符合条件的值，使用逗号分隔，例如case val1, val2, val3 每个case分支都是唯一的，从上到下逐一测试，一旦成功匹配到某个分支，执行完对应的代码块后会自动退出整个 switch 结构，而不需要使用break结束。因此，程序不会自动的去执行剩下的case分支的代码，如果想继续执行，需要使用fallthrough关键字 switch i { case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用 } case语句后不需要用大括号包围代码块，default分支可以出现在任何顺序，但最好放在最后 package main import \"fmt\" func main() { var num1 int = 100 switch num1 { case 98, 99: fmt.Println(\"It's equal to 98\") case 100: fmt.Println(\"It's equal to 100\") default: fmt.Println(\"It's not equal to 98 or 100\") } } //Output: //It's equal to 100 switch可以不提供条件语句，然后在每个case分支测试不同条件，可以替换分支比较多的if-else结构，简化代码 switch { case i \u003c 0: f1() case i == 0: f2() case i \u003e 0: f3() default: ... } switch的条件语句还可以是初始化语句 switch a, b := x[i], y[j] { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: t = 1 } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:2","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.3 for 结构 Go中只有for用于循环结构，没有C中的while或do while，基本形态如下 for 初始化语句; 条件语句; 修饰语句 { ... } 同样，for 关键字后的三个语句不需要小括号，左大括号需和关键字在同一行 可以只保留条件语句，这种情况下可以去掉所有分号，大致等同于其它语言的while循环 package main import \"fmt\" func main() { var i int = 5 for i \u003e= 0 { i = i - 1 fmt.Printf(\"The variable i is now: %d\\n\", i) } } 或者省略条件语句，但必须在循环体中存在条件判断以确保在某个时候退出循环，退出可以使用break或return for i := 0; ; i++ { ... } 或者三条语句全部省略，但同样需要在循环体中添加退出条件 for { ... } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:3","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"2.4 for-range 结构 这是 Go 中特有的迭代结构，可以迭代数组、切片、map、字符串等任意一个集合，一般形式为 for k, v := range set { ... } k 为索引，每次递增，v 为索引对应的值的拷贝。值得注意的是，由于 v 只是值的拷贝，任何对它的修改都不会影响集合中原来的值，除非索引是指针。 如果不需要索引，可以使用匿名变量_忽略它 for _, v := range set{ ... } 但如果只需要索引而不需要值，可以直接省略不写 for k := range set { ... } // Output: 0 1 2 ... 字符串通过for-range结构获取的元素是rune类型 ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:2:4","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"3. 辅助关键字 break用来跳出循环，在for循环中跳出一层循环，在switch或select语句中，跳过整段代码块 for i:=0; i\u003c3; i++ { for j:=0; j\u003c10; j++ { if j\u003e5 { break } print(j) } print(\" \") } //Output: //012345 012345 012345 continue用来忽略剩余的循环体直接进入下一次循环，只存在于for循环中 for i := 0; i \u003c 10; i++ { if i == 5 { continue } print(i) print(\" \") } //Output: //0 1 2 3 4 6 7 8 9 for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词，下例中continue语句指向LABEL1，当执行到该语句时，就会跳转到LABEL1标签的位置起继续执行，不过此时注意循环体内的变量并不会被释放，当j==4循环跳出后，i会自动变成下一个循环的值，不会陷入无限循环。 package main import \"fmt\" func main() { LABEL1: for i := 0; i \u003c= 5; i++ { for j := 0; j \u003c= 5; j++ { if j == 4 { continue LABEL1 } fmt.Printf(\"i is: %d, and j is: %d\\n\", i, j) } } } 标签的名称和一般的标识符相同，都是大小写敏感的，但为了可读性，一般全部使用大写字母。同变量相同，标签定义未使用也会导致编译错误。 goto关键字是配合标签使用的，但这种用法并不被推荐，因为很可能导致糟糕的代码结构，一如当年的PASCAL 逆序的标签虽然可能导致错误，但正序的标签(标签位于goto语句之后)则可以正常使用，但标签和goto之间不能有新定义变量的语句，否则会导致编译失败 // compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8 package main import \"fmt\" func main() { a := 1 goto TARGET // compile error b := 9 TARGET: b += a fmt.Printf(\"a is %v *** b is %v\", a, b) } ","date":"2019-10-29","objectID":"/2019/golang-syntax-4-operators-and-flow-control/:3:0","tags":["Go语法"],"title":"Golang语法基础4-运算符与流程控制","uri":"/2019/golang-syntax-4-operators-and-flow-control/"},{"categories":["Golang学习之路"],"content":"本文介绍 Go 中的常量、变量、基本数据类型和常用的类型转换。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:0:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"1. 常量 常量用于存储程序运行过程中不会改变的数据，试图改变会引发编译错误。Go 中常量使用关键字 const 定义，声明与初始化语句放在一起，格式如下 const identifier [type] = value 常量的值必须在编译时能够确定，因此只能是基本数据类型和表达式。一个常量定义的例子如下 const Pi float64 = 3.14159 另外，由于 Go 的一些特性，常量的定义有一些不同的形式 Go 支持根据值推断其类型，因此类型定义可省略 const Pi = 3.14159 Go 支持在同一行同时定义多个值，称为多重赋值 const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6 Go 支持批量声明，这种定义形式叫做因式分解关键字 const ( Monday, Tuesday, Wednesday = 1, 2, 3 Thursday, Friday, Saturday = 4, 5, 6 ) 此外，Go 还提供关键字 iota，用作常量计数器，只能在常量定义时使用。iota 在 const 关键字出现时被重置为 0，每新增一行常量声明新增一个计数，能极大的简化定义。一个例子如下 const a = iota // a=0 const ( b = iota //b=0 c //c=1 相当于c=iota ) 可以使用空白标识符跳过不想要的值 const ( a = iota // 0 _ c // 2 ) 同一行有多个变量不产生影响，中间有数值插队也不产生影响，因为 iota 的值是每新增一行声明增加 1 const ( a,b = iota,iota+1 // 0,1 c,d // 1,2 e,f // 2,3 ) const ( a = iota // 0 b = 3.14 c // 2 ) ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:1:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"2. 变量 变量使用 var 关键字声明，格式为 var identifier type 当一个变量被声明后，系统会自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。 变量与常量的一个不同之处在于，一般情况下，声明与初始化是分离的，一个例子如下 var a int a = 15 但变量也可以将声明和初始化放到一起，就像常量一样，这也是最常使用的方式 var a int = 15 最后，由于常量部分提到的三个 Go 的特性，变量的声明和使用也有一些不同的形式 类型推断，从而可以省略类型定义 var a = 15 多重赋值 var a, b, c = 5, 6, 7 批量声明 var ( a = 15 b = false str = \"Go says hello to the world!\" numShips = 50 city string ) 上面提到的所有方式可以用于全局变量，也可以用于局部变量，但还有一种更加简短的声明与定义方式，仅能用于局部变量（函数体内，包括 main 函数），这是我们使用非常多的一种写法 a := 15 这里详细介绍一下常量部分提到过的空白标识符，空白标识符指的是下划线 _，也叫做匿名变量，只允许写入，任何类型都可以赋值给它，但无法使用它的值。我们在使用 iota 关键字时可以使用空白标识符跳过不想要的值，另外一种常见的使用场景是在多重赋值中抛弃不需要的变量 _, b = 5, 7 匿名变量不会被分配内存，因此不占用内存空间，多次声明也不会引起冲突。 Go 还提供了一种非常友好的功能，如果想要交换两个变量的值，可以直接使用 a, b = b, a 这种形式，不需要再使用临时变量，为程序编写带来了极大的便利。 变量的命名规则最好遵循驼峰命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips。但当全局变量需要对外部包可见时，首个单词首字母需要大写(可见性原则)。 变量作用域的规则同 C 语言相同，关于值类型和引用类型的理解也和 C 语言相同，Go 中引用类型包括指针、切片、映射和通道，值类型存储在栈中，引用类型存储在堆中，以便进行垃圾回收。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:2:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3. 基本数据类型 Go 拥有 4 大类共7种基本数据类型 布尔类型 bool 数字类型： 整型 int，根据位数的不同包括 int8, int16, int32, int64 四种以及相对应的 uint 浮点型 float，包括 float32 和 float64 两种 复数 complex，包括 complex32 和 complex64 两种，复数类型并不常用 字符类型： byte，uint8 的别名，完全等同 rune，int32 是别名，完全等同 字符串类型 string ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.1 布尔类型 使用bool关键字声明，值只可以是常量 true 或 false var b bool = true 两个类型相同的值可以使用关系运算符来获得一个布尔类型的值。布尔类型的值之间也可以使用逻辑运算符来产生另一个布尔值，运算规则与其它语言相同。 类型相同是一个很严格的规定，涉及到了 Go 的比较规则，我们将 Go 中不可比较类型总结如下，除此之外，其它类型都是可比较的 切片类型 映射类型 函数类型 任何字段为不可比较类型的结构体类型，以及任何元素类型为不可比较类型的数组类型 对于接口而言，情况更加复杂一点，如果值的类型是接口，那么它们必须实现了相同的接口。如果条件不满足，则必须事先进行类型转换才可以比较。或者直接一点， 布尔值（以及任何结果为布尔值的表达式）最常用在流程控制的的条件语句中，如：if、for 和 switch 结构。 另外值得注意的一点是，Go 中的布尔值并不等于数字 1 和 0，因此不能直接进行运算。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:1","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.2 数字类型 Go 中数字类型分为三种，整型、浮点型和复数类型。 整型 整型提供有符号和无符号两种，每一种又分别提供对应 8、16、32、64bit 大小的四种类型，总计八种，列表如下 整型 无符号整型 int8（-128 -\u003e 127） uint8（0 -\u003e 255） int16（-32768 -\u003e 32767） uint16（0 -\u003e 65,535） int32（-2,147,483,648 -\u003e 2,147,483,647） uint32（0 -\u003e 4,294,967,295） int64（-9,223,372,036,854,775,808 -\u003e 9,223,372,036,854,775,807） uint64（0 -\u003e 18,446,744,073,709,551,615） 除此之外还提供两种不带位数的类型声明：int 和 uint。这两种类型的大小取决于所运行的平台处理器支持的字长，例如，在 32 位操作系统上，使用 32 位（4 个字节），在 64 位操作系统上，使用 64 位（8 个字节）。 尽管 int 有可能是 32 位，但在需要时 int 和 int32 之间也必须显式进行类型转换。 最后还有一种无符号整型 uintptr，它没有指定具体的 bit 大小但被设定为足够容纳一个指针。uintptr 类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方，一般用于指针计算。 int型是计算最快的类型，也是最常使用的类型。 浮点型 Go 语言中没有 float 类型，没有 double 类型，只有 float32 和 float64。它们的算术规范由IEEE-754标准定义，该标准被所有现代的 CPU 支持。 float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。通常应该优先使用 float64 类型，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。 复数类型 Go语言拥有两种复数类型，分别是 complex64（32 位实数和虚数）和 complex128（64 位实数和虚数）。 var c1 complex64 = 5 + 10i 内置的 complex 函数用于构建复数，内置的 real 和 imag 函数分别返回复数的实部和虚部： var cl complex128 = complex(1, 2) // 1+2i fmt.Println(real(cl)) // \"1\" fmt.Println(imag(cl)) // \"2\" cmath 包中包含了一些操作复数的公共方法。如果对内存的要求不是特别高，最好使用 complex128 作为计算类型，因为相关函数都使用这个类型的参数。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:2","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.3 字符类型 Go语言的字符有两种： byte 型，代表了 ASCII 码的一个字符。 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。 严格来说，字符只是整数的特殊用例。byte 类型是 uint8 的别名，刚好一个字节，足以表示传统 ASCII 编码的字符。例如：var ch byte = 'A'；rune是int32的别名，四个字节，足以表示最长的UTF-8字符。 另一方面，由于字符只是整数的别名，因此其零值也是 0。 字符使用单引号括起来。 包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 这些函数返回一个布尔值。包 utf8 拥有更多与 rune 相关的函数。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:3","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.4 字符串类型 字符串底层约定是字节的一个序列，编码方式建议是 UTF-8，但不是必须遵守，通常是ASCII。因此取字符串单个字符的类型通常是 byte，只有遇到中文等语言是才是 rune。另外，使用 for-range 结构遍历时字符串的单个字符类型是rune 字符串是值类型，且值不可变，即创建一个字符串后无法再次修改它的内容 Go 支持以下 2 种形式的字符串： 解释字符串：该类字符串使用双引号括起来，其中的转义字符将被替换，这些转义字符包括： \\n：换行符 \\r：回车符 \\t：tab 键 \\u 或 \\U：Unicode 字符 \\\\：反斜杠自身 非解释字符串：该类字符串使用反引号括起来，当使用多行字符串时使用这种形式。 a := `abc def` fmt.Println(a) // Output: abc def string 类型的零值为长度为零的字符串，即空字符串 \"\"。 Go 中的字符串是根据长度限定的，而非特殊字符\\0，其长度可以使用内置函数len()来获取，长度的基本含义是字符串在内存中所占字节的个数，所以下面的例子虽然是两个中文，但长度是6 a := \"中国\" fmt.Println(len(a)) // 6 可以将字符串看作数组而索引其内的单个字符，如第i个字节表示为str[i-1] 使用拼接符+可以拼接两个字符串，以下是一个多行字符串拼接的例子 str := \"Beginning of the string \" + \"second part of the string\" +必须放在第一行末尾，因为编译器会在行尾自动补全分号。当然，+=一样可用于字符串 s := \"hel\" + \"lo,\" s += \"world!\" fmt.Println(s) //输出 “hello, world!” 在循环中使用+拼接字符串并不是最高效的做法，更好的办法是使用string.join()，或者使用字节缓冲bytes.Buffer ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:4","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"3.5 类型别名 使用某个类型时可以给它起个别名在程序中使用，用于简化名称或解决名称冲突 在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。 package main import \"fmt\" type TZ int func main() { var a, b TZ = 3, 4 c := a + b fmt.Printf(\"c has the value: %d\", c) // 输出：c has the value: 7 } 实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法；TZ 可以自定义一个方法用来输出更加人性化的时区信息。 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:3:5","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4. 类型转换 Go语言中类型转换是可行的，但是不存在隐式类型转换，所有的转换都必须显式说明。类型转换的基本格式为 valueOfTypeB = typeB(valueOfTypeA) 两条转换原则如下 只有相同底层类型的变量间可以进行相互转换（如int16和int32），不同底层类型的变量相互转换会引发编译错误 类型转换只有从取值范围小的类型转换到取值范围大的类型才能成功，反过来会发生精度丢失（截断） var a,b int16 var c int32 A := int32(a) // 标准转换 B := bool(b) //类型不匹配，引发编译错误 C := int16(c) //取值范围变小，精度丢失 浮点型可以转换为整型，转换时会将小数部分去掉，只保留整数部分 a := 12.54 fmt.Println(int(a)) //输出12 精度丢失可以使用专门的函数保证安全，如int型到int8 func Uint8FromInt(n int) (uint8, error) { if 0 \u003c= n \u0026\u0026 n \u003c= math.MaxUint8 { // conversion is safe return uint8(n), nil } return 0, fmt.Errorf(\"%d is out of the uint8 range\", n) } 其它的类型转换则需要使用一些库函数 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:0","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.1 bool与string Go语言中bool类型值与数字1和0不等同，因此不能和数字类型相互转换（可以简单的使用if-else结构完成这一功能）。但借助strconv包，可以和string类型转换。 //string-\u003ebool b, err := strconv.ParseBool(\"true\") //bool-\u003estring s := strconv.FormatBool(true) 两个函数的原型如下 //ParseBool返回字符串代表的bool值，接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False作为传入参数，其他参数均返回error func ParseBool(str string) (bool, error) { switch str { case \"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\": return true, nil case \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\": return false, nil } return false, syntaxError(\"ParseBool\", str) } // FormatBool returns \"true\" or \"false\" according to the value of b. func FormatBool(b bool) string { if b { return \"true\" } return \"false\" } ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:1","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.2 int/float与string 与字符串相关的类型转换都是通过strconv包实现的。最常用的是Atoi(string to int)和Itoa(int to string)函数 i, err := strconv.Atoi(\"-42\") s := strconv.Itoa(-42) 函数原型如下 func Atoi(s string) (int, error) func Itoa(i int) string 字符串-\u003e数字类型 ParseFloat, ParseInt, 和ParseUint可以将字符串转化为对应的值 f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-42\", 10, 64) u, err := strconv.ParseUint(\"42\", 10, 64) 浮点型函数原型如下 func ParseFloat(s string, bitSize int) (float64, error) bitSize指定了返回值的类型，当bitSize=32，返回float32类型（结果仍是float64，但会转换为float32)；当bitSize=64，返回float64类型。只有这两种情况。 整型函数原型如下 func ParseInt(s string, base int, bitSize int) (i int64, err error) func ParseUint(s string, base int, bitSize int) (uint64, error) 如果base为0那么实际上base由string的前缀指定，0x意味着base=16，0意味着base=8，否则base=10，本质上是进制的前缀。若base等于1，小于0或超过36，返回一个error。 bitSize仍然指定返回值类型. 其值为 0, 8, 16, 32, 和 64 分别对应 int, int8, int16, int32和int64. bitSize值小于0或大于64，返回一个error。 数字类型-\u003e字符串 FormatFloat, FormatInt, 和FormatUint可以将值转换为字符串 s := strconv.FormatFloat(3.1415, 'E', -1, 64) s := strconv.FormatInt(-42, 16) s := strconv.FormatUint(42, 16) 浮点型的函数原型如下 func FormatFloat(f float64, fmt byte, prec, bitSize int) string bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。 fmt表示格式：‘b’ (-ddddp±ddd, 二进制指数), ‘e’ (-d.dddde±dd,十进制指数), ‘E’ (-d.ddddE±dd, 十进制指数), ‘f’ (-ddd.dddd, 没有指数), ‘g’ (指数很大时用‘e', 否则用 ‘f’ ), ‘G’ (指数很大时用‘E', 否则用 ‘f’ ). 精度prec控制数字的个数 (排除指数)。对’e', ‘E’, 和 ‘f’ ，表示小数点后的数字位数. 对 ‘g’ 和 ‘G’ 是有效数字位数 (trailing zeros are removed)。prec等于-1时则使用最少数量但又必须的数字来表示f。 整型的函数原型如下 func FormatInt(i int64, base int) string func FormatUint(i uint64, base int) string 返回base指定进制的整数i的字符串形式，2 \u003c= base \u003c= 36。使用小写字母 ‘a’ 到 ‘z’ 表示大于10的数字。 忽略可能出现的转换错误，可以给出如下例子： package main import ( \"fmt\" \"strconv\" ) func main() { var orig string = \"666\" var an int var newS string an, _ = strconv.Atoi(orig) fmt.Printf(\"The integer is: %d\\n\", an) an = an + 5 newS = strconv.Itoa(an) fmt.Printf(\"The new string is: %s\\n\", newS) } //输出： The integer is: 666 The new string is: 671 ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:2","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"4.3 []rune与string 用 for range 遍历字符串可以返回每个字符，返回的字符类型是 rune。但 []rune 类型也经常需要转换为 string，和单个 rune 类型相似，都可以直接进行显示类型转换，如下： a := []rune{'a', 'b', 'c'} b := 'g' c := string(a) d := string(b) fmt.Println(reflect.TypeOf(a), reflect.TypeOf(b), reflect.TypeOf(c), reflect.TypeOf(d)) fmt.Println(a, b, c, d) //Output []int32 int32 string string [97 98 99] 103 abc g ","date":"2019-10-22","objectID":"/2019/golang-syntax-3-constants-variables-and-elementary-types/:4:3","tags":["Go语法"],"title":"Golang语法基础3-常量变量与基本数据类型","uri":"/2019/golang-syntax-3-constants-variables-and-elementary-types/"},{"categories":["Golang学习之路"],"content":"本篇介绍Go中的基础命令，包和模块。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:0:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1. 命令 Go 在安装后自带一个命令行工具，名为 go，用来下载、编译、安装、测试 Go 的包和源文件，关于 Go CLI 的发展历史和设计理念，可以查看 About the go command，这里只介绍如何使用这些命令。 Go 命令的用法如下 go \u003ccommand\u003e [arguments] 可用命令如下，使用 go help \u003ccommand\u003e 可获取对应命令的帮助信息 bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages 其它的一些帮助主题如下，使用 go help \u003ctopic\u003e 可以查看相关主题的说明 buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum module-private module configuration for non-public modules packages package lists and patterns testflag testing flags testfunc testing functions 我们之前已经接触过几种命令，包括查看环境变量的 go env，查看go版本的 go version，用于编译和安装的go install和go build，已经对它们有了一定的了解，下面详细解释所有的命令，明确它们的作用，弄清楚它们的区别。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1.1 command 当前命令一共17个，使用 go help \u003ccommand\u003e可以查看这些命令的详细说明 go build go build [-o output] [-i] [build flags] [packages] go build 编译导入的包和依赖，但会忽略掉以 _test.go 结尾的文件，因为这些文件是用来测试的。 编译main包时，输出的可执行文件会放到当前目录下，可执行文件的后缀取决于操作系统，只有在windows下后缀才会是.exe，而可执行文件的名字同编译的go文件名相同，如ed.go会编译成ed.exe。 编译多个包或单个非main包时，编译器不会输出可执行文件，仅仅作为这些包是否可编译的一个检查。 以 hello world 程序为例，编译后的 hello.exe 文件位于项目根目录下 $ go build github.com/shuzang/hello $ ls go.mod go.sum gotest.exe main.go 加入 -o 参数可以指定输出文件，-i则在编译后自动执行安装过程（默认只会编译不会安装） go install go install 命令在编译的基础上增添了安装这一步，安装 的基本含义是将生成的可执行文件放到指定的目录，默认为 GOBIN 环境变量指定的目录，即 $GOPATH/bin。仍以hello为例，如下命令执行后，hello.exe文件将位于$GOPATH/bin目录下 \u003e go install github.com/shuzang/hello go get go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages] go get 相比 go install 又多了一步：解析与添加依赖到当前包。完成这一步后自动编译和安装它们。 go get 下载的默认路径是 GOPATH/pkg/mod ，默认下载最新版本，但版本的选择规则比较复杂，可以查看命令说明。下面是一个使用实例 \u003e go get -v github.com/google/codesearch/index github.com/google/codesearch (download) github.com/google/codesearch/sparse github.com/google/codesearch/index -v参数输出下载安装的详细过程，并输出debug信息，其它的一些可选参数说明如下 -d只下载不安装 -fix在对下载的包解析依赖项或编译前先运行修复工具 -t下载为指定的包生成测试需要的包 -u用于更新已有的包和依赖 go run 以上三个命令虽然都包含编译过程，但也到此为止，在生成可执行文件后将不再做任何操作，需要自己来执行。go run命令则在编译后直接执行运行操作，以hello为例 \u003e go run github.com/shuzang/hello Hello, Go! go version go version在没有参数时，会打印自身的版本信息 \u003e go version go version go1.13.4 windows/amd64 但是go version后也可以跟一个目录，这时会递归的查找该目录下的可执行文件，并打印它们的版本信息，以bin目录为例 PS C:\\Users\\lylw1\\go\u003e go version bin bin\\cobra.exe: go1.13.4 bin\\dlv.exe: go1.13.4 bin\\go-outline.exe: go1.13.4 bin\\go-symbols.exe: go1.13.4 bin\\gocode-gomod.exe: go1.13.4 bin\\gocode.exe: go1.13.4 bin\\godef.exe: go1.13.4 bin\\golint.exe: go1.13.4 bin\\gopkgs.exe: go1.13.4 bin\\gorename.exe: go1.13.4 bin\\goreturns.exe: go1.13.4 bin\\guru.exe: go1.13.4 bin\\hello.exe: go1.13.4 添加-m参数会打印包导入的模块信息，添加-v参数会将无法识别的文件信息也打印出来，以stringutil为例 \u003e go version -v src/github.com/shuzang/stringutil src\\github.com\\shuzang\\stringutil\\reverse.go: not executable file go env go env [-json] [-u] [-w] [var ...] go env的基本作用是打印go的环境变量信息，添加-json参数可以以 JSON 的格式打印，但没有默认的脚本形式可读性高。添加 -w 参数可以设置某个环境变量的值，比如 \u003e go env -w GOPATH=d:\\go 与之相反，重置某个环境变量为默认值可以使用-u参数 \u003e go env -u GOPATH 其它 其它的命令使用频率没有上面几个高，因此只简单介绍其作用，用的时候再去查用法即可，go test和go mod两个命令以后单独介绍。 go bug，作用是打开默认浏览器并启动新的 Bug 报告，该报告包含有用的系统信息。 go clean，移除源码包中编译生成的文件 go doc，显示包或符号的文档 go fix，用来更新老版本的代码到新版本 go fmt，go的代码有严格的格式要求，该命令用来做格式化，但一般IDE都会帮忙做这件事 go generate，通过处理源码生成go文件 go list，列出当前安装的包或模块 go mod，模块维持 go test，自动读取源码目录下名为*_test.go的文件进行测试 go tool，运行指定的go工具，后面跟的参数是其它命令 go vet，用于检查Go语言源码中的静态错误 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1.2 topic topic有15个，本质是对Go中的一些概念作解释，所以它实际上是一些文档说明，使用go help \u003ctopic\u003e查看，这些topic包括 buildmode：构建模式的描述 c：Go和c的相互调用 cache：构建和测试缓存 environment：环境变量 filetype：文件类型 go.mod：go.mod文件 gopath：GOPATH环境变量 gopath-get： goproxy：模块代理协议 importpath：导入路径语法 modules：模块，模块版本等 modules-get： packages：包列表的描述 testflag：测试符号描述 testfunc：测试函数描述 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:1:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2. 包 包是Go语言代码组织和代码编译的一个基本结构，一个包可能由一个或多个.go文件组成，而一个或多个包可以构成完整的项目(仓库)。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.1 包名 每个Go源文件(.go文件)都必须在非注释的首行声明属于哪个包 package name name就是包名，包名的命名遵循命名规范，而且不得使用大写字母。每个Go应用程序都必须包含一个main包 一个Go程序通过import关键字将一组包衔接在一起，如 import \"fmt\" 包名需要用双引号包围，多个包可以使用多个import语句，也可以使用一个小括号全部放在一起，如 import ( \"fmt\" \"os\" \"crypto/rot13\" \"github.com/shuzang/hello\" ) 包名也是导入路径的最后一个字段，比如crypto/rot13，其包名为rot13；github.com/shuzang/hello，其包名为hello 没有必要刻意使用不同的包名，只要导入路径保持唯一即可 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.2 标准库 像 fmt、os 等这样具有常用功能的内置包在 Go 语言中有 150 个以上，它们被称为标准库，大部分内置于Go本身，位于C:\\Go\\pkg\\windows_amd64，即$GOROOT/pkg/$GOOS__$GOARCH目录下，不需要额外的下载、安装和编译，详细列表和说明可以在 Go Packages 查看，这里简单介绍一些常用包的基本功能 unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中 系统操作类 os: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致 os/exec: 提供我们运行外部操作系统命令和程序的方式 syscall: 底层的外部包，提供了操作系统底层调用的基本接口 archive/tar 和 /zip-compress：压缩(解压缩)文件功能。 输入输出类 fmt: 提供了格式化输入输出功能 io: 提供了基本输入输出功能，大多数是围绕系统功能的封装 bufio: 缓冲输入输出功能的封装 path/filepath: 用来操作在当前系统中的目标文件名路径 flag: 对命令行参数的操作　 字符串操作类 strings: 提供对字符串的操作 strconv: 提供将字符串转换为基础类型的功能 unicode: 为 unicode 型的字符串提供特殊的功能 regexp: 正则表达式功能 bytes: 提供对字符型分片的操作 index/suffixarray: 子字符串快速查询 数学 math: 基本的数学函数 math/cmath: 对复数的操作 math/rand: 伪随机数生成 sort: 为数组排序和自定义集合 math/big: 大数的实现和计算 数据结构 list: 双链表 ring: 环形链表 时间 time: 日期和时间的基本操作 log: 记录程序运行时产生的日志,我们将在后面的章节使用它 编/解码 encoding/json: 读取并解码和写入并编码 JSON 数据 encoding/xml:简单的 XML1.0 解析器 text/template:生成像 HTML 一样的数据与文本混合的数据驱动模板 网络 net: 网络数据的基本操作。 http: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。 html: HTML5 解析器 runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建。 reflect: 实现通过程序运行时反射，让程序操作任意类型的变量。 Go的生态远不止这些标准库，社区里存在大量的第三方包或项目，在开发自己的项目时，最好先查找下是否有已存在的第三方包或可用的库。 Go Walker 支持根据包名在海量数据中查询。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.3 导入包 导入包的基本格式如下 import \"包的路径或 URL 地址\" ”包的路径“指可以是以下这种形式 import \"./pack1/pack1\" 而URL地址指的是下载的外部安装包 import \"github.com/org1/pack1” 导入时可以对包进行重命名，比如 import packx \"github.com/org1/pack1” 也可以重命名为两种特殊符号：.和_，前者可以在使用时省略包名，直接使用对外部可见的函数和变量，后者则只执行其中的init函数和初始化其全局变量，无法调用函数 import . \"./pack1\" import _ \"./pack1/pack1\" ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:3","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"2.4 使用脚本编译或安装 在 Linux/OS X 下可以用 Makefile 脚本 实现自动检测机器架构并调用正确的编译器和链接器 include $(GOROOT)/src/Make.inc TARG=pack1 GOFILES=\\ pack1.go\\ pack1b.go\\ include $(GOROOT)/src/Make.pkg 通过 chmod 777 ./Makefile确保它的可执行性，然后在终端使用make工具 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:2:4","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3. 模块 自 Go 1.11 起，开始支持使用 Go Module 进行包管理，这里参考 Go Blog 中的 Using Go Modules 一文对其进行介绍。 模块(module)通过项目根目录下go.mod文件起作用，项目中使用的所有包的集合都在该文件中定义。go.mod文件定义了模块路径，用于项目中包的导入路径。以 delve 的go.mod文件为例 module github.com/go-delve/delve go 1.10 require ( github.com/cosiner/argv v0.0.0-20170225145430-13bacc38a0a5 github.com/cpuguy83/go-md2man v1.0.8 // indirect github.com/inconshreveable/mousetrap v1.0.0 // indirect github.com/kr/pretty v0.1.0 // indirect github.com/mattn/go-colorable v0.0.0-20170327083344-ded68f7a9561 github.com/mattn/go-isatty v0.0.3 github.com/onsi/ginkgo v1.8.0 // indirect github.com/onsi/gomega v1.5.0 // indirect github.com/peterh/liner v0.0.0-20170317030525-88609521dc4b github.com/pkg/profile v0.0.0-20170413231811-06b906832ed0 github.com/russross/blackfriday v0.0.0-20180428102519-11635eb403ff // indirect github.com/sirupsen/logrus v0.0.0-20180523074243-ea8897e79973 github.com/spf13/cobra v0.0.0-20170417170307-b6cb39589372 github.com/spf13/pflag v0.0.0-20170417173400-9e4c21054fa1 // indirect github.com/stretchr/testify v1.3.0 // indirect go.starlark.net v0.0.0-20190702223751-32f345186213 golang.org/x/arch v0.0.0-20171004143515-077ac972c2e4 golang.org/x/crypto v0.0.0-20180614174826-fd5f17ee7299 // indirect golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb golang.org/x/tools v0.0.0-20181120060634-fc4f04983f62 gopkg.in/airbrake/gobrake.v2 v2.0.9 // indirect gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect gopkg.in/gemnasium/logrus-airbrake-hook.v2 v2.1.2 // indirect gopkg.in/yaml.v2 v2.2.1 ) 注意，使用模块进行包管理独立于原来的使用 gopath 进行包管理，可以在任意位置建立项目。如果go.mod文件放在$GOPATH/src，即原来的统一工作区，是不起作用的，会被旧的GOPATH模式屏蔽。自 Go 1.13 开始，module 模式已经成为了 Go 开发的默认模式。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:0","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.1 创建新模块 在$GOPATH/src外的任意位置创建项目目录，cd进入该目录，创建hello.go文件 package hello func Hello() string { return \"Hello, world.\" } 为它写一个测试文件hello_test.go package hello import \"testing\" func TestHello(t *testing.T) { want := \"Hello, world.\" if got := Hello(); got != want { t.Errorf(\"Hello() = %q, want %q\", got, want) } } 现在，项目中有了一个包，因为项目目录位于F:/hello，执行go test的结果如下 $ go test PASS ok _/F_/hello 0.240s 因为我们在 $GOPATH 外进行的测试，而且现在还没有go.mod文件，所以Go命令不知道导入路径，只能根据目录名生成一个导入路径。现在我们来创建go.mod文件并再次执行go test命令 $ go mod init example.com/hello go: creating new go.mod: module example.com/hello $ go test PASS ok example.com/hello 0.214s go mod init命令用于创建go.mod文件，初始化Go模块，其内容如下 $ pwd /f/hello $ ls go.mod hello.go hello_test.go $ cat go.mod module example.com/hello go 1.13 go.mod文件位于项目根目录，其中的模块路径也只显示到项目根目录，子目录中包的导入路径由模块路径+子目录路径组成。我们在当前项目目录下创建world子目录，其导入路径将会是example.com/hello/world ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:1","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.2 添加依赖 使用Go模块的首要目的是提升别的开发者使用我们编写的代码的体验。编辑hello.go文件，导入rsc.io/quote，然后用它来实施Hello package hello import \"rsc.io/quote\" func Hello() string { return quote.Hello() } 现在运行go test $ go test go: finding rsc.io/quote v1.5.2 go: downloading rsc.io/quote v1.5.2 go: extracting rsc.io/quote v1.5.2 go: finding rsc.io/sampler v1.3.0 go: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: downloading rsc.io/sampler v1.3.0 go: extracting rsc.io/sampler v1.3.0 go: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c go: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c PASS ok example.com/hello 0.023s Go使用go.mod文件中列举的依赖模块版本来解析导入的包，但是当在go.mod文件中找不到这个包是，就会自动的查找包含这个包的模块的最新版本，然后添加到go.mod文件。上例中自动下载了模块rsc.io/quote v1.5.2，还下载了它依赖的两个其它模块：rsc.io/sampler和golang.org/x/text。不过只有直接依赖会被记录到go.mod文件 $ cat go.mod module example.com/hello go 1.13 require rsc.io/quote v1.5.2 下载的包位于$GOPATH/pkg/mod，再次运行go test命令，就不会重新下载了，因为已经存在。 $ go test PASS ok example.com/hello 0.020s 需要注意的是，尽管使用模块使得添加包管理简单轻松，但并非没有代价，当前代码的安全性、正确性和许可等都依赖于导入的模块，关于这个问题的详细描述可以查看 Our Software Dependency Problem. 如上所述，添加一个直接依赖通常会引入一些间接的依赖，使用go list -m all可以列举当前模块和它们所有的依赖。 $ go list -m all example.com/hello golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c rsc.io/quote v1.5.2 rsc.io/sampler v1.3.0 在go list的输出中，当前模块是主模块，总是位于第一行，其它的模块按模块路径顺序显示。 go.mod文件外，Go还维持一个名为go.sum的文件，包含特定模块版本内容的加密哈希。Go使用该文件确保将来下载该模块时内容与第一次下载的内容相同，从而保证所依赖的模块没有被恶意或非恶意的更改。 $ ls go.mod go.sum hello.go hello_test.go $ cat go.sum golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO... golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq... rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3... rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX... rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q... rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9... go.mod和go.sum文件都应该包含到版本控制系统中，也就是说随着源代码文件一起提交到远程仓库。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:2","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.3 更新依赖 Go模块使用的版本号分三部分：主版本号(major)，次版本号(minor)和修订版本号(patch)。例如，v0.1.2，主版本号是0，次版本号是1，修订版本号是2。首先以一个次版本号的更新举例说明 前面go list -m all的输出中我们可以看到golang.org/x/text使用的不是标准的版本号，我们可以使用go get命令将其更新 $ go get golang.org/x/text go: finding golang.org/x/text v0.3.0 go: downloading golang.org/x/text v0.3.0 go: extracting golang.org/x/text v0.3.0 $ go test PASS ok example.com/hello 0.013s 现在再次列举所有的模块以及查看go.mod文件 $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote v1.5.2 rsc.io/sampler v1.3.0 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote v1.5.2 ) 可以看到两者中golang.org/x/text都已经更新到了最新的版本号v0.3.0，注释中的indirect说明这个依赖不是直接被引用的，只是被其它的模块间接引用。 现在我们更新rsc.io/sampler的次版本号 $ go get rsc.io/sampler go: finding rsc.io/sampler v1.99.99 go: downloading rsc.io/sampler v1.99.99 go: extracting rsc.io/sampler v1.99.99 $ go test --- FAIL: TestHello (0.00s) hello_test.go:8: Hello() = \"99 bottles of beer on the wall, 99 bottles of beer, ...\", want \"Hello, world.\" FAIL exit status 1 FAIL example.com/hello 0.014s 测试失败说明版本不匹配，列举所有可用版本 $ go list -m -versions rsc.io/sampler rsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99 之前使用的是v1.3.0，v1.99.99也被证明无法使用，因此换用v1.3.1 $ go get rsc.io/sampler@v1.3.1 go: finding rsc.io/sampler v1.3.1 go: downloading rsc.io/sampler v1.3.1 go: extracting rsc.io/sampler v1.3.1 $ go test PASS ok example.com/hello 0.022s 通过@来指定具体的版本号，go get的参数实际上应该带有版本号，不明确指定会使用默认的@latest，从而使用最新版本。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:3","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.4 在主版本号上添加依赖 主版本号的更新是不同的，会看作一个独立的依赖。在hello.go中添加一个新的函数Proverb()，它使用了rsc.io/quote的v3版本，导入格式为rsc.io/quote/v3 package hello import ( \"rsc.io/quote\" quoteV3 \"rsc.io/quote/v3\" ) func Hello() string { return quote.Hello() } func Proverb() string { return quoteV3.Concurrency() } 然后为其添加测试函数 func TestProverb(t *testing.T) { want := \"Concurrency is not parallelism.\" if got := Proverb(); got != want { t.Errorf(\"Proverb() = %q, want %q\", got, want) } } 测试结果如下 $ go test go: finding rsc.io/quote/v3 v3.1.0 go: downloading rsc.io/quote/v3 v3.1.0 go: extracting rsc.io/quote/v3 v3.1.0 PASS ok example.com/hello 0.024s 现在我们的模块同时依赖于rsc.io/quote和rsc.io/quote/v3 $ go list -m rsc.io/q... rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.1.0 Go模块的每个主版本号(v1, v2, and so on)都使用一个不同的模块路径，从v2开始，路径必须以主版本号结尾，比如rsc.io/quote的v3版本模块路径为rsc.io/quote/v3，这种惯例称作 semantic import versioning ，给不兼容的包提供了不同的名字。相反，同一个主版本号，如v1.6.0应该向前兼容，和rsc.io/quote使用同一个名字，在同一个项目中，每个主版本号Go只允许出现一种，比如v1.5.2和v1.6.0不能同时存在，但不同的主版本号可以同时存在，这是为了使程序可以逐步过渡到新的版本。 ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:4","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.5 更新依赖到新的主版本号 比如从rsc.io/quote迁移到rsc.io/quote/v3，由于大版本更新，某些不兼容的API可能被删除、重命名或做其它的更改，阅读文档，我们可以发现HelloV3相对于Hello做了如下改动 $ go doc rsc.io/quote/v3 package quote // import \"rsc.io/quote\" Package quote collects pithy sayings. func Concurrency() string func GlassV3() string func GoV3() string func HelloV3() string func OptV3() string 检查并更新我们的源码 package hello import quoteV3 \"rsc.io/quote/v3\" func Hello() string { return quoteV3.HelloV3() } func Proverb() string { return quoteV3.Concurrency() } 由于没有冲突，这里导入的包不再需要重命名，因此可以继续简化 package hello import \"rsc.io/quote/v3\" func Hello() string { return quote.HelloV3() } func Proverb() string { return quote.Concurrency() } 运行测试 $ go test PASS ok example.com/hello 0.014s ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:5","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"3.6 移除不使用的依赖 我们已经不再使用rsc.io/quote，但它依然存在于go list -m all的输出和go.mod文件中 $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote v1.5.2 rsc.io/quote/v3 v3.0.0 rsc.io/sampler v1.3.1 // indirect ) 这是因为编译单个包时无法自动检测是否可以安全的移除某个包，只能通过手动执行go mod tidy命令清理不再使用的依赖 $ go mod tidy $ go list -m all example.com/hello golang.org/x/text v0.3.0 rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 $ cat go.mod module example.com/hello go 1.12 require ( golang.org/x/text v0.3.0 // indirect rsc.io/quote/v3 v3.1.0 rsc.io/sampler v1.3.1 // indirect ) $ go test PASS ok example.com/hello 0.020s $ 最后是关于发布自己的模块版本的注意，参考两篇文章 Publishing Go Modules Go Modules: v2 and Beyond ","date":"2019-09-19","objectID":"/2019/golang-basic-grammer-2-command-package-module/:3:6","tags":["Go语法"],"title":"Golang语法基础2-命令、包与模块","uri":"/2019/golang-basic-grammer-2-command-package-module/"},{"categories":["Golang学习之路"],"content":"1. 起源与发展 Go/Golang 起源于2007年，并于2009年正式对外发布，是一个完全开源的项目，背后的支持者是谷歌公司，核心设计者是三位著名IT工程师：Ken Thompson，Rob Pike，Robert Griesemer。分别是如下从左到右三位 其中 Ken Thompson 是 Unix 操作系统的设计者，并因此获得图灵奖，也是C语言前身B语言的设计者，UTF-8 编码设计者之一，计算机史的重要人物，2006年加入谷歌，和另外两人一起设计了Go语言。 Rob Pike 是 Ken 的老搭档。 随后又有 lan Lance Taylor 和 Russ Cox 两人加入团队，前者是 gccgo 编译器的作者和 cgo工具链的维护者，后者加入团队后着手Go语言标准库的开发。下图分别是他们两个 Go语言以囊地鼠(Gopher)为图标和吉祥物，这是一种原产于加拿大的啮齿类动物，Go语言开发者也一般自称为 Gopher。下图中左边是囊地鼠，右边是 Go logo. Go语言相比于其它语言的最大优势在于它的执行性能与开发效率，这得益于Go在并发编程、内存回收等许多方面的良好设计，并因此大规模用于服务器编程、网络编程、数据库和云平台领域。 比较出名的Go语言项目有(不限于这些) Go语言本身： https://github.com/golang/go Docker： https://www.docker.com/ kubernetes： https://github.com/kubernetes/kubernetes Ethereum： https://github.com/ethereum/go-ethereum fabric： https://github.com/hyperledger/fabric Hugo： https://github.com/gohugoio/hugo TiDB： https://github.com/pingcap/tidb InfluxDB： https://github.com/influxdata/influxdb ETCD： https://github.com/etcd-io/etcd 使用Go的国外公司有：Google, Docker, NetFlix, CloudFlare, Dropbox, MongoDB, Uber等 使用Go的国内公司有：七牛、字节跳动、bilibili、京东、百度，其它公司如小米、腾讯、阿里等也都在使用Go，但可能不是主力 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:1:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"2. 跟踪最新动态 最直接的方式是跟踪Go语言的源码库，关注提交历史和issue 原始代码库： https://go.googlesource.com/go github镜像： https://github.com/golang/go 其它活跃论坛或动态 golang-dev：Google邮件列表的Go开发组讨论区 golang-nuts：Google邮件列表的Go讨论社区 golang-announce：发布Go版本或Go开发的最新状态 go.dev：刚刚上线(2019.11.14)的Go开发人员中心 gotime：Go的一个播客，每周一更，内容有干货 @golang：Go 语言在 Twitter 的官方帐号 此外还有每年举办的几个大会 Gopher Con，举办地在美国，时间不定，今年在7月，2020年会在6月份举行。会议总结 GopherChina，举办地在中国，每年4月份。会议总结 dotGo，举办地在欧洲，每年3月份 详细的会议列表可查看 https://github.com/golang/go/wiki/Conferences Go 下载地址和相关的文档、标准库等访问地址为 官网 https://golang.org/ 国内的镜像网站 https://golang.google.cn/ Go语言中文网 是国内最活跃的Go社区，每周会发行一份Go语言爱好者周刊 Go相关资料聚集最多的还是go wiki ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:2:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3. 下载安装 Windowns下快速安装可以使用 chocolatey ，执行如下命令即可 \u003e choco install golang 自动配置环境变量，安装完重启终端即可使用。下面开始介绍常规的安装方法，以win10和Ubuntu为例。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.1 下载 Golang中国官网下载页面为 golang.google.cn/dl，为windows，macOS和Linux三种环境都提供了安装包。 windows默认下载文件为go1.14.windows-amd64.msi，双击启动即可安装，默认安装位置为C:\\Go，环境变量将自动设置。但如果下载了以.zip为后缀的版本，则需要自己解压到合适的路径，并自己设置环境变量。 Linux默认下载文件为go1.14.linux-amd64.tar.gz，将其解压缩到/usr/local，然后手动将/usr/local/go/bin添加到 PATH 环境变量中。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:1","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.2 安装 windows msi后缀的安装版本双击安装，环境变量将会自动设置，打开powershell，使用go env命令查看环境变量 \u003e go env set GO111MODULE= set GOARCH=amd64 set GOBIN= set GOCACHE=C:\\Users\\lylw1\\AppData\\Local\\go-build set GOENV=C:\\Users\\lylw1\\AppData\\Roaming\\go\\env set GOEXE=.exe set GOFLAGS= set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOINSECURE= set GONOPROXY= set GONOSUMDB= set GOOS=windows set GOPATH=C:\\Users\\lylw1\\go set GOPRIVATE= set GOPROXY=https://goproxy.cn,direct set GOROOT=c:\\go set GOSUMDB=sum.golang.org set GOTMPDIR= set GOTOOLDIR=c:\\go\\pkg\\tool\\windows_amd64 set GCCGO=gccgo set AR=ar set CC=gcc set CXX=g++ set CGO_ENABLED=1 set GOMOD= set CGO_CFLAGS=-g -O2 set CGO_CPPFLAGS= set CGO_CXXFLAGS=-g -O2 set CGO_FFLAGS=-g -O2 set CGO_LDFLAGS=-g -O2 set PKG_CONFIG=pkg-config set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\lylw1\\AppData\\Local\\Temp\\go-build192094374=/tmp/go-build -gno-record-gcc-switches 使用 go version 查看版本同时验证安装 \u003e go version go version go1.13.4 windows/amd64 Linux 以Ubuntu 20.04 LTS 为例说明，首先在 golang.org/dl 页面右击要下载的版本获取下载链接，使用wget下载文件。也可以直接下载。 $ wget https://dl.google.com/go/go1.14.linux-amd64.tar.gz 将文件解压缩到指定目录/usr/local，-C参数用于指定目标文件夹，解压缩后删除压缩文件。 $ sudo tar -xzf go1.14.linux-amd64.tar.gz -C /usr/local $ rm go1.14.linux-amd64.tar.gz 查看安装目录 $ ls /usr/local bin etc games go include lib man sbin share src $ ls /usr/local/go AUTHORS CONTRIBUTORS PATENTS SECURITY.md api doc lib pkg src CONTRIBUTING.md LICENSE README.md VERSION bin favicon.ico misc robots.txt test 设置环境变量 $ sudo nano /etc/profile # 在打开的文件末尾添加下列语句 export PATH=$PATH:/usr/local/go/bin 更新的环境变量可以通过下面的命令使其直接生效 $ source /etc/profile # 查看生效后的环境变量设置 $ go version go version go1.14 linux/amd64 Linux 全部环境变量如下 $ go env GO111MODULE=\"\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/home/shuzang/.cache/go-build\" GOENV=\"/home/shuzang/.config/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOINSECURE=\"\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"linux\" GOPATH=\"/home/shuzang/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/usr/local/go\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/linux_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"gcc\" CXX=\"g++\" CGO_ENABLED=\"1\" GOMOD=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build153919612=/tmp/go-build -gno-record-gcc-switches\" 注：将环境变量添加到/etc/profile可使go全局启用，也可添加到$HOME/.profile，对当前登录用户起作用。 注：可以使用apt-get命令安装，但安装的go不会是最新版本，同样，也可以使用snap安装，可以安装最新版本。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:2","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.3 环境变量说明 常规的使用除了GOPATH外无需关心其它环境变量，但在进行交叉编译时，需要进行一定的设置，详细的环境变量说明可以查看 $GOPATH environment variable set correctly，以下解释几个主要的环境变量。 GOOS与GOARCH：目标操作系统和处理器架构， GOHOSTOS和GOHOSTARCH是宿主机操作系统和处理器架构。 GOBIN：编译器和链接器的安装位置，默认是$GOROOT/bin，一般将其设置为空值，Go会使用默认值。 GOROOT：电脑上安装的Go的根目录，Linux下一般为$HOME/go，windows下为C:\\go GOPATH：go install、go get等命令默认路径都是GOPATH，是编译后二进制文件的存放目的地、下载后包的存放路径以及 import 包时的搜索路径 我们需要关心的唯一一个环境变量是GOPATH，可以看到，默认的GOPATH是c:\\Users\\lylw1\\go，其中lylw1是自己的用户名。 GOPATH 所代表的路径是 go 的工作区，可以选择任意自己喜欢的文件夹作为go的工作区，如果不想使用默认的路径，需要自己进行修改，使用 go env 命令 \u003e go env -w GOPATH=/somewhere/else 更多的环境变量修改方式可以查看Setting GOPATH，需要注意的一点是GOPATH不能设置为Go的安装目录C:\\go ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:3","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.4 安装目录清单 安装完成的Go根目录（$GOROOT）文件夹结构除了README.md，AUTHORS，LICENSE等常规文件外，基本结构应如下所示： /bin：包含可执行文件，如：编译器，Go 工具 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例 /pkg/os_arch：包含标准库的包的对象文件（.a） /src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言） /src/cmd：包含 Go 和 C 的编译器和命令行脚本 这是之前的介绍，网上搜到的多是这个说明，但当前还多了api和test两个文件夹。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:4","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"3.5 代码目录结构 Go 1.13之前，所有代码在一个工作区，Go 1.13及之后，使用 Go module 进行管理，项目代码不再必须放到 GOPATH 下。本文假设使用 Go 1.13 及以后的版本。对于之前的方式不再介绍。 Go 程序以包（package）的形式进行组织，一个包就是一个目录，该目录下可能有一个或多个源文件，同一个包的所有代码会被一起编译。另外，同一个包中定义的变量、常量、类型、函数，即使在不同的源文件中，也可以相互访问。 Go 项目以模块的方式进行组织，模块（module）是一组相关包的集合。一个项目通常是一个仓库（repository），而一个 Go 仓库（repository）只能包含一个模块，但可导入使用多个其它模块，仓库根目录下的 go.mod 文件用来声明这些导入模块的路径。和 go.mod 文件一起位于仓库根目录的是一个一个的子目录，每个子目录可能是一个包，也可能是一个子模块，是否为子模块要看子目录下是否存在 go.mod 文件。 值得注意的是，尽管项目代码以仓库的方式进行组织，但在编写完成构建之前，代码不需要上传到云端，模块可以本地存在，仓库形式仅仅是因为我们总有一天会将代码上传到云的。 模块的路径不仅作为导入路径，同样也说明了模块的下载路径，比如 golang.org/x/tools， Go 命令将知道从 https://golang.org/x/tools 去下载它。包的导入路径是模块路径 + 包名，比如，模块 github.com/google/go-cmp 包含一个包（子目录）cmp，这个包的导入路径就是 github.com/google.go-cmp/cmp。Go 的标准库导入不需要模块路径前缀，可以仅使用包名。 最后，所有的模块都会下载到 GOPATH 的 pkg/mod 目录下，并被所有项目共享，因此，模块代码是只读的。 本部分说明可以阅读第二篇文章后再来看。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:3:5","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"4. 第一个程序 编辑并运行我们的第一个程序，按照编程界的惯例，输出hello, world!。 首先创建项目文件夹并初始化模块，模块路径自行选择 $ mkdir hello $ cd hello $ go mod init example.com/user/hello go: creating new go.mod: module example.com/user/hello $ cat go.mod module example.com/user/hello go 1.14 $ 然后在该目录下创建hello.go文件，使其包含如下代码 package main import \"fmt\" func main() { fmt.Println(\"Hello, world.\") } 使用go install命令编译安装 \u003e go install github.com/shuzang/hello 该命令会编译程序并产生一个二进制包，然后将该二进制包安装到 $HOME/go/bin/hello ，如果是 Windows，会安装到 %USERPROFILE%\\go\\bin\\hello.exe。 安装目录受 GOPATH 和 GOBIN 影响，如果 GOBIN 被设置，则二进制包会被安装到设置的目录，如果 GOPATH 被设置，二进制包将按照到 GOPATH 列表的第一个目录的 bin 子目录，如果都没有被设置，就会安装到默认 GOPATH 的 bin 子目录($HOME/go or %USERPROFILE%\\go)。 go install 命令执行需要在仓库根目录下，且下面三个命令是等效的 $ go install example.com/user/hello $ go install . $ go install 将$GOPATH/bin添加到电脑的PATH环境变量中，这样可以直接执行 $ hello Hello, world! 可能是因为我使用chocolatey安装的原因，这一环境变量也已经自动设好了，所以我可以直接执行命令。 完成编辑后，就可以使用版本控制工具初始化仓库并上传代码了，示例如下（这一步不是必须的） $ git init Initialized empty Git repository in C:/Users/lylw1/go/src/github.com/shuzang/hello/.git/ $ git add go.mod hello.go $ git commit -m \"initial commit\" [master (root-commit) 0b4507d] initial commit 1 file changed, 7 insertion(+) create mode 100644 go.mod hello.go 一种最方便的方式是将模块路径与仓库路径匹配，比如将以上模块声明为 github.com/username/hello，多数版本控制服务商都支持这种格式。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:4:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5. 编辑器/IDE Golang 开发最流行的两个工具是 Goland 和 VScode，我自己是 VScode 的使用者。除了这两个工具外，官方还提供了一份IDE和插件列表。 VScode 中的 Go 扩展提供了大量的特性，如自动补全、悬停信息显示、括号匹配等，原本属于第三方开发者维护，现在交给了 Go 团队。详细的特性说明查看官网，下面进行一些简单介绍。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:0","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.1 Go工具链 微软在开发 VS Code 过程中, 定义了一种协议： 语言服务器协议 ，用来为每种语言提供诸如自动完成，代码提示等功能。gopls 就是Go语言的服务器, 安装命令为 $ go get -v golang.org/x/tools/gopls 事实上，编辑 Go 代码时如果没有安装，VScode 会在右下角弹出提示，只要直接点击 Install 即可，不需要自己输入命令。同时，因为没有设置go.toolsGopath，默认使用了 GOPATH 作为安装路径 go.toolsGopath setting is not set. Using GOPATH C:\\Users\\lylw1\\go Installing 1 tool at C:\\Users\\lylw1\\go\\bin in module mode. gopls Installing golang.org/x/tools/gopls SUCCEEDED Reload VS Code window to use the Go language server All tools successfully installed. You're ready to Go :). Go代码的调试需要 delve 工具 $ go get -v github.com/go-delve/delve/cmd/dlv 除此之外，还有一批需要安装的分析工具，如下 # Below tools are needed for the basic features of the Go extension. gocode gopkgs go-outline gocode-gomod godef goreturns 所有这些工具只需要在右下角弹出提示后点击 Install 即可 不过上述提到的很多插件不翻墙都无法下载，可以自己手动到github下载然后解压到GOPATH/src，建立起对应的目录结构，然后运行go install将其安装 微软设置了默认的代理服务器，现在(2020.03.18)所有插件均可在不翻墙的情况下顺利安装，而且速度很快 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:1","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.2 用户和工作区设置 使用 VScode 需要关心的一个重要部分是用户和工作区设置，几乎所有的事情都和它们有关。 这是两种不同的设置范围 用户设置：是一个全局的设置，适用于打开的任何VScode窗口 工作区设置：如题，项目工作区的设置，只适用于对应的工作区 工作区的设置会覆盖掉用户设置，它针对具体的项目，配置文件位于项目根目录.vscode文件夹，可与其它开发者共享。.vscode文件夹还用于存放调试配置和任务配置。 点击左下角的齿轮，选择设置，默认的设置界面如上，是一个可视化的界面，不过也可以使用settings.json配置文件 用户设置文件在windows中位于%APPDATA%\\Code\\User\\settings.json 工作区设置文件位于根目录的.vscode文件夹中 最后，VScode大量的操作都可以通过命令完成，使用快捷键Ctrl+Shift+P可以打开命令输入框。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:2","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.3 特性说明 在用户或工作区设置中，将 go.autocompleteUnimportedPackages 设为true ，可以在代码中点击包名跳转查看包的具体内容。 鼠标悬停在变量、函数和结构体的名称上方可以查看它们的签名等信息，这一功能由前面安装的godef工具实现，同样可完成这一功能的工具还有godoc和gogetdoc，通过在用户或工作区设置中调整go.docsTool来切换工具。 代码导航功能无需设置默认实现。 对源码的保存操作会自动触发格式化、编译和代码质量检查。格式化工具为gofmt，可选的替代工具有goreturns和goimports，在用户或工作区设置中调整go.formatTool来设置。编译的过程使用go build命令。代码质量检查的工具为golint，也可以使用gometalinter，用来检查代码的规范性，检查得到的errors和warning会在编辑器里以红色/绿色波浪线标出来，下面的输出窗口也会显示详细信息。 所有可选的替代工具都需要自己安装，使用快捷键打开命令面板，输入 Go: Install/Update Tools ，选择要安装的工具，点击确定即可。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:3","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"5.4 使用 调试使用的是前面安装的delve工具。在 VScode 中，按F5启动调试，一般情况下使用默认的调试配置即可，不过还是应当对调试配置选项有一定的了解。 默认是没有调试配置文件的，当我们需要进行配置时，输入命令 Debug: Open launch.json ，第一次会在工作区根目录的.vscode文件夹中创建launch.json文件，文件中默认的配置信息如下 { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch\", \"type\": \"go\", \"request\": \"launch\", \"mode\": \"auto\", \"program\": \"${fileDirname}\", \"env\": {}, \"args\": [] } ] } 可设置的配置属性可查看Debugging Go code using VS Code，更多关于VScode中Go调试的相关信息都可查看该文档。 这里需要注意的是args，调试时程序需要传入的参数数组是该配置参数的值 运行程序使用快捷键Ctrl+F5，和调试使用的是同一个配置文件。 ","date":"2019-09-13","objectID":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/:5:4","tags":["Go语法"],"title":"Golang语法基础1-背景与初探","uri":"/2019/golang-basic-grammar-1-background-and-preliminary-exploration/"},{"categories":["Golang学习之路"],"content":"如下列代码，在使用bufio包中的ReadString读取字符串之后，这个字符串无法进行类型转换，每次使用strconv.Atoi()函数返回值均为0。 inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please input a number\") t, err := inputReader.ReadString('\\n') if err != nil { fmt.Println(\"can't read number!\") } fmt.Println(\"the number is\", t) if num, ok := strconv.Atoi(t); ok != nil { fmt.Println(\"convert to int error\", num) } //input 25 //output Please input a number the number is 25 convert to int error 0 因为这种写法其实经常遇到，之前编程的时候遇到这种情况没怎么注意，以为是算法问题，就换思路写了，直到这次只能用这种思路，才发现这里出现了问题。 Stackoverflow上相关的问题回答说这是因为ReadString读取字符串成功后会把'\\n'一起加在字符串后面。查找包说明发现函数的原型和解释如下 func (b *Reader) ReadString(delim byte) (string, error) /* ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. */ 这种情况给出的建议是利用strings.Trim…系列去除末尾添加的字符，比如，对上面的错误程序 inputReader := bufio.NewReader(os.Stdin) fmt.Println(\"Please input a number\") t, err := inputReader.ReadString('\\n') if err != nil { fmt.Println(\"can't read number!\") } fmt.Println(\"the number is\", t) t = strings.TrimRight(t, \"\\n\") if num, ok := strconv.Atoi(t); ok == nil { fmt.Println(\"convert succeed\", num) } //input 25 //output Please input a number the number is 25 convert succeed 25 ","date":"2019-08-27","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-bufio%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-bufio读取的字符串无法直接进行类型转换","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-bufio%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"categories":["Golang学习之路"],"content":"PAT乙级25分的题好多需要根据一个结构体类型的某个字段进行排序，第一次遇到时确实不知所措，然后查了不少解决方案，这里做个总结。 这一问题一般归结为对自定义类型排序，当然，基本指的是结构体，搜到的解决方案也基本是利用sort包。 sort包基本的排序都是针对切片的，直接调用的话能找到整型、浮点型和字符串三种类型切片的排序，最简单的整型排序如下： package main import ( \"fmt\" \"sort\" ) func main() { s := []int{5, 2, 6, 3, 1, 4} // unsorted sort.Ints(s) fmt.Println(s) } //Output:[1 2 3 4 5 6] ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"调用sort.Sort() 不少文章都是通过调用sort.Sort()实现的对结构体的排序，如youyu岁月和Donne的文章就是使用的这种办法。 func Sort(data Interface) Sort函数会调用一次data.Len确定长度，调用O(n*log(n))次data.Less和data.Swap进行排序。但函数不能保证排序的稳定性。而调用Sort首先需要实现一个接口。 type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } 只要实现了Len, Less, Swap三个方法，就能调用Sort实现对结构体的排序，而其中主要就是Less比较逻辑的实现。 先看一下sort包本身对[]int类型的排序实现 // 首先定义了一个[]int类型的别名IntSlice type IntSlice []int // 获取此 slice 的长度 func (p IntSlice) Len() int { return len(p) } // 比较两个元素大小 升序 func (p IntSlice) Less(i, j int) bool { return p[i] \u003c p[j] } // 交换数据 func (p IntSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // sort.Ints()内部调用Sort() 方法实现排序 // 注意 要先将[]int 转换为 IntSlice类型 因为此类型才实现了Interface的三个方法 func Ints(a []int) { Sort(IntSlice(a)) } 然后我们以一个人的结构体为例，结构体中包括其姓名和年龄，按照其年龄对结构体进行排序。 type Person struct { Name string Age int } type ByAge []Person 仿照[]int实现三个方法 func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u003c a[j].Age } 然后写个完整的程序测试看一看 package main import ( \"fmt\" \"sort\" ) type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\"%s: %d\", p.Name, p.Age) } // ByAge implements sort.Interface for []Person based on // the Age field. type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u003c a[j].Age } func main() { people := []Person{ {\"Bob\", 31}, {\"John\", 42}, {\"Michael\", 17}, {\"Jenny\", 26}, } fmt.Println(people) // There are two ways to sort a slice. First, one can define // a set of methods for the slice type, as with ByAge, and // call sort.Sort. In this first example we use that technique. sort.Sort(ByAge(people)) fmt.Println(people) } //输出结果如下： [Bob: 31 John: 42 Michael: 17 Jenny: 26] [Michael: 17 Jenny: 26 Bob: 31 John: 42] 如果要对某个结构体中多个字段进行排序，可以利用嵌套结构体实现，如下面的代码，该代码来自youyu岁月 package main import ( \"fmt\" \"sort\" ) type Person struct { Name string Age int } type Persons []Person // Len()方法和Swap()方法不用变化 // 获取此 slice 的长度 func (p Persons) Len() int { return len(p) } // 交换数据 func (p Persons) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // 嵌套结构体 将继承 Person 的所有属性和方法 // 所以相当于SortByName 也实现了 Len() 和 Swap() 方法 type SortByName struct{ Persons } // 根据元素的姓名长度降序排序 （此处按照自己的业务逻辑写） func (p SortByName) Less(i, j int) bool { return len(p.Persons[i].Name) \u003e len(p.Persons[j].Name) } type SortByAge struct{ Persons } // 根据元素的年龄降序排序 （此处按照自己的业务逻辑写） func (p SortByAge) Less(i, j int) bool { return p.Persons[i].Age \u003e p.Persons[j].Age } func main() { persons := Persons{ { Name: \"test123\", Age: 20, }, { Name: \"test1\", Age: 22, }, { Name: \"test12\", Age: 21, }, } fmt.Println(\"排序前\") for _, person := range persons { fmt.Println(person.Name, \":\", person.Age) } sort.Sort(SortByName{persons}) fmt.Println(\"排序后\") for _, person := range persons { fmt.Println(person.Name, \":\", person.Age) } } ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:1:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"调用sort.Slice() 更简单的是直接调用sort.Slice()，当然，由于golang官方的包说明稳定没法访问，一直查看的是国内的标准库说明文档，完全没有意识到它已经落后了，可能许久未更新，完全没有提到sort包中的Slice函数，但利用这个函数进行自定义类型排序是真有用，还是翻出去看官方说明比较好。 func Slice(slice interface{}, less func(i, j int) bool) sort.Slice()以给定的比较函数排序切片，但并不保证排序的稳定性，想要稳定性，可以调用sort.SliceStable()。因为切片类型的广泛使用，调用sort.Slice()能满足大部分的需求，同时减少了自己实现接口需要实现的Len和Swap两个方法，写法上也更加精炼。一个例子如下： package main import ( \"fmt\" \"sort\" ) func main() { people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Name \u003c people[j].Name }) fmt.Println(\"By name:\", people) sort.Slice(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) fmt.Println(\"By age:\", people) } //Output By name: [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}] By age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] 值得注意的一点是，这里的排序结果依赖于less函数的内容，并不是默认升序，如上述程序。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/:2:0","tags":["Go语法"],"title":"Golang查漏补缺-对自定义类型排序","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E5%AF%B9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F/"},{"categories":["Golang学习之路"],"content":"最近在刷PAT乙级的题，因为PAT考点一般只提供C/C++或Java环境的缘故，网上找到的90%都是C++代码，剩下的又绝大部分是Java，还有一小部分Python，其他语言还真没看到。我用go来刷题，遇到很多问题还真的只能自己慢慢琢磨，倒也很是能锻炼人。 在PAT乙级1015（德才论）和1018（锤子剪刀布）两题中，历经万难，总有测试点显示“运行超时”。仔细一想，不应该啊，go的编译执行速度应该算比较快了，比C++应该差不了多少，这也是go的优点，怎么就运行超时呢，前两天写的时候没想出来，就这么放下了，但这两天心里一直惦记着。知道今天，想到一件事，1015（德才论）还好说，涉及排序，可能算法不够好。1018（锤子剪刀布）一题中也没排序，这么就运行超时了，于是去网上找到了Python解法，竟然过了，彻底陷入了迷惘，go的速度连Python都比不过了吗，肯定有没注意到的地方，于是开始了执行时间优化之旅。 1018（锤子剪刀布）的原始代码如下 /*题目说明 大家应该都会玩“锤子剪刀布”的游戏,现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式： 输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式： 输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例： 10 C J J B C B B B B C C C C B J B B C J J 输出样例： 5 3 2 2 3 5 B B 时间限制: 200 ms 内存限制: 64 MB 代码长度限制: 16 KB */ package main import \"fmt\" func findMax(a [3]int) int { var max, index int for k, v := range a { if v \u003e max { max = v index = k } } return index } func main() { var ( n int jiawin, yiwin int jia, yi [3]int str = \"BCJ\" ) fmt.Scanln(\u0026n) for i := 0; i \u003c n; i++ { var t [2]string fmt.Scanln(\u0026t[0],\u0026t[1]) if t[0] == \"B\" \u0026\u0026 t[1] == \"C\" { jia[0]++ } else if t[0] == \"B\" \u0026\u0026 t[1] == \"J\" { yi[2]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"B\" { yi[0]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"J\" { jia[1]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"B\" { jia[2]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"C\" { yi[1]++ } } jiawin = jia[0] + jia[1] + jia[2] yiwin = yi[0] + yi[1] + yi[2] fmt.Println(jiawin, n-jiawin-yiwin, yiwin) fmt.Println(yiwin, n-jiawin-yiwin, jiawin) fmt.Printf(\"%c %c\", str[findMax(jia)], str[findMax(yi)]) } 检查了半天实在找不到什么地方可以优化的，时间复杂度的大头是for循环，但能迁移出来的代码都已经迁移出来了，结果始终如下图 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:0:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"I/O性能 在google上搜go程序的执行时间怎么优化，最终在golang-nuts讨论组发现一个靠谱的问题以及有用的回答。 原来是I/O读写的问题，fmt包的读写这么不省心吗，怪不得，1015和1015如果测试点是边界值的话，循环要执行10000次，I/O读写出了问题，不超时才怪。看作者在之后的讨论中说他的程序“On my system: C runs in ~50ms, python in ~125ms and go in ~450ms.”也难怪Python都能通过，go通过不了了。 按照其他人的回答，使用bufio包替换了for循环中的fmt进行读取，改进的代码如下： package main import ( \"bufio\" \"fmt\" \"os\" \"strings\" ) func findMax(a [3]int) int { var max, index int for k, v := range a { if v \u003e max { max = v index = k } } return index } func main() { var ( n int jiawin, yiwin int jia, yi [3]int str = \"BCJ\" ) // 用fmt读取输入会有测试点超时 inputReader := bufio.NewReader(os.Stdin) fmt.Scanln(\u0026n) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) if t[0] == \"B\" \u0026\u0026 t[1] == \"C\" { jia[0]++ } else if t[0] == \"B\" \u0026\u0026 t[1] == \"J\" { yi[2]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"B\" { yi[0]++ } else if t[0] == \"C\" \u0026\u0026 t[1] == \"J\" { jia[1]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"B\" { jia[2]++ } else if t[0] == \"J\" \u0026\u0026 t[1] == \"C\" { yi[1]++ } } jiawin = jia[0] + jia[1] + jia[2] yiwin = yi[0] + yi[1] + yi[2] fmt.Println(jiawin, n-jiawin-yiwin, yiwin) fmt.Println(yiwin, n-jiawin-yiwin, jiawin) fmt.Printf(\"%c %c\", str[findMax(jia)], str[findMax(yi)]) } 果然通过了，如下图，最后一个测试点28ms,一想想题目时间限制是200ms，从超时到28，这提升，看起来1015的德才论一题也有救了。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:1:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"排序优化 1018德才论的原始代码如下： /* 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（\u003c100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式： 输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例： 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例： 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 时间限制: 400 ms 内存限制: 64 MB 代码长度限制: 16 KB */ package main import ( \"fmt\" ) //L is student level weight const L = 100000000000000 //S is student grade weight const S = 100000000000 //D is student id weight const D = 100000000 func main() { var ( n, l, h int id, de, cai int sum, level, count int student []int64 ) fmt.Scanln(\u0026n, \u0026l, \u0026h) for i := 0; i \u003c n; i++ { fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = append(student, int64(tmp)) count++ } } for i := 0; i \u003c count; i++ { for j := i; j \u003c count; j++ { if student[i] \u003c student[j] { tmp := student[i] student[i] = student[j] student[j] = tmp } } } fmt.Println(count) for i := 0; i \u003c count; i++ { id = int(D - student[i]%D) sum = int(student[i] % L / S) de = int(student[i] % S / D) cai = sum - de fmt.Println(id, de, cai) } } 其实这已经是优化过了，之前写的时候用的正规的结构体的思路，为了优化，改成这种用权重的剑走偏锋的思路。但提交结果没有丝毫改变，超时就是超时。 改呗，第一个for循环里的输入改成用缓冲区的bufio，按1018的提升幅度，估计可以。改进部分的代码如下。 fmt.Scanln(\u0026n, \u0026l, \u0026h) inputReader := bufio.NewReader(os.Stdin) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) id, _ = strconv.Atoi(string(t[0])) de, _ = strconv.Atoi(string(t[1])) cai, _ = strconv.Atoi(string(t[2])) //fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = append(student, int64(tmp)) count++ } } 第2个测试点过了，但第3，第4个还是没过。 回去一看代码，得，最后一个for循环有输出，用fmt又费不少时间，继续改缓冲区，正巧这时候查到了GO语言基础进阶教程：bufio包，分析了bufio提升文件读写效率的原因，于是参考说明改了输出，如下： fmt.Println(count) buf := bufio.NewWriter(os.Stdout) for i := 0; i \u003c count; i++ { id = int(D - student[i]%D) sum = int(student[i] % L / S) de = int(student[i] % S / D) cai = sum - de buf.WriteString(fmt.Sprintf(\"%d %d %d\\n\", id, de, cai)) } buf.Flush() 没怎么起作用，只是第2个测试点从290ms提升到了272ms。那就只能改排序了，程序里自己写了两层循环，本来以为能过，看来还是得用sort包。改进的完整代码如下： package main import ( \"bufio\" \"fmt\" \"os\" \"sort\" \"strconv\" \"strings\" ) //L is student level weight const L = 100000000000000 //S is student grade weight const S = 100000000000 //D is student id weight const D = 100000000 func main() { var ( n, l, h int id, de, cai int sum, level, count int student []int64 ) fmt.Scanln(\u0026n, \u0026l, \u0026h) inputReader := bufio.NewReader(os.Stdin) for i := 0; i \u003c n; i++ { s, _ := inputReader.ReadString('\\n') t := strings.Fields(s) id, _ = strconv.Atoi(string(t[0])) de, _ = strconv.Atoi(string(t[1])) cai, _ = strconv.Atoi(string(t[2])) //fmt.Scanln(\u0026id, \u0026de, \u0026cai) if de \u003e= l \u0026\u0026 cai \u003e= l { sum = de + cai if de \u003e= h \u0026\u0026 cai \u003e= h { level = 4 } else if de \u003e= h \u0026\u0026 cai \u003c h { level = 3 } else if de \u003c h \u0026\u0026 cai \u003c h \u0026\u0026 de \u003e= cai { level = 2 } else { level = 1 } tmp := level*L + sum*S + de*D + D - id student = ap","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:2:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":["Golang学习之路"],"content":"总结 涉及大量数据的读写时，利用bufio包通过缓冲区进行读写比fmt要快的多。 排序的代码可以调用sort包，不仅仅是自己写两层循环排序的问题，不是必要的情况下，同样的排序算法，自己写的很难说比得过封装好的。更何况，无论是哪种语言，调用的执行排序算法的包其实不是单纯执行快排或堆排序等比较快的排序算法，而是根据输入在调整的，所以不管为了时间性能还是写的方便，直接调用sort包完事儿。 ","date":"2019-08-16","objectID":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/:3:0","tags":["Go语法"],"title":"Golang查漏补缺-程序执行时间优化","uri":"/2019/golang%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"https://www.bilibili.com/video/BV1vL411E7fs?spm_id_from=333.851.b_7265636f6d6d656e64.6，失去信任 看到世卫组织的工作，提升信心 看到家长里短，坑钱商家，失去信心 B站，温铁军，《为什么贫富分化愈发严重》失去信心 QQ空间，东大小红果，祝融号新闻，唤起信心 B站，闫帅奇，军神科普视频，唤起信心 米游社，执望三千里任务的评论，失去信心 金融圈惊呆了！市值300多亿，一年净亏损超1000亿，前董事长已被执行死刑，失去信心 看到现在有人在刻意制造孩子与父母的对立，凡是有问题就把原因归结到父母，失去信心 B站，儿童合唱团oneVoice的合唱，唤起信心，给我唱哭了， 震撼圆梦之声《A Million Dreams》催泪合唱现场！_哔哩哔哩_bilibili 洗涤心灵的合唱现场！童声演绎治愈良曲《I Can Only Imagine》_哔哩哔哩_bilibili 网络安全学习 \\1. cybrary https://www.cybrary.it/ \\2. securitytube http://www.securitytube.net/ \\3. hacking-tutorial https://www.hackingtutorials.org/ \\4. hack this site https://www.hackthissite.org/ \\5. hacking loops https://www.hackingloops.com/ \\6. exploit database https://www.exploit-db.com/ \\7. hellbound hackers https://hbh.sh/home \\8. hack in the box https://www.hitb.org/ –来自百度网盘超级会员V5的分享 hi，这是我用百度网盘分享的内容~复制这段内容打开「百度网盘」APP即可获取 链接:https://pan.baidu.com/s/1icooGlQL_9hRd1duifjFvg 提取码:29d9 ","date":"0001-01-01","objectID":"/1/:0:0","tags":null,"title":"","uri":"/1/"}]